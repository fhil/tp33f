; ^QW: find current word
; ^QS: find current word without first letter (for names that start with an
;      underscore)

; - define the symbol 'MSX' to compile the msx compiler
;   otherwise the PC version will be generated

; - define the symbol 'USELIB' to compile all library routines
; - define the symbol 'NEWEXT' to use the new external routine
; - define the symbol 'EDIT' to use the editor

;EDIT:
;NEWEXT:

USETIMER:

IFNDEF MAKEPC
MSX:
ENDIF

IFDEF MSX
MSXDOS	EQU 5
USELIB:
ENDIF

UPCASE	EQU L04A6

	EXTRN TurboErrorMessages

	PUBLIC COMPILED
         PUBLIC L2D01               ; ask for Yes or No
         PUBLIC L2E76               ; wait for escape
         PUBLIC L4543,L4544,L4546,L4548

	PUBLIC L5271,L5287,L5639,L58C5,L5960,L59E9,L5A0C,L5A17,L5CAD
	PUBLIC L5D76,L5E8E,L5E97,L5EA2,L5EB0,L5EBB,L5EBE,L5ED0,L5EDD,L5EE8
	PUBLIC L6148,L6201,L620F,L6540,L65D5,L65DE,L65E7,L65EF,L65F7,L677F
	PUBLIC L678B,L6A5C,L6B5E,L6CC2,L6D24,L6D43,L6E54
         PUBLIC PARSE_O_IL_C,OP_L_I
	PUBLIC L6F0B,L6F13,L6F1B,L6F5E,L6F66,L6F6E,L6F7E
	PUBLIC L72D4,L72DA,L72E1
	PUBLIC L7B59,L7B5E,L7B6D,L7B6F
	PUBLIC L7B71,L7B72,L7B73,L7B74,L7B8B,L7B9E
	PUBLIC L7BA3,L7BA7
	PUBLIC L7BF1,L7BF2,L7BF3

	PUBLIC TEMPID

	; defined in slib.mac
	EXTRN L7638,L77B1

	INCLUDE stdio.inc

	INCLUDE libdefs.inc

	; include file with generated EQU's from RUNTIME.MAP
	INCLUDE libconst.inc

L20E2:

;         LD A,'A'
;         LD BC,'A'*256+'P'
;         LD HL,File1
;         OR A
;         CALL SetExtension
;
;         CALL PrintASCIIZUPCASED
;         CALL L01E1                 ; print CR, LF
;
;         LD HL,File2
;         CALL PrintASCIIZUPCASED
;         CALL L01E1                 ; print CR, LF
;
;         LD A,'A'
;         LD BC,'A'*256+'P'
;         LD HL,File2
;         OR A
;         CALL SetExtension
;
;         CALL PrintASCIIZUPCASED
;         CALL L01E1                 ; print CR, LF
;
;         LD A,'A'
;         LD BC,'A'*256+'P'
;         LD HL,File3
;         OR A
;         CALL SetExtension
;
;         CALL PrintASCIIZUPCASED
;         CALL L01E1                 ; print CR, LF
;
;         LD A,'A'
;         LD BC,'A'*256+'P'
;         LD HL,File4
;         OR A
;         CALL SetExtension
;
;         CALL PrintASCIIZUPCASED
;         CALL L01E1                 ; print CR, LF
;
;         LD A,'A'
;         LD BC,'A'*256+'P'
;         LD HL,File5
;         OR A
;         CALL SetExtension
;
;         CALL PrintASCIIZUPCASED
;         CALL L01E1                 ; print CR, LF

         JP L215E

;File1:   DB 'TEST.',0,0,0,0,0,0,0,0,0,0
;File2:   DB '\E',0,0,0,0,0,0,0,0,0,0
;File3:   DB 'E\E',0,0,0,0,0,0,0,0,0,0
;File4:   DB 'DIR.PAS',0,0,0,0,0,0,0,0,0,0
;File5:   DB 'TEST.PAS',0,0,0,0,0,0,0,0,0,0

PRINT_SYNTAX:
	CALL L0200
         DB 'Syntax: TURBO <filename> [/C|/H] [/Sxxxx] [/Exxxx] [/Fxxxx]'
; 33e         DB ' [/R[-|<file>]]'
         DB 13,10
	DB '/C            compiles <filename> to COM-file',13,10
	DB '/H            compiles <filename> to CHAIN-file',13,10
	DB '/Sxxxx        code start address (hexadecimal), min. ',0

	LD HL,_L20E2
	CALL L04AF

	CALL L0200
	DB 13,10
	DB '/Exxxx        data end address (hexadecimal), max. ',0

IFDEF MSX
	LD HL,(0006H)
ELSE
	LD HL,(L0006)
ENDIF
	LD BC,-708
	ADD HL,BC
	CALL L04AF

	CALL L0200
	DB 13,10
	DB '/Fxxxx        find runtime error at address xxxx (hexadecimal)',13,10
	DB '/R<file>      generates this error file with a compiler error',13,10
	DB '/R-           generates no error file'
	DB 13,10
	DB 0			; end of string

	LD C,0
	CALL MSXDOS		; quit program


GetParamErrorFileName:
	CALL L0200
	DB 10,'commandline: wrong error file name',13,10,10,0
	JP PRINT_SYNTAX

GetParamHexNumber:
	CALL L0200
	DB 10,'commandline: error in hexadecimal number',13,10,10,0
	JP PRINT_SYNTAX

GetParamUnknownOption:
	CALL L0200
	DB 10,'commandline: illegal option',13,10,10,0
	JP PRINT_SYNTAX

GETPARAM:; in:    -
	; out:	DE = destination for file name
	;	Carry set if error occurred
	;	BC = position of error
	PUSH DE

         LD HL,L0080
	LD E,(HL)
	INC E
	LD D,0
	ADD HL,DE

         XOR A
	LD (HL),A		; quit command-line with a '\0'

	LD A,E
	DEC A			; was it 1 ?
	SCF

	POP DE

	RET Z			; quit with Carry if command-line = empty

	LD HL,L0080+1		; start of command-line
	LD A,'P'
	LD BC,'A'*256+'S'
	CALL ParseName		; parse with default extension 'PAS'

         OR A
         SCF
         RET NZ                     ; quit with carry if error occurred

         PUSH HL

	LD HL,L0080+1
	LD DE,ErrorFileName-1
	LD A,'E'
	LD BC,'R'*256+'R'
	CALL ParseName		; parse with default extension 'ERR'

         POP HL

	OR A
	SCF
         RET NZ                     ; quit with carry if error occurred

	DEC HL
	LD B,H
	LD C,L

	LD HL,ErrorFileName
GETPAR_A:
	INC HL
	LD A,(HL)
	OR A
	JR NZ,GETPAR_A		; repeat while not end of string

GETPAR_B:
	DEC HL
	LD A,(HL)
	CP '.'
	JR NZ,GETPAR_B

	INC HL

	; add '.ERR'
	LD (HL),'E'
	INC HL
	LD (HL),'R'
	INC HL
	LD (HL),'R'
	INC HL
	LD (HL),0

GETPARLP:INC BC
	LD A,(BC)
	OR A
	RET Z			; quit with NonCarry if zero found

	CP '/'
	JR NZ,GETPARLP

GETPAR1:
	INC BC
	LD A,(BC)
	CALL UPCASE

	CP 'C'                     ; '/C' ?
	JR NZ,GETPAR2		; no, next

	; set COM file = TRUE
	LD A,2			; compile to Com-file
	LD (L44F3),A
	JP GETPARLP

GETPAR2:
	CP 'H'                     ; '/H' ?
	JR NZ,GETPAR3		; no, next

	; set CHAIN file = TRUE
	LD A,3			; compile to cHn-file
	LD (L44F3),A
	JP GETPARLP

GETPAR3:
	CP 'S'                     ; '/S' ?
	JR NZ,GETPAR4		; no, next

	CALL GETHEX		; parse hexadecimal number
	JP C,GetParamHexNumber

	; set start address = HL
	LD (L44F4),HL
	DEC BC
	JP GETPARLP

GETPAR4:
	CP 'E'                     ; '/E' ?
	JR NZ,GETPAR5		; no, next

	CALL GETHEX		; parse hexadecimal number
	JP C,GetParamHexNumber

	; set end address = HL
	LD (L44F6),HL
	DEC BC
	JP GETPARLP

GETPAR5:
	CP 'R'                     ; '/R' ?
	JR NZ,GETPAR6

	; parse filename or '-'
	INC BC
	LD A,(BC)
	CP '-'                     ; '/R-' ?
	JP Z,GETPAR51		; jump for no error file

	; file name is given
	; set to string after '/R'
	PUSH BC			; save start address

	LD H,B			; HL = BC = start of new file name
	LD L,C
	LD DE,ErrorFileInfo
	LD A,'E'
	LD BC,'R'*256+'R'
	CALL ParseName

	POP DE			; DE = start address
	JP C,GetParamErrorFileName

	PUSH HL

	OR A
	SBC HL,DE		; HL - DE, end - start
	LD B,H			; BC = length
	LD C,L
	LD HL,ErrorFileName
	EX DE,HL 		; HL = source
				; DE = destination
	LDIR			; fill ErrorFileName with new name

	XOR A
	LD (DE),A		; mark end of destination file name

	POP HL			; HL = address after file name

	LD B,H			; BC = address after file name
	LD C,L
	JP GETPARLP

GETPAR51:; no error file
	; set file name to ""
	LD HL,ErrorFileName
	LD (HL),0		; clear file name
	JP GETPARLP

GETPAR6:
	CP 'F'                     ; '/F' ?
	SCF
         JP NZ,GetParamUnknownOption

	CALL GETHEX		; parse hexadecimal number
	JP C,GetParamHexNumber

	; set search address = HL
	LD (L00CE),HL
	LD A,2
	LD (L7900),A		; compilation with search
	DEC BC
	JP GETPARLP

GETHEX:
	LD HL,0

GETHEX1:
	INC BC
	LD A,(BC)
	OR A
	RET Z			; quit with NonCarry
	CP ' '
	RET Z			; quit with NonCarry

	DEC BC
	CP '/'
	RET Z			; quit with NonCarry
	INC BC

	CALL UPCASE

	SUB '0'
	RET C			; error, no digit
	CP 10
	CCF
	JR NC,GETHEX2		; jump if '0'-'9'

	SUB 7
	RET C			; error, no digit and < 'A'
	CP 16
	CCF
	RET C			; return with Carry if >= 16

GETHEX2:
	ADD HL,HL
	ADD HL,HL
	ADD HL,HL
	ADD HL,HL
	OR L
	LD L,A

	JR GETHEX1

L20E5:
IFDEF MSX
	LD HL,(0006H)
ELSE
	LD HL,(L0006)
ENDIF
	POP BC
	LD SP,HL
	PUSH BC

	LD DE,-1024
	ADD HL,DE
         LD (L4548),HL              ; highest free address 1Kbyte below call 5

L20F2:	LD HL,L7AD7		; address of temp buffer (L00D2)
	LD BC,0000
         CALL L0364                 ; LIB

	RET

L215E:
IFDEF MSX
	LD HL,(0006H)
ELSE
	LD HL,(L0006)
ENDIF
	LD BC,-708
	ADD HL,BC

	LD (L44F6),HL		; compile end address

         CALL InitFileIO

	CALL L0200
IFDEF MSX
         DB 'Z80 TURBO Pascal compiler,             Version 3.3f (DOS 1/2) ',13,10
ELSE
         DB 'Z80 TURBO Pascal cross-compiler,       Version 3.3f ',13,10
ENDIF
         DB 'Copyright (C) MSX computer club Enschede, ''1993-''2000',13,10
	DB 0

	LD DE,L7AD7		; address of temp buffer
	XOR A
	LD (DE),A
         CALL GETPARAM              ; get command line parameters
	JP C,PRINT_SYNTAX 	; print syntax if error and quit program

	LD C,19H
	CALL MSXDOS		; get logged drive
	INC A
	LD (LOGDRV),A		; 1 = A:, 2 = B: etc.
         CALL L20E5

         LD A,'P'
         LD BC,'A'*256+'S'
         LD HL,L7AD7+1
         OR A
         CALL SetExtension

         LD HL,L7AD7+1              ; address of filename
         LD DE,L451D                ; DE = handle/FCB address
         LD A,'P'
         LD BC,'A'*256+'S'
         CALL ParseName             ; parse filename

         CALL L2827                 ; Compile

L223B:	CALL L01E1		; print CR, LF

	LD C,0
	CALL MSXDOS


L232E:	CALL L0200
	DB 'Free: ',0

L2338:	PUSH HL
	PUSH DE
	OR A
	SBC HL,DE
	CALL L2E5C		; print HL in decimal
	CALL L0200
	DB ' bytes (',0
	POP HL
	CALL L04AF
	LD A,'-'
	CALL L03C9		; print '-'
	POP HL
	CALL L04AF
	LD A,')'
	CALL L03C9		; print ')'
	JP L01E1 		; print CR, LF

ENVTPOUT:DB 'TPOUT',0

L27D7:

;         LD HL,L451D                ; assume work filename FCB
;         LD DE,CodeFile
;         LD BC,65                   ; handle/FCB length
;         LDIR

         LD A,(DOS2Present)
         OR A
         JP Z,TPOUT_OLD_STYLE       ; jump if DOS 1

         ; DOS 2

         LD A,(L451D)
         LD (CodeFile),a

         LD HL,ENVTPOUT
         LD DE,CodeFile + 1
         LD B,64
         LD C,6Bh
         CALL MSXDOS                ; retrieve TPOUT environment item value
         OR A
         JP NZ,TPOUT_OLD_STYLE      ; switch to the old style if error occurred

TPOUT_SCAN:
         LD A,(DE)
         OR A
         JR Z,TPOUT_SCAN_END

         INC DE
         JR TPOUT_SCAN

TPOUT_SCAN_END:
         LD HL,L451D + 1

TPOUT_COPY:
         LD A,(HL)
         LD (DE),A
         INC HL
         INC DE
         OR A
         JR NZ,TPOUT_COPY

         JP L27D9                   ; ready

TPOUT_OLD_STYLE:
         LD HL,L451D                ; assume work filename FCB

         LD DE,CodeFile

         LD BC,65                   ; handle/FCB length
         LDIR

L27D9:
IFDEF MSX
	LD HL,(0006H)
ELSE
	LD HL,(L0006)
ENDIF
	LD (L790A),HL		; HL = end of data area

	LD HL,(L4546)		; HL = start of free area
	LD (L7904),HL		; code start address
	RET

L2827:   ; Compile
         CALL L27D7

	LD A,(L44F3)
	SUB 2			; to com-file ? (= 2)
;	 DEC A			 ; to memory?
;	 JP Z,L28AA		 ; jump if to memory

;	 DEC A			 ; to com-file?
	PUSH AF

	JR NZ,L283C		; jump if chain-file

	; to com-file
	LD A,'C'                   ; AHL = 'COM' extension
         LD BC,'O'*256+'M'
	JR L2841

L283C:	; to chain-file
	LD A,'C'                   ; AHL = 'CHN' extension
         LD BC,'H'*256+'N'

L2841:   LD HL,CodeFile+1
         SCF                        ; overrule
         CALL SetExtension

;         LD (L793C),A
;         LD (L793D),HL

	LD A,(L7900)
	OR A
	JR NZ,L2842		; skip if already filled in for search

	LD A,1
	LD (L7900),A		; code generation to disk
L2842:

	LD HL,(L44F4)		; compile start address
	LD (L7904),HL		; new code start address
	LD HL,(L44F6)		; compile end address
	LD (L790A),HL		; new data end address
         LD HL,(L44F4)              ; 33e
         LD (L7BF5+1),HL            ; 33e TODO

         XOR A
         LD (CodeFileCreated),A

         LD A,(L7900)
         DEC A
         JP NZ,L2850                ; skip CodeFile creation if searching

         LD DE,CodeFile+1
         CALL DeleteFile            ; delete old file

         LD HL,CodeFile+1
         LD DE,CodeFile
         LD A,' '
         LD BC,' '*256+' '
         CALL CreateFile
         OR A
         JP NZ,L2A5A                ; jump if error
                                    ; error: Disk or directory full

         LD A,255
         LD (CodeFileCreated),A     ; CodeFile correct created

L2850:

;         LD HL,L7933+FCB_RECSIZE
;         LD (HL),80H                ; record size = 128
;         INC HL
;         LD (HL),0

	POP AF			; NonZero if chain-file
	LD HL,L0100
	JR Z,L2877		; jump if com-file

	LD HL,(L7904)		; HL = code start address

L2877:	LD (L7902),HL
	EX DE,HL

L287B:	LD HL,(L7904)		; HL = code start address
         OR A
         SBC HL,DE                  ; HL - DE
         JR C,L28A9                 ; jump if DE > HL

         LD A,(L7900)
         DEC A
         JP NZ,L28A9                ; jump if searching
                                    ; don't write runtime library

         LD BC,CodeFile

;         LD HL,(L7904)              ; HL = compile start address
;         LD (L0101),HL              ; init start jump at 100H

;         PUSH BC

         PUSH HL                    ; DE = start address of data
         LD HL,L7BF5-100H           ; !!!
	ADD HL,DE
	EX DE,HL
         POP HL

         CALL WriteFile

         PUSH AF
         CALL NZ,CleanUpCodeFile
         POP AF
         OR A
         JP NZ,L2A5A                ; jump if error
                                    ; error: Disk or directory full

;         LD HL,_L20E2
;         LD (L0101),HL
;         OR A
;         JP NZ,L2A5A

;         LD L,C
;         LD H,B
;	 LD HL,128
;         ADD HL,DE
;         EX DE,HL
;         JR L287B

L28A9:
	CALL L0200
	DB 0DH,0AH,'Compiling ',0

;         LD DE,L7933

         LD DE,L451D                ; 33e TODO
         CALL PrintFileName

         LD A,(L7900)
         DEC A
         JR NZ,L28D0                ; jump if searching
                                    ; don't print '--> <filename>'

         CALL L0200
	DB ' --> ',0

         LD DE,CodeFile
         CALL PrintFileName
;         CALL L2DF8                 ; print file name in DE

L28D0:	CALL L01E1		; print CR, LF

IFDEF MSX
	LD HL,0
	LD (0FC9EH),HL
ENDIF
         CALL L454A                 ; enter the real compiler

IFDEF MSX
IFDEF USETIMER
         LD HL,(0FC9EH)
         PUSH HL
ENDIF    ; USETIMER
ENDIF    ; MSX

	LD A,(L7901)
	CP 0CAH			; abort compilation error, keypressed
         JR NZ,L28FA                ; no, continue

         LD A,(L7900)
         DEC A

         CALL Z,CleanUpCodeFile     ; clean mess up if a '.COM' file
                                    ; was generated, if no search was performed


         CALL L0200
	DB 0DH,0AH,0AH,'Compilation aborted',0
	JP L223B 		; print CR, LF and go to DOS

CleanUpCodeFile:
         LD A,(CodeFileCreated)
         OR A
         RET Z                      ; quit if no CodeFile created

         LD BC,CodeFile
         CALL CloseFile             ; try to close the file first

         LD DE,CodeFile+1
         JP DeleteFile

L28FA:
         CALL L0200
	DB 0DH,0AH,0

IFDEF MSX
IFDEF USETIMER
         CALL L0200
         DB 'Time: ',0

         POP HL
         CALL L2E5C                 ; print HL in 5 decimals

         CALL L0200
         DB 0DH,0AH,0
ENDIF    ; USETIMER
ENDIF    ; MSX

	LD A,(L7901)
	OR A
	JP NZ,L2970		; jump if error occurred during compiling

         LD A,(L7900)
	CP 2			; searching while compiling?
         JR NZ,L292A                ; no, skip checking

	CALL L2A7A		; print 'Run-time error position '

	CALL L0200
	DB 'not found',0DH,0AH,0
	JP L223B 		; print CR, LF and go to DOS

L292A:
	LD HL,(L7904)		; HL = code start address
	LD DE,_L20E2		; DE = first available address
	OR A
	SBC HL,DE
;!	pushf
	ADD HL,DE
;!	popf
	CALL NZ,L232E		; print free memory between
				; _L20E2 and compile start address
				; if it is there
         CALL L0200
	DB 'Code: ',0
	LD DE,(L7904)		; DE = code start address
	LD HL,(L7906)		; HL = code end address
	PUSH HL
	DEC HL
	CALL L2338
	POP DE
	LD HL,(L7908)		; HL = data start address
	PUSH HL
	CALL L232E
	POP DE
	INC DE			; DE = data start address
	LD HL,(L790A)		; HL = data end address
	CALL L0200
	DB 'Data: ',0
         CALL L2338

	LD A,0FFH
	LD (COMPILED),A		; compilation completed
	RET

	DB 0			; hoort bij ErrorFileName
ErrorFileName:
	DB 'TURBO.ERR',0           ; 10 bytes
	DS 65-10

ErrorFilePtr:
	DW L7A57
ErrorFileInfo:
	DS 65

ErrorFileWrite:
	POP IX			; HL = return address
	POP BC			;  C = character to print
	LD HL,(ErrorFilePtr)
	LD (HL),C
	INC HL
	LD (ErrorFilePtr),HL
	JP (IX)

ErrorFileMake:
	LD HL,(CON1OUTPTR)
	PUSH HL			; save old routine
	LD HL,ErrorFileWrite
	LD (CON1OUTPTR),HL

	LD HL,ErrorFileName
	LD DE,ErrorFileInfo
	LD A,' '
	LD BC,' '*256+' '
	CALL CreateFile
	JR NZ,ErrorFileMake1

	LD DE,FileCurrentInfo
         CALL PrintFileName
	CALL L01E1		; print CR, LF

	LD HL,(FileBufferLine)
	CALL L2E61		; print line number
	CALL L01E1		; print CR, LF

	CALL GetColumnNumber
	LD L,B
	LD H,0
	CALL L2E61		; print column number
	CALL L01E1		; print CR, LF

	LD HL,(L7901)
	LD H,0
	CALL L2E61		; print error number
	CALL L01E1		; print CR, LF

	LD A,(L7901)
	LD B,A
	CALL PrintErrorMessage
	CALL L01E1		; print CR, LF

	LD A,1AH
	CALL L03C9

	LD HL,(ErrorFilePtr)
	LD BC,L7A57
	OR A
	SBC HL,BC		; HL = length of data to write

	LD BC,ErrorFileInfo
	LD DE,L7A57
	CALL WriteFile		; write to error file
	JR NZ,ErrorFileMake1

	LD BC,ErrorFileInfo
	CALL CloseFile

ErrorFileMake1:
	POP HL
	LD (CON1OUTPTR),HL	; restore old routine
	RET

GetColumnNumber:
	LD B,1			; start at column 1
	LD HL,L79D7		; start of line buffer
	LD DE,(FileBufferLastPos)

GetColumnNumber1:
	CALL CompareHL_DE
	RET NC			; quit if end found

	LD A,(HL)
	INC HL
	CP 9
	JR Z,GetColumnNumberTAB	; TAB stop found

	DEC B
	CP 8
	JR Z,GetColumnNumber1	; BackSpace found
	INC B

	INC B
	JR GetColumnNumber1

GetColumnNumberTAB:
	LD A,B
	DEC A
	AND 7
	NEG
	ADD A,8
	ADD A,B
	LD B,A
	JR GetColumnNumber1

ExpandLine:
	; in:	DE = destination for expanded line buffer
	LD HL,L79D7		; start of line buffer
	LD B,1			; start at column 1

ExpandLine1:
	LD A,(HL)
	INC HL

	OR A
	JR Z,EndOfLine

	CP 9
	JR NZ,ExpandLine2

	CALL PrintTAB		; print spaces
	JR ExpandLine1

ExpandLine2:
	LD (DE),A
	INC DE

	INC B			; next column
	JR ExpandLine1

EndOfLine:
	LD (DE),A
	RET


PrintTAB:; in:	DE = address where to put spaces
	;	B = current column, 1 .. 80
	; out:	DE = address after the new spaces
	;	B = new column
	LD A,B
	DEC A
	AND 7
	NEG
	ADD A,8
	LD C,A
	ADD A,B
	LD B,A

PrintTAB1:
	LD A,' '
	LD (DE),A
	INC DE

	DEC C
	JR NZ,PrintTAB1

	RET

ScanLeftRight:
	; in:	D = left column >= 1
	;	E = total size
	;	B = total chars permitted to the left
	;	C = total chars left
	LD A,D
	CP 1
	JR Z,ScanLeftRight1

	LD A,B
	OR A
	JR Z,ScanLeftRight1
	DEC B			; decrease maximum before

	DEC D			; one more to the left
	INC E
	DEC C			; decrease chars left
	RET Z

	JR ScanLeftRight2

ScanLeftRight1:
	LD A,E
	CP 79
	RET Z			; quit if both at the border

ScanLeftRight2:
	LD A,E
	CP 79
	JR Z,ScanLeftRight	; continue with other side

	INC E			; one more to the right
	DEC C			; decrease chars left
	RET Z

	JR ScanLeftRight

L2970:
         PUSH AF
         CALL CleanUpCodeFile       ; clean mess up if a '.COM' file
                                    ; was generated, if no search was performed
         POP AF

         CP 0FAH                    ; error 250: Disk or directory full
         JP NC,L2A5A
	CP 0C8H			; error 200: run-time error address found
	JR NC,L29EC

	PUSH AF

	LD DE,FileCurrentInfo
	CALL PrintFileName

	CALL L0200
	DB ', line ',0

	LD HL,(FileBufferLine)
	CALL L2E61		; print current line number

	CALL L0200
	DB ', column ',0

	CALL GetColumnNumber
	LD H,0
	LD L,B
	CALL L2E61		; print column number

	CALL L01E1		; print CR, LF

	CALL PrintCurrentLine

	POP AF

	LD B,A
	CALL L0200
	DB 'Error ',0
	LD H,0
	LD L,B
	PUSH BC
	CALL L2E61		; print error number
	POP BC

	CALL L0200
	DB ': ',0

	CALL PrintErrorMessage
	JP L29F8

PrintErrorMessage:
	; in:	B = error code

	LD HL,TurboErrorMessages

L2995:	LD A,(HL)
	CP 1AH
	RET Z			; quit if at end of messages

	CP 20H
	JR C,L29AD

	SUB 30H
	LD C,A
	ADD A,A			; * 2
	ADD A,A			; * 4
	ADD A,C			; * 5
	ADD A,A			; * 10
	INC HL
	ADD A,(HL)
	SUB 30H
	INC HL
	CP B
	JR Z,L29B6

L29AD:	LD A,(HL)
	INC HL
	CP 0DH
	JR NZ,L29AD
	INC HL			; skip LF (0Ah) code
	JR L2995

L29B6:

L29BC:	LD A,(HL)
	CP 0DH
	RET Z			; quit if the end was found

	CP 20H			; < 32 ?
	JR NC,L29E6		; jump if it is printable

	LD DE,TurboErrorMessages

L29C9:	LD A,(DE)
	INC DE
	CP 20H
	JR NC,L29DD

	CP (HL)
	JR NZ,L29DD

L29D2:	LD A,(DE)
	CP 0DH
	JR Z,L29E9
	CALL L03C9		; print character
	INC DE
	JR L29D2

L29DD:	LD A,(DE)
	INC DE
	CP 0DH
	JR NZ,L29DD
	INC DE
	JR L29C9

L29E6:	CALL L03C9		; print character

L29E9:	INC HL
	JR L29BC

L29EC:	CALL L2A7A
	CALL L0200
	DB 'found',0

L29F8:
	LD A,'.'
	CALL L03C9		; print '.'

	LD HL,ErrorFileName
	LD A,(HL)
	OR A
	CALL NZ,ErrorFileMake	; create error file if wanted

         JP L223B

PrintCurrentLine:
	LD DE,FileBuffer
	CALL ExpandLine		; expand all TABS in command line

	CALL GetColumnNumber

	LD D,B			; D = left column number
	LD E,0			; E = starting at a size of 0
	LD BC,40*256+79
	CALL ScanLeftRight

	LD A,E
	OR A
	RET Z			; quit if size = 0

	LD B,A			; B = length of chars to print

	PUSH DE
	LD L,D
	LD H,0
	LD DE,FileBuffer-1
	ADD HL,DE		; HL = start of first character

PrintCurrentLine1:
	LD A,(HL)
	OR A
	JR Z,PrintCurrentLine2	; quit if end of chars found

	CALL L03C9		; print char

	INC HL
	DJNZ PrintCurrentLine1

PrintCurrentLine2:
	CALL L01E1		; print CR, LF

	CALL GetColumnNumber
	POP DE
	LD A,B
	SUB D
	LD B,A
	INC B

PrintCurrentLine3:
	DEC B
	JR Z,PrintCurrentLine4

	LD A,' '
	CALL L03C9		; print char

	JR PrintCurrentLine3

PrintCurrentLine4:
	LD A,'^'
	CALL L03C9
	JP L01E1 	       ; print CR, LF

L2A5A:	CALL L0200
	DB 'Disk or directory full',0

         CALL L2E76                 ; wait for escape
	JP L223B

L2A7A:	CALL L0200
	DB 'Run-time error position ',0
L2A96:	RET


L2D01:   ; asks for Yes or No
	; out: NonZero if 'Y' or 'y' pressed
	;	 Zero if 'n' or 'n' pressed
	CALL L0200
	DB ' (Y/N)? ',0

L2D0D:   CALL L03E1                 ; readkey
	CALL L04A6		; upcase A
	CP 'Y'
	JR Z,L2D1B
	CP 'N'
	JR NZ,L2D0D

L2D1B:   CALL L03C9                 ; print character, choice
	SUB 'N'
	RET

L2D21:	CALL L2D01
	PUSH AF
	CALL L01E1		; print CR, LF
	POP AF
	RET

L2E5C:   LD DE,-5
	JR L2E64

L2E61:   LD DE,-1

L2E64:	PUSH IX
	PUSH IY
	PUSH HL
	PUSH DE
	CALL L149B		; set and check for output
	POP HL
	CALL L1726
	POP IY
	POP IX
	RET

L2E76:   ; wait for escape
	; changes: -
	PUSH AF
	CALL L0200
	DB '. Press <ESC>',0

L2E88:   CALL L03E1                 ; A = character from console
	CP 1BH			; ESC pressed ?
	JR NZ,L2E88		; no, repeat until ESC pressed
	POP AF
	RET

	; TURBO PASCAL COMPILER
L44F1:	DB 0
L44F2:	DB 0

IFDEF MSX
L44F3:	DB 2			; 1 = to memory
				; 2 = to com-file
				; 3 = to chain-file
ELSE	; PC
L44F3:	DB 3			; 1 = to memory
				; 2 = to com-file
				; 3 = to chain-file
ENDIF

L44F4:	DW _L20E2		; compile start address
L44F6:	DW 0			; compile end address
LOGDRV:	DB 0			; logged drive: 1 = A:, 2 = B:

	; FCB with main filename
L44F9:	DB 0
L44FA:	DS 12H			; 18 x '\0'
L450C:	DS 11H			; 17 x '\0'

	; FCB with work filename
L451D:   DS 1 + 64

;L451D:   DB 0
;L451E:   DS 23H                     ; 35 x '\0'

L4541:	DB 0			; zero = no error messages read
				; nonzero = error messages read

COMPILED:DB 0			; 0  = program not compiled
				;255 = program compiled
L4543:	DB 0

L4544:	DW L7BF5 		; at start of text area
L4546:	DW L7BF5 		; start of free area
L4548:	DW 0			; end of free area

L454A:   LD (L7B71),SP              ; save stack pointer to return after an error

	LD HL,L7AD7+1
	CALL FileInit

	LD HL,(L4546)		; HL = start of free area
	INC HL

	LD (L7BDF),HL		; set start address of 1024 bytes
				; update table
	INC H
	INC H
	INC H
	INC H
	LD (L7BE1),HL		; start of free area + 1024

	LD HL,(L790A)		; HL = data end address
	LD (L7908),HL		; start of free data area, growing downwards
	XOR A
	LD H,A
	LD L,A
	LD (L7B91),A		; = 0
	LD (L7B92),A		; = 0
	LD (L7B94),A		; = 0
	LD (L7BA2),A		; = 0, no end of file found
	LD (L7BA0),A		; = 0
	LD (L7BE3),A		; = 0, no updates

	LD (L7B96),A		; = 0, number of the overlay file

	LD (L7BDB),A		; = 0, already read and not dirty

         LD (L7BDD),HL              ; = 0, first block of the file
				; or first block of current overlay part
         LD (CodeFileStart),HL
         LD (CodeFileStart+2),HL

	CALL L718F		; print current line number

	DEC HL
         LD (L7954),HL              ; init at block 65535, no block read yet

         LD (CodeFilePos),HL
         LD (CodeFilePos+2),HL

	LD A,10H
	LD (L7B93),A		; first free type number
				; use by scalar types

	LD A,0F5H
	LD (L7B9D),A		; default:
				; 0, 1 I/O Error Handling on
				; 1, 0 Index Range Checking off
				; 2, 1 Absolute Code on
				; 3, 0 User Interrupt off
				; 4, 1 Array Optimization on
				; 5, 1 Var-parameter Type Checking on
				; 6, 1 I/O Mode Selection on
				; 7, 1 Control S and C interpretation on
         LD A,4
         LD (WITHDEPTH),A           ; init number of 'with' levels

	LD HL,(L4544)		; HL = start of text area
;	 LD (L7BD7),HL		 ; init current position of text in memory
;	 LD (L7BD9),HL		 ; init start of line of text in memory

	LD IX,L79D7		; init line buffer as empty, terminated by 0
	LD (IX+0),0

	LD HL,(L7904)		; HL = code start address
         CALL L6CC2

	LD HL,(L4548)		; HL = end of free area
	DEC HL
	LD (L7B77),HL		; address of the first declared id (CBREAK)
	LD D,H
	LD E,L
	LD BC,L74D2-L731F+1	; length of variable table
				; grows down wards
	OR A
	SBC HL,BC
	LD (L7B73),HL		; bottom of variable table
	LD (L7B75),HL		; same
	LD (L7B7B),HL		; same

;	 CALL SETCHK

	CALL L6BC7		; check compiler overflow, memory overflow
	LD HL,L74D2
	LDDR			; copy standard variable definitions

         CALL L45EA

	LD A,(L7900)
	DEC A
	JR NZ,L45E2		; jump if search (= 2)

	CALL L6C96

         CALL L6CFD                 ; write 128 bytes to file
				; flush last buffer

         PUSH IY
         LD BC,CodeFile
         CALL CloseFile
         POP IY

L45E2:   LD (L7906),IY              ; new code end address
	XOR A
         JP L72E3

L45EA:	CALL L6F95		; get non-blank
	CALL L6E76		; start with PROGRAM?
	DW L7529 		; start of reserved word: PROGRAM
	JR NZ,L460A		; no, skip PROGRAM stuff

	; PROGRAM identifier ( identifier list )
	CALL L4692		; add identifier at IX

	CALL L6F1B		; match('('), if present
	JR NZ,L4607		; jump if '(' not matched

L45FC:	CALL L4692		; add identifier at IX
	CALL L6F13		; match(','), if present
	JR Z,L45FC		; yes, add next identifier

	CALL L6F6E		; match(')')

L4607:	CALL L6F48		; match(';')

L460A:	LD A,31H 		; opcode 'LD SP,'
	LD HL,100H
	CALL O_OPHL		; out: 'LD SP,100H'

	LD HL,L79D7
	LD A,(L7900)
	OR A			; compile to memory?
	JR Z,L4621		; yes, output L79D7

	LD DE,0100H
	CALL L6C30		; allocate 256 bytes of data area

L4621:	CALL O_LDHL		; out: 'LD HL,L79D7'
				;   or 'LD HL,allocated data address'
	LD A,(L7B9D)
	BIT 7,A			; 1 = Control S and C interpretation on
	LD D,0			; assume no interpretation
	JR Z,L462E		; jump if off
	DEC D			; D = 255
L462E:	PUSH DE
	LD A,1
	CALL O_BYTE		; opcode: 'LD BC,'
				; B = 255 if Control S and C interpretation on
				; C = 255 if User Interrupt on

	PUSH IY			; save code pointer
	CALL O_HL		; out: dummy, reserve 2 bytes
	LD HL,_L0364		; LIB, done
	CALL O_CALHL		; out: 'CALL L0364'

	LD A,21H
	CALL O_BYTE		; opcode: 'LD HL,'
	PUSH IY			; save code pointer (1st)

	CALL O_HL		; out: dummy, reserve 2 bytes
	LD A,11H
	CALL O_BYTE		; opcode: 'LD DE,'
	PUSH IY			; save code pointer (2nd)

	CALL O_HL		; out: dummy, reserve 2 bytes

	LD HL,(L790A)		; HL = data end address
	CALL O_LDBC		; out: 'LD BC,data end address

	LD A,(L7900)		; 0 = compiled in memory
				; 1 = compiled to disk
				; 2 = compiled while searching
	LD H,A
	LD L,3EH
	CALL O_HL		; out: 'LD A,value (L7900)'

	LD HL,_L04D4		; LIB, clear
	CALL O_CALHL		; out: 'CALL L04D4'
	CALL L469E

         CALL L52FC                 ; start main program

         LD A,(IX+0)
	CP '.'                     ; '.' ?, needed for 'END.'

	CALL L72DA		; NonZero --> error
	DB 0AH			; error 10: '.' expected

	LD HL,_L20D4		; LIB, done
	CALL O_JPHL		; out: JP L20D4

	POP HL
	LD DE,(L7908)		; DE = data start address
         CALL L6C42                 ; update address at HL with contents of DE

	POP HL
         CALL L6C3F                 ; update address at HL with current address

	POP HL
	POP DE
	LD A,(L7BA0)
	LD E,A
         JP L6C42                   ; update address at HL with contents of DE

L4692:	; add identifier at address IX
	; in:	IX = address of identifier
	; out:	-
	LD HL,(L7B73)		; HL = address to add a identifier
	PUSH HL
	CALL L6D87		; add identifier at address IX
	POP HL
	LD (L7B73),HL
	RET

L469E:	; in:	-
	; out:	-
	LD A,(WITHDEPTH)
	PUSH AF
	ADD A,A
	LD E,A			; DE = 2 * value (WITHDEPTH) bytes to allocate
	LD D,0
         CALL L6C30                 ; HL = address newly allocated data
	PUSH HL
	CALL O_C3		; opcode: 'JP'
	PUSH IY
	PUSH HL
	CALL O_HL		; out: address of allocated data

L46B3:	CALL L6E5A
	DB 1			; 1 byte following every reserved word
	DW L7584 		; start of reserved word list:
				; LABEL, CONST, TYPE, VAR, BEGIN, OVERLAY
				; PROCEDURE, FUNCTION

	CALL L72DA		; NonZero --> error
	DB 0CH			; error 12: BEGIN expected

	LD A,(HL)		; A = byte following the found word

L46BE:	CP 1			; word is 'LABEL' ?
	JR NZ,L46C7		; no, continue


	CALL L488E		; label-declaration-part
	JR L46B3 		; repeat

L46C7:	CP 2			; word is 'CONST' ?
	JR NZ,L46D0		; no, continue

	CALL L48B7
	JR L46BE

L46D0:	CP 3			; word is 'TYPE' ?
	JR NZ,L46D9		; no, continue
	CALL L4AEB
	JR L46BE

L46D9:	CP 4			; word is 'VAR' ?
	JR NZ,L46E6		; no, continue
	CALL L4B2A
	LD HL,(L7908)		; HL = data start address
	EX (SP),HL
	JR L46BE

L46E6:	CP 7			; word is 'OVERLAY' ?
         JP NZ,L485E                ; no, continue

	; start of overlay procedure
	LD A,(L7900)
	OR A			; only overlays when compiling to disk

	CALL L72D4		; Zero --> error
	DB 4DH			; error 77: Overlays not allowed in direct mode

         LD HL,CodeFile+1
         LD DE,TEMPFileData
         LD A,' '
         LD B,A
         LD C,A
         CALL ParseName             ; parse name to get last item

         PUSH BC                    ; save address of last item

;         LD HL,L7934
;         LD DE,L7BB2
;         LD BC,0008
;         LDIR                       ; fill name of overlay file

	; create 0xy
	LD HL,L7B96

         LD A,(HL)
         PUSH AF                    ; save number to put in overlay-info block

         INC (HL)

;         EX DE,HL

;         LD (HL),'0'
;         INC HL

         LD B,'0'-1

L4709:	INC B
	SUB 10
	JR NC,L4709
;         LD (HL),B
;         INC HL

         ADD A,'0' + 10             ; + 10 to compensate for SUB 10
         LD C,A

;         LD (HL),A

         LD A,'0'

         LD HL,TEMPFileData+1
         SCF                        ; overrule current extension
         CALL SetExtension

	LD A,(L7B9D)
         LD HL,_LoadRunOverlayRec

	BIT 2,A			; 1 = Absolute Code on
         JR Z,L470D                 ; jump if not on

         LD HL,_LoadRunOverlay      ; LIB, overlay system call

L470D:
	CALL O_CALHL

         LD HL,-1                   ; initial ID number, nothing loaded
         CALL O_HL                  ;Ok$$$$, will be long with file position
                                    ; as id of loaded overlay
         LD HL,-1
         CALL O_HL

         LD HL,-1
         CALL O_HL                  ; output overlay data length
                                    ; default not present

         POP HL
         LD A,H
         CALL O_BYTE                ; output overlay number

         POP HL                     ; HL = address of last item
                                    ; drive/path/name drive/name
                                    ;            ^          ^
         PUSH HL

         XOR A                      ; lenght of overlay file name = 0
L4723:
         INC A

         DEC (HL)
         INC (HL)

         INC HL

         JR NZ,L4723

         DEC A

         CALL O_BYTE                ; output length of overlay file name

         POP HL

;         LD HL,L7BB2                ; source address overlay file name
         LD B,13                    ; file name is 13 bytes long
                                    ;Ok$$$$, will be ASCIIZ string of 12 bytes
                                    ; + '\0'

L4724:	LD A,(HL)
	CALL O_BYTE
	INC HL
	DJNZ L4724

	LD A,(L7900)
	DEC A
	JR NZ,L473B		; jump if searching

	CALL L6C96		; jump dates

         XOR A
         LD (L7BE3),A               ; no updates

	CALL L6CFD		; write 128 bytes to file, updated record

L473B:
         ;LD HL,(L7BDD)              ; save first block of current part
         ;PUSH HL                    ;Ok$$$$, must be long
                                    ; CodeFileStart
         LD HL,(CodeFileStart+2)
         PUSH HL                    ; save high-word
         LD HL,(CodeFileStart)
         PUSH HL                    ; save low-word

	LD HL,(L7902)		; save first address of current part
	PUSH HL

         LD HL,(L7BB0)              ; save length of largest part
         PUSH HL                    ;Ok$$$$, must be in bytes
                                    ;       now in 128 byte blocks

         LD (L7902),IY              ; set first address of current part

         LD HL,0                    ; #### 0000
         LD (L7BB0),HL              ; set length of largest part = 0

         LD HL,-65                  ; size of handle/FCB
         ADD HL,SP

;         LD HL,-FCB_LEN             ; -36
;         ADD HL,SP                  ; allocate space for a new FCB

	LD SP,HL
	EX DE,HL
         LD HL,CodeFile ; L7933
         LD BC,65 ; FCB_LEN
	LDIR			; copy current FCB to this new space

	LD A,(L7900)
	DEC A
         JP NZ,L478C                ; jump if searching

;         LD HL,L7BB2
;         LD DE,L7933 + 1
;         LD BC,11                   ; length of FCB name
;         LDIR
;
;         EX DE,HL
;         LD B,FCB_LEN - 12          ; length of drive name + name
;L4773:   LD (HL),0
;         INC HL
;         DJNZ L4773

         LD HL,TEMPFileData
         LD DE,CodeFile
         LD BC,65
         LDIR

         LD DE,CodeFile+1
         CALL DeleteFile

         LD HL,CodeFile+1
         LD DE,CodeFile
         LD A,' '
         LD B,A
         LD C,A
         CALL CreateFile

;         LD DE,L7933
;         PUSH DE
;         LD C,13H                   ; delete file
;         CALL DOSIXIY
;         POP DE
;         LD C,16H                   ; create file
;         CALL DOSIXIY
;         INC A

         CALL L72DA                 ; NonZero --> error
	DB 5CH			; error 92: Unable to create overlay file

         LD HL,0
         LD (CodeFileStart),HL
         LD (CodeFileStart+2),HL

L478C:
         LD HL,0
         LD (CodeFileBufferPos),HL  ; start at byte 0 of buffer
         XOR A
	LD (L7BDB),A		; already read and not dirty
;         LD (L7BDC),A               ; start at byte 0 of current block

	LD HL,(L7908)		; HL = data start address
	LD (L7BAB),HL		; save data start address
				; all overlay functions and procedures in
				; the same overlay have the same data
				; start address

L4799:	CALL L6E5A
	DB 1			; 1 byte following
	DW L75A7 		; start of reserved word list:
				; PROCEDURE, FUNCTION

	CALL L72DA		; NonZero --> error
	DB 10H			; error 16: PROCEDURE or FUNCTION expected

         LD A,(HL)                  ; A = 5, PROCEDURE
                                    ; A = 6, FUNCTION

         PUSH IY                    ; save start of overlay code
                                    ; just after the filename

         LD HL,(CodeFileStart)
         LD (CodeFilePos),HL
         LD HL,(CodeFileStart+2)
         LD (CodeFilePos+2),HL

;         LD HL,(L7954)              ; HL = current file position
;                                    ;Ok$$$$, must be long
;         LD (L7BDD),HL              ; save current file position
;                                    ; set start of new part
;                                    ;Ok$$$$, must be long CodeFileStart

	LD HL,(L7908)		; HL = data start address
	PUSH HL			; save old data start address

	LD HL,(L7BAB)
	PUSH HL

	LD E,0FFH		; this procedure, function is an overlay
         CALL L4B3A

         ; HL = address of high byte of struct length
         LD B,H
         LD C,L

	POP DE

	LD HL,(L7908)		; HL = new data start address
	OR A
	SBC HL,DE		; used data of last proc/func >
				;	   biggest data of proc/func
         ADD HL,DE
	JR C,L47C6		; jump not bigger

	EX DE,HL 		; data of last proc/func is largest data

L47C6:	LD (L7BAB),HL		; save biggest data area

	POP HL			; restore old data start address
	LD (L7908),HL		; set new data start address

	POP DE			; DE = start of overlay code


         PUSH BC                    ; address of high byte of struct length

	PUSH DE			; DE = start of overlay code

	LD A,(L7900)
	DEC A
	CALL Z,L6C96		; call if compiling to disk

	XOR A
	LD (L7BE3),A		; 0 = no updates

	POP DE			; DE = start of overlay code
	PUSH DE

         ;Ok$$$$, this part should not be done, that is no round up

         ; this routine rounds the overlay up to a multiple of 128 bytes
;L47DD:   PUSH IY
;         POP HL                     ; HL = address of first byte after overlay
;
;         OR A
;         SBC HL,DE                  ; current address - start of overlay address
;
;         LD A,L
;         AND 7FH
;         JR Z,L47EE                 ; jump if at 128 byte boundary
;
;         XOR A
;         CALL O_BYTE
;         JR L47DD
;
;L47EE:

         PUSH IY
         POP HL

         OR A
         SBC HL,DE                  ; HL = length of current part in bytes

         EX DE,HL
;         ;Ok$$$$, must be length in bytes
;         ADD HL,HL                  ; length in bytes * 2
;         LD E,H                     ; E = number of 128 byte blocks
;         LD D,0
;         RL D

         LD HL,(L7BB0)              ; HL = largest part
	SBC HL,DE
	JR NC,L47FF		; jump largest part > length current part

         LD (L7BB0),DE              ; largest part = length current part
                                    ;Ok$$$$, must be in length in bytes

L47FF:
	POP IY			; IY = start of overlay code

         ;Ok$$$$, DE = must become length of function/procedure in bytes
         POP HL                     ; HL = address of high byte of struct length
	INC HL
	LD (HL),E		; set size of function/procedure code
	INC HL			; to number of 128 byte blocks
	LD (HL),D

         LD HL,(CodeFileStart)
         ADD HL,DE
         LD (CodeFileStart),HL
         LD HL,(CodeFileStart+2)
         LD DE,0
         ADC HL,DE
         LD (CodeFileStart+2),HL

	CALL L6E76
	DW L759F 		; start of reserved word: OVERLAY
         JR Z,L4799                 ; jump if 'OVERLAY'
				; this jump repeats the LOOP

	LD HL,(L7BAB)		; HL = lowest address with data in overlay
	LD (L7908),HL		; continue the with the rest

	LD A,(L7900)
	DEC A
	JR NZ,L4821		; jump if searching

         CALL L6CFD                 ; write 128 bytes to file
				; flush last buffer

         LD BC,CodeFile
         CALL CloseFile

;         LD DE,L7933
;         LD C,10H                   ; close file with generated code
;         CALL DOSIXIY

L4821:	; pop old FCB block (previous overlay or com or chain file)
	LD HL,0000
	ADD HL,SP

;         LD DE,L7933
;         LD BC,FCB_LEN
;         LDIR

         LD DE,CodeFile
         LD BC,65
         LDIR

         LD SP,HL

	LD DE,(L7BB0)		; number of blocks of largest part

	POP HL
         LD (L7BB0),HL              ; restore length of largest part
	POP HL
	LD (L7902),HL		; restore first address of previous part

;         POP HL
;         LD (L7BDD),HL              ; restore first block of previous part
;                                    ;Ok$$$$, CodeFileStart
         POP HL
         LD (CodeFileStart),HL      ; low-word
         POP HL
         LD (CodeFileStart+2),HL    ; high-word

	XOR A
	LD (L7BDB),A		; already read and not dirty

	LD HL,-1
         LD (L7954),HL              ; init, no block read yet
         LD (CodeFilePos),HL
         LD (CodeFilePos+2),HL

	PUSH IY
	POP HL
         CALL L6CC2

         ; create empty area in code file where the overlay is to be loaded
L484E:   LD B,1 ; 80H

L4850:   XOR A
	CALL O_BYTE
	DJNZ L4850
	DEC DE
	LD A,D
	OR E
         JR NZ,L484E                ; until no more to go

         JP L46B3

L485E:	CP 8			; word is 'BEGIN' ?
	JR Z,L486A

	; A = 5, PROCEDURE found
	; A = 6, FUNCTION found
	LD E,0			; this procedure, function is not an overlay
	CALL L4B3A
	JP L46B3

L486A:	; parses the word BEGIN
	CALL L4E8A
	POP DE			; DE = address of allocated memory
	POP HL			; HL = address after 'JP' opcode
	PUSH DE			; save address of allocated memory

	PUSH IY
	POP DE			; DE = IY

	DEC DE
	DEC DE			; DE - 2

	OR A
	SBC HL,DE		; set flags at HL - DE
;!	pushf
	ADD HL,DE		; restore HL
;!	popf
	JR Z,L4880		; no more code generated ?

         CALL L6C3F                 ; update address at HL with current address
	JR L4884

L4880:	DEC HL			; dispose 'JP' opcode

         CALL L6CC2


L4884:	POP DE			; DE = address of allocated memory
	POP HL			; HL = address of allocated memory
	LD (L7BCA),HL
	POP AF			; A = pushed value of (WITHDEPTH)
	LD (L7BC6),A
	RET

L488E:	; SYNTAX: label-declaration-part ::= LABEL label {, label } ;
	; reserved word LABEL already parsed
	LD DE,100H
         CALL L6D75                 ; add DE to id table

	LD A,(IX+0)
	CALL L7282		; letter, underscore or decimal ?

	CALL L6D8D		; carry set --> error
				; error 58: Illegal character in identifier
	LD A,(L7B94)
	CALL L6D7A		; add byte to id table

	LD B,3
L48A5:	LD A,0FFH
	CALL L6D7A		; add byte to id table
	DJNZ L48A5

	CALL L6DC6		; add length
	CALL L6F13		; match(','), if present
	JR Z,L488E		; yes, add next id

	JP L6F48 		; match(';')

L48B7:	LD HL,(L7B73)
	PUSH HL			; push for later setting of type

	LD DE,0000
	CALL L6D75		; add DE to id table
	CALL L6D87		; add identifier to id table
	CALL L6F23		; match('='), if present
	JR NZ,L4901		; jump if '=' not matched

	LD A,0FFH		; default type = INTEGER / LONGINT
	LD (DEF_TYPE),A
	CALL L6A0D		; parse a constant of any type

	LD A,B			; A = type
	CALL L6D7A		; add type (byte) to id table
	LD A,B
	CP 9			; constant type = REAL ?
	JR NZ,L48DB1		; jump if not

	; add real value (6 bytes) to id table
	EXX
	PUSH HL
	PUSH DE
	PUSH BC
	LD B,3

L48DB:	POP DE
	CALL L6D75		; add DE to id table
	DJNZ L48DB
	JR L48FA

L48DB1:	CP 0EH			; type = LONGINT ?
	JR NZ,L48E3		; jump if not

	; add longint value (4 bytes) to id table
	EXX
	PUSH HL
	PUSH DE
	LD B,2			; add 2 words
	JR L48DB

L48E3:	CP 8			; type = STRING ?
	JR NZ,L48F6		; jump if not

	LD HL,L7A57
	LD A,C
	INC C

L48EC:	CALL L6D7A		; add byte to id table
	LD A,(HL)
	INC HL
	DEC C
	JR NZ,L48EC
	JR L48FA

L48F6:	EX DE,HL
	CALL L6D75		; add DE to id table

L48FA:	CALL L6DC6		; add length
	LD D,2			; id type = constant
	JR L4928

L4901:	CALL L6F40		; match(':')
	XOR A
	CALL L6D7A		; add byte to id table
	CALL L6D72		; add IY to id table
				; start of constant address

	LD HL,(L7B73)
	PUSH HL			; push for later setting of type

	CALL L6D75		; add DE to id table
	CALL L6DC6		; add length

	CALL L4F9B		; parse every possible type

	POP HL
	LD DE,(L7B5A)
	LD (HL),D
	DEC HL
	LD (HL),E
	CALL L6F76		; match('=')

	CALL L4937
	LD D,4

L4928:	POP HL
	LD (HL),D
	CALL L6F48		; match(';')
	CALL L6E5A
	DB 1			; 1 byte following
	DW L7584 		; start of reserved word list:
				; LABEL, CONST, TYPE, VAR, BEGIN, OVERLAY
				; PROCEDURE, FUNCTION

	JP NZ,L48B7		; jump if none of these reserved words
				; repeat for next constant

	LD A,(HL)
	RET

L4937:	LD A,(L7B5C)		; A = type
	LD (DEF_TYPE),A
	CP 4
	JR C,L4946		; jump if type = 0, 1, 2 or 3 (SET)

	CP 8
	JR NC,L4946		; jump if STRING, REAL, INTEGER, BOOLEAN,
				;	 CHAR, LONGINT

	CALL L72E1		; no condition
	DB 3DH			; error 61: Files and pointers are
				;	    not allowed here
L4946:	CP 1
	JR NZ,L49A1

	; type = 1
	CALL L6D2A		; push 13, L7B57

	LD HL,(L7B60)
	CALL L5271		; 8 bytes from HL (down) to 7B69 (up)

	LD HL,(L7B6D)
	LD DE,(L7B6B)
	OR A
	SBC HL,DE
	INC HL
	PUSH HL
	LD HL,(L7B5E)		; HL = address of type definition
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)
				; get all information from this type
	POP DE
	LD A,(L7B5C)
	CP 0CH
	JR NZ,L4978
	LD A,D
	OR A
	JR NZ,L4978
	CALL L6F1B		; match('('), if present
	JR NZ,L498A		; jump if '(' not matched
	JR L497B

L4978:	CALL L6F66		; match('(')
L497B:	PUSH DE

	CALL L4937

	POP DE
	DEC DE
	LD A,D
	OR E
	JR Z,L499A
	CALL L6F5E		; match(',')
	JR L497B

L498A:	PUSH DE
	CALL L69FD		; parse string constant
	POP DE
	LD A,C
	CP E

	CALL L72DA		; NonZero --> error
	DB 32H			; error 50: String constant length does not
				;	    match type
	CALL L6B62
	JR L499D

L499A:	CALL L6F6E		; match(')')
L499D:	CALL L6D49		; pop 13, L7B57
	RET

L49A1:	CP 2
	JR NZ,L49FA

	; type = 2
	CALL L6D2A		; push 13, L7B57
	CALL L6F66		; match('(')
	LD A,(L7B5D)
	LD C,A
	LD HL,(L7B62)		; HL = length
	PUSH HL
	LD HL,0000
L49B6:	PUSH BC
	PUSH HL
	LD B,4			; variable identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info

	CALL L72DA		; NonZero --> error
	DB 29H			; error 41: Unknown identifier or syntax
				;	   error

	CALL L5276		; id info at 7B5C
	POP DE
	LD HL,(L7B58)		; HL = lvalue of current id
	OR A
	SBC HL,DE
;!	pushf
	ADD HL,DE
;!	popf

	CALL L72DA		; NonZero --> error
	DB 45H			; error 69: Invalid ordering of fields

	LD DE,(L7B62)		; DE = length
	ADD HL,DE
	PUSH HL
	CALL L6F40		; match(':')

	CALL L4937

	POP HL
	POP BC
	CALL L6F0F		; match(';'), if present
	JR Z,L49B6		; jump if ';' matched
	CALL L6F6E		; match(')')
	POP DE
	EX DE,HL
	OR A
	SBC HL,DE
L49EB:	LD A,H
	OR L
	JR Z,L49F6
	XOR A
	CALL O_BYTE
	DEC HL
	JR L49EB
L49F6:	CALL L6D49		; pop 13, L7B57
	RET

L49FA:	CP 3			; type = SET ?
	JR NZ,L4A7A		; jump if not

	; type = SET
	CALL L6D2A		; push 13, L7B57
	LD HL,(L7B62)		; HL = length
	LD (L7B6F),HL
	LD HL,(L7B5E)		; HL = address of type definition
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)
	CALL L6F30		; match('[')

	LD (L7BA9),IX		; save temporary
	CALL L0581		; LIB, push new empty SET on stack
	LD IX,(L7BA9)		; restore text pointer

	CALL L6EF7		; match(']') or match('.)')
	JR Z,L4A4B		; jump if matched

L4A20:	CALL L4ACA
	PUSH HL

	CALL L6E76
	DW L7580 		; start of reserved word: ..
	JR NZ,L4A37		; jump if no '..'

	CALL L4ACA

	LD (L7BA9),IX		; save temporary
	CALL L059B		; LIB
	JR L4A3F

L4A37:	POP HL
	LD (L7BA9),IX		; save temporary

	CALL L0591		; LIB

L4A3F:	LD IX,(L7BA9)		; restore text pointer
	CALL L6F13		; match(','), if present
	JR Z,L4A20		; jump if ',' matched
	CALL L6F38		; match(']')

L4A4B:	LD HL,L7A57
	LD BC,0020H

	LD (L7BA9),IX		; save temporary
	CALL L0612		; LIB, copy pushed set to the address in HL
	LD IX,(L7BA9)		; restore text pointer

	LD HL,L7A57
	LD A,(L7B5E)
	RRA
	RRA
	RRA
	AND 1FH
	LD E,A
	LD D,0
	ADD HL,DE
	LD A,(L7B6F)
	LD B,A
L4A6F:	LD A,(HL)
	CALL O_BYTE
	INC HL
	DJNZ L4A6F
	CALL L6D49		; pop 13, L7B57
	RET

L4A7A:	CP 8			; type = STRING ?
	JR NZ,L4A99

	; type = STRING
	; typed string constant
	CALL L69FD		; parse string constant

	LD A,(L7B62)		; A = length of constant type
	DEC A			; minus 1 for length byte

	SUB C			; - string constant length
	LD B,A

	JR NC,L4A8D

	; constant type < string constant
	ADD A,C			; restore type length - 1
	LD C,A			; copy constant type bytes
	LD B,0			; no padding at the end

L4A8D:	CALL L6B5E		; output length (C) and data at L7A57
	INC B
L4A91:	DEC B
	RET Z
	XOR A
	CALL O_BYTE
	JR L4A91

L4A99:	CP 9			; type = REAL ?
	JR NZ,L4ABC

	; type = REAL
	CALL L69EA		; parse a constant of any type
				; error if not found
	LD A,B
	CP 9			; type = REAL ?
	JR Z,L4AAF		; jump if type = REAL, no conversion

	CP 0EH			; type = LONGINT ?
	JR Z,L4AAF1		; jump if type = LONGINT, L_R

	CP 0AH			; type = INTEGER ?

	CALL L72DA		; NonZero --> error
	DB 19H			; error 25: Integer, real or longint
				;	   constant expected

	CALL L1008		; convert integer HL to REAL HLDEBC
	EXX

L4AAF:	; output data for REAL constant
	EXX
	PUSH BC
	PUSH DE
	PUSH HL
	LD B,3			; output 3 words

L4AB5:	POP HL
	CALL O_HL
	DJNZ L4AB5
	RET

L4AAF1:	; output data for LONGINT constant
	EXX
	CALL L_R 		; convert longint DEHL to REAL HLDEBC
	EXX
	JR L4AAF

L4ABC:	CP 0EH			; type = LONGINT ?
	JR NZ,L4ABC1

	; type = LONGINT
	CALL L69EA		; parse a constant of any type
				; error if not found
	LD A,B
	CP 9			; type = REAL ?
	CALL L72D4		; Zero --> error
	DB 2CH			; error 44: Type mismatch

	EXX			; DEHL = value
	CP 0EH			; type = LONGINT ?
	JR Z,OUT_LONG
	EXX			; HL = integer value

	CP 0AH			; type = INTEGER ?
	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

	CALL I_L 		; convert integer HL to longint DEHL

OUT_LONG:
	CALL O_HL
	EX DE,HL
	CALL O_HL
	EX DE,HL
	RET

I_L:	; in:	HL = INTEGER, signed
	; out:	DEHL = LONGINT, signed
	LD DE,0
	BIT 7,H
	RET Z			; return if integer is positive

	DEC DE			; make long negative
	RET

L4ABC1:	CALL L4ACA		; make constant range check
	LD A,(L7B62)
	DEC A			; length = 1 ?
	LD A,L
	JP Z,O_BYTE		; output data
	JP O_HL

L4ACA:	; make constant range check
	CALL L69EA		; parse a constant of any type
				; error if not found
	LD A,(L7B5C)
	CP B			; equal types ?

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

	CP 0EH			; type = LONGINT ?
	RET Z			; no range check

	LD DE,(L7B5E)		; DE = minimum value
	CALL L728D		; check if lower bound <= upper bound

	JR C,L4AE7		; jump if lower bound > upper bound

	LD DE,(L7B60)		; DE = maximum value
	CALL L728D		; check if lower bound <= upper bound
	RET C			; return if HL < maximum value
	RET Z			; return if HL = maximum value

L4AE7:	CALL L72E1		; no condition
	DB 2DH			; error 45: constant out of range

L4AEB:	LD HL,(L7B73)
	PUSH HL
L4AEF:	LD HL,(L7B73)
	PUSH HL
	LD DE,0000
	CALL L6D75		; add DE to id table
				; represents the type
	CALL L6D87		; add identifier to id table

	LD HL,(L7B73)
	PUSH HL
	CALL L6D75		; add DE to id table
				; will be filled in later with pointer to
				; the type
	CALL L6DC6		; add length, length is calculated
	CALL L6F76		; match('=')
	CALL L4F9B		; parse every possible type
	POP HL
	LD DE,(L7B5A)
	LD (HL),D
	DEC HL
	LD (HL),E
	POP HL
	LD (HL),3
	CALL L6F48		; match(';')

	CALL L6E5A
	DB 1			; 1 byte following
	DW L7584 		; start of reserved word list:
				; LABEL, CONST, TYPE, VAR, BEGIN, OVERLAY
				; PROCEDURE, FUNCTION

	JR NZ,L4AEF
	LD A,(HL)

	POP HL			; address where to stop reference search
	PUSH AF
	CALL L5295		; update pointer references
	POP AF
	RET

	; name1, name2 : type_name;
L4B2A:	CALL L4F35		; parse variable declarations
	CALL L6F48		; match(';')

	CALL L6E5A
	DB 1			; 1 byte following
	DW L7584 		; start of reserved word list:
				; LABEL, CONST, TYPE, VAR, BEGIN, OVERLAY
				; PROCEDURE, FUNCTION

	JR NZ,L4B2A		; no reserved found, parse more names
	LD A,(HL)		; A = number of one of the reserved words
	RET

L4B3A:   LD B,A                     ; B = 5 if procedure
				; B = 6 if function
	LD C,0
	SUB 5
	LD (L7B97),A		; 0 = procedure, 1 = function

L4B42:	LD A,E
         LD (L7B99),A               ; 0 = no overlay, 255 = overlay

	LD A,(L7B9D)		; compiler directives
	LD (L7B9E),A		; save them

	PUSH BC
	CALL L6DDB		; ID at current position double defined ?
	JP Z,L4C61		; jump if double defined

	POP DE			; DE = type
				; D = 5, PROCEDURE
				; D = 6, FUNCTION
	CALL L6D75		; add DE to id table
	CALL L6D87		; add identifier to id table

	LD HL,(L7B7B)
	PUSH HL			; save add position of first added struct

	LD HL,(L7B75)		; HL = start of added PROC/FUNC struct
	LD (L7B7B),HL
	LD HL,(L7B73)
	PUSH HL			; save add position after identifier
				; for connection
         CALL L6D75                 ; add DE to id table, # different types
         CALL L6D75                 ; add DE to id table, proc/func address
         CALL L6D75                 ; add DE to id table, function type def.
         CALL L6D75                 ; add DE to id table, addr function result
                                    ;                     variable

;         LD DE,(L7BDD)              ; save first block of current PROC/FUNC
;                                    ;Ok$$$$, make long word CodeFileStart
;         CALL L6D75                 ; add DE to id table

         LD DE,(CodeFileStart+2)
         CALL L6D75                 ; save high-word of CodeFileStart
         LD DE,(CodeFileStart)
         CALL L6D75                 ; save low-word of CodeFileStart

         LD DE,0000                 ; length in bytes of procedure/function code
         LD A,(L7B99)
         OR A                       ; Zero = no overlay, NonZero = overlay
         JR Z,L4B45
         DEC DE                     ; init at -1, special meaning
L4B45:
;         LD DE,1
;         LD DE,0000                 ; length in blocks of 128 bytes of
;                                    ; the largest overlay part
;                                    ;Ok$$$$, becomes length in bytes
	CALL L6D75		; add DE to id table

	CALL L6F1B		; match('('), if present
	LD B,0			; assume no dest. type --> procedure
	JR NZ,L4BDA		; jump if no '(', thus no var list

	; start loop for different types
L4B88:	PUSH BC			; push number of different types

	LD HL,(L7B73)
	PUSH HL			; save position for number of vars with
				; same type
	CALL L6D75		; add DE to id table, count + var/no var.
	CALL L6D75		; add DE to id table, address type defs.

	CALL L6E76
	DW L7595 		; start of reserved word: VAR

	LD BC,0000		; B = 0, zero identifiers using same type
				; C = 0, assume no VAR
	JR NZ,L4B9E		; jump if no VAR found

	DEC C			; C = 255, VAR before definition

L4B9E:
	PUSH BC
	CALL L6D87		; add identifier to id table

	POP BC
	INC B			; one more identifier using same type
	CALL L6F13		; match(','), if present
	JR Z,L4B9E		; jump if ',' matched, repeat

	PUSH BC			; save count and VAR flag

	CALL L6F0B		; match(':'), if present
	JR NZ,L4BB8		; jump if ':' not matched
	LD A,C
	LD (L7B8F),A		; 0 = no VAR, 255 = VAR parsed
	CALL L4F18		; L7B5C..L7B63 filled in with type info
	JR L4BC3

L4BB8:	INC C

	CALL L72DA		; NonZero --> error
	DB 2			; error 2: ':' expected

	LD HL,L7512
	LD (L7B5A),HL

L4BC3:	; add count and VAR/NO VAR flag
	POP BC			; pop count and VAR flag

	POP HL
         LD (HL),B                  ; save count
	DEC HL
         LD (HL),C                  ; save VAR flag

	LD DE,(L7B5A)		; DE = address of type definition info
	DEC HL
	LD (HL),D
	DEC HL
	LD (HL),E

	POP BC			; restore number of different types
	INC B			; one more different types
	CALL L6F0F		; match(';'), if present
	JR Z,L4B88		; jump if ';' matched, repeat for next var

	CALL L6F6E		; match(')')

L4BDA:	PUSH BC			; save number of different types
	LD A,(L7B97)		; 0 = proc, 1 = func
	OR A
	JR Z,L4C07		; if proc skip function type

	CALL L6F40		; match(':')
	XOR A
	LD (L7B8F),A		; 0 = no VAR, 255 = VAR
	CALL L4F18		; L7B5C..L7B63 filled in with type info		  ; parse type
	LD A,(L7B5C)
	CP 8			; type = STRING, REAL, INT, BOOL or CHAR ?
	JR NC,L4BF8		; yes, jump
	CP 4

	CALL L72DA		; NonZero --> error
	DB 30H			; error 48: Invalid result type

L4BF8:	POP BC			; restore number of different types

         POP HL                     ; HL = address after PROC/FUNC identifier
         PUSH HL

         PUSH BC

         LD DE,-4
	ADD HL,DE
	LD DE,(L7B5A)		; address of type definition info
	LD (HL),D
	DEC HL
	LD (HL),E

L4C07:	POP BC			; restore number of different types
	POP DE			; DE = position after declared
				; procedure/function name
	POP HL
	LD (L7B7B),HL		; restore

	PUSH DE
	PUSH BC			; save type
	CALL L6DC6		; add length of proc/func definition
	CALL L6F48		; match(';')
	LD A,(L7B99)		; 0 = no overlay, 255 = overlay
	OR A
	JR NZ,L4C44		; jump if overlay

	CALL L6E76		; FORWARD next ?
	DW L7533 		; start of reserved word: FORWARD
	JR NZ,L4C2C		; no, skip

	PUSH IY
	POP DE			; DE = address of 'JP' opcode

	CALL O_JPHL		; output forward jump

         LD A,0FFH                  ; flag for update, update necessary
	JR L4C38

L4C2C:	CALL L6E76		; EXTERNAL next ?
	DW L753A 		; start of reserved word: EXTERNAL
	JR NZ,PF_INL		; jump if not EXTERNAL

IFNDEF NEWEXT
	CALL L69F2		; parse integer constant
	EX DE,HL 		; DE = start address for external routine
	XOR A			; no update necessary
ELSE
	PUSH IY			; save current code address

	CALL L5E97		; parse integer expression

	LD A,0E9H
	CALL O_BYTE		; opcode: JP (HL)

	XOR A			; no update necessary

	POP DE			; start address for external routine
ENDIF

L4C38:	POP BC			; pop type

         POP HL                     ; HL = address after PROC/FUNC identifier
	LD (HL),A		; save update flag
	DEC HL
	LD (HL),B		; save number of different types
	DEC HL
	LD (HL),D		; save proc/func call address
	DEC HL
	LD (HL),E
	JP L6F48 		; match(';')

PF_INL:	CALL L6E76		; INLINE next ?
	DW L75EC 		; start of reserved word: INLINE
	JR NZ,L4C44		; jump if not INLINE

	PUSH IY			; save current code address

	CALL L5698		; parse complete INLINE statement

	XOR A			; no update necessary
	POP DE			; start address for external routine
	JP L4C38

L4C44:	POP BC			; B = number of different types
	POP HL			; HL = position after declared name

	PUSH HL			; save position after declared name
	LD (HL),0		; update flag, 0 = no update
	DEC HL
	LD (HL),B		; save number of different types
	DEC HL

	PUSH IY			; IY = current address in code
	POP DE			; DE = start address of procedure/function

         LD A,(L7B99)               ; 0 = no overlay, 255 = overlay
	OR A
         JR Z,L4C5B                 ; skip if no overlay

	EX DE,HL 		; adjust start address of an overlay

;         LD BC,-16                  ; 16 bytes before address of code generation
;                                    ;Ok$$$$, propably to 20
;         LD BC,-20                  ; overlay-info block length
         LD BC,-24                  ; minus overlay-info block length

         ADD HL,BC
	EX DE,HL

L4C5B:	LD (HL),D		; save start address of proc or func
	DEC HL
	LD (HL),E
	POP HL			; HL = position after declared name
	JR L4C76

L4C61:	LD A,(HL)
	OR A

	CALL L72D4		; Zero --> error
	DB 2BH			; error 43: Duplicate identifier or label

	LD A,(L7B99)		; 0 = no overlay, 255 = overlay
	OR A

	CALL L72DA		; NonZero --> error
	DB 4CH			; error 76: Overlay cannot be forward

	CALL L6E96
	POP DE
	CALL L6F48		; match(';')

L4C76:	EX DE,HL 		; DE = position after declared name

	LD A,(L7B9D)
	LD HL,(L7908)		; HL = data start address

	BIT 2,A			; 1 = Absolute Code on
         JR Z,L4C84                 ; jump if not on

         LD HL,0000                 ; absolute code on
                                    ; remember for this procedure/function

L4C84:   LD (L7B83),HL              ; set data start address

	LD HL,(L7B7B)
	PUSH HL

	LD HL,(L7B73)
	LD (L7B7B),HL
	PUSH HL

	EX DE,HL 		; HL = position after declared name
	LD A,(HL)
	LD (HL),0		; update flag, 0 = no update
	DEC HL
	LD B,(HL)		; B = number of different types
	DEC HL
	LD D,(HL)		; DE = procedure/function address
	DEC HL
	LD E,(HL)
	DEC HL
	OR A
	JR Z,L4CA7		; jump if no update necessary

	PUSH HL
	EX DE,HL
	INC HL
         CALL L6C3F                 ; update address at HL with current address
	POP HL

L4CA7:	LD A,(L7B97)		; 0 = proc, 1 =func
	OR A
	JR Z,L4CD2		; jump if procedure

	LD D,(HL)		; DE = address of function result type
	DEC HL
	LD E,(HL)
	DEC HL
	PUSH HL
	EX DE,HL
         CALL L5287                 ; 8 bytes from HL (down) to 7B5C (up)
				; get all information on this type
	LD A,(L7B5C)
	LD (L7B87),A
	LD HL,(L7B62)		; HL = size of the type
	LD A,L
	LD (L7B88),A
	EX DE,HL
	CALL L6C30		; allocate DE bytes of data for this type
	LD (L7B89),HL
	EX DE,HL
	POP HL
	LD (HL),D
	DEC HL
	LD (HL),E
	DEC HL
	JR L4CD6

L4CD2:   LD DE,-4                   ; skip function type definition and
                                    ; function result variable address
	ADD HL,DE

L4CD6:   LD DE,-6                   ; -4
	ADD HL,DE
	PUSH HL

         LD C,0                     ; start at variable 0

         LD A,B
	OR A
         JR Z,L4D2B                 ; quit if 0 different types

         ; loop for variables with different type
L4CE1:   LD A,(HL)                  ; A = count, # variables with same type
	ADD A,C
	LD C,A
	PUSH BC

         LD B,(HL)                  ; B = count, # variables with same type
	DEC HL

         LD A,(HL)
	LD (L7B8F),A		; 0 = no VAR, 255 = VAR
	DEC HL

         LD D,(HL)                  ; DE = address of type definition info
	DEC HL
	LD E,(HL)
	DEC HL

         PUSH HL

         EX DE,HL
         LD (L7B5A),HL              ; HL = address of type definition info

         CALL L5287                 ; 8 bytes from HL (down) to 7B5C (up)

         LD HL,(L7B73)

         EX (SP),HL

         PUSH BC

         ; loop for variables with same type
L4CFD:   PUSH BC
	LD DE,400H
	CALL L6D75		; add DE to id table

L4D04:	LD A,(HL)

         CALL L6D7A                 ; add byte to id table

	BIT 7,(HL)
;!	pushf
	DEC HL
;!	popf
         JR Z,L4D04                 ; until end of identifier

	PUSH HL
	CALL L6D7A		; add byte to id table
	CALL L6D75		; add DE to id table
	CALL L6D75		; add DE to id table
	CALL L6DC6		; add length
	POP HL
	POP BC
         DJNZ L4CFD                 ; repeat for variables with same type

         POP BC

         EX (SP),HL

         XOR A
	LD (L7B90),A		; 0 = not absolute, 255 = absolute

         CALL L4F52

         POP HL
	POP BC

         DJNZ L4CE1                 ; repeat for variables with different type

L4D2B:
         LD B,C                     ; B = total number of variables

         PUSH BC

	LD HL,(L7B73)
	PUSH HL

         LD HL,(L7B83)              ; save data start address
         PUSH HL                    ; equals 0 if it is absolute code

	LD HL,(L7B89)
	PUSH HL

	LD A,(L7B87)
	PUSH AF

	LD A,(L7B88)
	PUSH AF

         LD A,(L7B99)               ; 0 = no overlay, 255 = overlay
         PUSH AF

	LD A,(L7B97)		; 0 = proc, 1 = func
	PUSH AF

	LD HL,L7B94
         INC (HL)                   ; increase level

         CALL L469E

	POP AF
	LD (L7B97),A		; restore: 0 = proc, 1 = func

         POP AF
         LD (L7B99),A               ; 0 = no overlay, 255 = overlay

	POP AF
	LD (L7B88),A

	POP AF
	LD (L7B87),A

	POP HL
	LD (L7B89),HL

	POP HL
         LD (L7B83),HL              ; restore data start address
	LD (L7B85),DE

	LD A,H
	OR L
	JR Z,L4D79

	SBC HL,DE
	JR Z,L4D79

	CALL O_LDBC

	EX DE,HL
	CALL O_LDHL

	LD HL,_L0508		; LIB, heap alloc, clear
	CALL O_CALHL

L4D79:	POP HL
	POP BC
	INC B
	DEC B
         JP Z,L4DF3                 ; jump if no variables

	CALL O_CODE
	DB 2
	DB 0FDH,0E1H		; POP IY

L4D86:	PUSH BC
	INC HL
	LD E,(HL)
	INC HL
	LD D,(HL)
	ADD HL,DE
	PUSH HL
	DEC HL
	DEC HL
L4D8F:	BIT 7,(HL)
;!	pushf
	DEC HL
;!	popf
	JR Z,L4D8F
	CALL L5276		; id info at 7B5C
	LD A,(L7B57)
	OR A
	JR NZ,L4DD4

	LD A,(L7B5C)
	CP 3
	JR C,L4DBD
	JR Z,L4DE6

	CP 4			; type = POINTER ?
	JR Z,L4DE3

	CP 8
	JR C,L4DBD
	JR Z,L4DE6

	CP 0EH			; type = LONGINT ?
	JR Z,POPLONG		; jump to generate code for it

	CP 0AH
	JR NC,L4DE3

	; output code to pop REAL
	CALL O_CODE
	DB 3
	DB 0E1H			; POP HL
	DB 0D1H			; POP DE
	DB 0C1H			; POP BC

	JR L4DE6

POPLONG: CALL O_CODE
	DB 2
	DB 0E1H			; POP HL
	DB 0D1H			; POP DE

	JR L4DE6

L4DBD:	CALL O_POPHL
	LD HL,(L7B58)		; HL = lvalue of current id
	CALL O_LDDE		; output: 'LD DE,value HL'
	LD HL,(L7B62)
	CALL O_LDBC

	CALL O_CODE
	DB 2
	DB 0EDH,0B0H		; LDIR

	JR L4DE9

L4DD4:	XOR A
	LD (L7B57),A
	LD A,4
	LD (L7B5C),A		; type = pointer
	LD HL,0002
	LD (L7B62),HL		; lenght = 2

L4DE3:	CALL O_POPHL

L4DE6:	CALL L661B
L4DE9:	POP HL
	POP BC
	DJNZ L4D86

	CALL O_CODE
	DB 2
	DB 0FDH,0E5H		; PUSH IY

L4DF3:
         CALL L52FC                 ; start begin end part

         LD HL,L7B94
         DEC (HL)                   ; decrease level

         LD A,(L7B97)               ; 0 = proc, 1 = func
	OR A
         JR Z,L4E46                 ; jump if proc

         LD HL,(L7B89)
	LD A,(L7B87)
	CP 8			; type = STRING ?
	JR NZ,L4E24		; jump if not STRING

	LD B,A

	CALL O_CODE
	DB 2
         DB 0FDH,0E1H               ; POP IY, save return address

	LD A,21H
	CALL O_OPHL		; LD HL, HL

	LD HL,_L053A		; LIB, clear
	CALL O_CALHL

	CALL O_CODE
	DB 2
         DB 0FDH,0E5H               ; PUSH IY, restore return address

         ; stack: STRING
         ;        return address

	JR L4E46

L4E24:	CP 9
	JR NZ,L4E35

	LD A,21H
	CALL O_OPHL		; LD HL, HL

	LD HL,_L052C		; LIB, GETFLT
	CALL O_CALHL		; CALL _L052C
	JR L4E46

L4E35:	LD A,2AH
	CALL O_OPHL		; LD HL,( HL )

	LD A,(L7B88)
	DEC A
	JR NZ,L4E46

	CALL O_CODE
	DB 2
	DB 26H,00H		; LD H,0

L4E46:   LD HL,(L7B83)
	LD A,H
	OR L
         JR Z,L4E78                 ; jump if absolute code

         ; HL = data start address

         LD DE,(L7B85)
	SBC HL,DE
	JR Z,L4E74

         LD A,(L7B97)               ; 0 = proc, 1 = func
	OR A
	JR Z,L4E65		; no EXX if a procedure call

	LD A,(L7B87)
         CP 8                       ; type = STRING ?

         LD A,0D9H                  ; opcode: EXX
         CALL NZ,O_BYTE             ; yes, output EXX

L4E65:	CALL O_LDBC
	EX DE,HL
	CALL O_LDDE		; output: 'LD DE,value HL'

         LD HL,_L0522               ; LIB, heap de-alloc
         CALL O_CALHL

;         JR L4E79

L4E74:   ; recursive code

         LD A,(L7B97)               ; 0 = proc, 1 = func
	OR A
         JR Z,L4E76                 ; no EXX if a procedure call

	LD A,(L7B87)
         CP 8                       ; type = STRING ?

         LD A,0D9H                  ; opcode: EXX
         CALL NZ,O_BYTE             ; yes, output EXX

L4E76:
         LD A,(L7B99)
         OR A
         JR Z,L4E78                 ; jump if no overlay

         POP DE                     ; DE = address of high byte of PROC/FUNC
                                    ; struct length
         PUSH DE

         LD HL,12
         ADD HL,DE
         LD A,(HL)
         DEC HL
         LD L,(HL)
         LD H,A                     ; HL = address of overlay proc

         INC HL                     ; skip CALL instruction
         INC HL
         INC HL

         CALL O_LDHL                ; output: 'LD HL,value HL'

         LD HL,_OverlayRec1         ; LIB, Load only overlay code
	CALL O_JPHL

         JR L4E79

L4E78:   CALL O_CODE                ; output: ret
	DB 1
	DB 0C9H			; RET

L4E79:   CALL L6F48                 ; match(';')

         POP DE                     ; DE = address of high byte of PROC/FUNC
                                    ; struct length

         POP HL
         LD (L7B73),HL              ; HL = address after PROC/FUNC struct length
	LD (L7B75),HL

         POP HL
         LD (L7B7B),HL              ; HL = position after declared PROC/FUNC
                                    ;      name
         EX DE,HL
         ; HL = high byte of struct length
         ; DE = position after declared PROC/FUNC name
	RET

L4E8A:	LD HL,(L7B73)		; HL = address to add an identifier
L4E8D:	LD DE,(L7B7B)		; HL = start of identifier list
	OR A
	SBC HL,DE
;!	pushf
	ADD HL,DE
;!	popf
	RET Z			; quit if no identifiers
	INC HL
	LD E,(HL)		; DE = offset
	INC HL
	LD D,(HL)
	ADD HL,DE
	LD A,(HL)
	CP 6
	JR Z,L4EA4
	CP 5
	JR NZ,L4E8D
L4EA4:	PUSH HL
	DEC HL
	DEC HL
L4EA7:	BIT 7,(HL)
;!	pushf
	DEC HL
;!	popf
	JR Z,L4EA7
	LD A,(HL)		; A = byte after name
	OR A

	CALL L72DA		; NonZero --> error
	DB 49H			; error 73: Undefined FORWARD procedure(s)

	POP HL
	JR L4E8D

L4EB5:	; in:	-
	; out:	HL = top of stack before variable name declarations
	;	 B = number of variable name declarations
	LD HL,(L7B73)
	PUSH HL
	LD B,0
L4EBB:	PUSH BC
	LD D,4
	LD A,(L7B91)
	LD E,A
	CALL L6D75		; add DE to id table
	CALL L6D87		; add identifier to id table
	CALL L6D7A		; add byte to id table
	CALL L6D75		; add DE to id table
	CALL L6D75		; add DE to id table
	CALL L6DC6		; add length
	POP BC
	INC B
	CALL L6F13		; match(','), if present
	JR Z,L4EBB		; yes, an other declaration
	POP HL
	RET

L4EDD:	LD HL,(L7B73)
	PUSH HL
	CALL L4F9B		; parse every possible type

	POP HL			; address where to stop reference search
	CALL L5295		; update pointer references

	CALL L6E76		; followed by 'ABSOLUTE'?
	DW L7562 		; start of reserved word: ABSOLUTE

	LD A,0			; assume no 'absolute'
	JR NZ,L4F14		; no, continue

	LD A,(L7B91)
	OR A

	CALL L72DA		; NonZero --> error
	DB 4BH			; error 75: Illegal use of ABSOLUTE

	LD BC,400H		; variable identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info
	JR NZ,L4F0C		; no variable identifier, try address

	LD A,(HL)
	LD (L7B8F),A		; 0 = no VAR, 255 = VAR
	DEC HL
	LD D,(HL)		; DE = lvalue of variable
	DEC HL
	LD E,(HL)
	EX DE,HL
	JR L4F0F

L4F0C:	CALL L69F2		; parse integer constant

L4F0F:	LD (L7B7F),HL
	LD A,0FFH		; absolute anyway

L4F14:	LD (L7B90),A		; 0 = not absolute, 255 = absolute
	RET

L4F18:
	; L7B5C..L7B63 filled in with type info
	CALL L4FC8		; find type identifier
				; and fill L7B5C..L7B63
	JR Z,L4F181		; jump if type identifier found

	CALL L6E76
	DW L754D 		; start of reserved word: FILE

	CALL L72DA		; NonZero --> error
	DB 24H			; error 36: Type identifier expected

	LD HL,FILEDEF		; address of definition of type
	LD (L7B5A),HL		; save address to definition info
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)

L4F181:
	XOR A
	LD (L7B90),A		; 0 = not absolute, 255 = absolute

	LD A,(L7B8F)		; 0 = no VAR, 255 = VAR
	OR A
	RET NZ			; return if VAR
	LD A,(L7B5C)
	CP 5
	RET C
	CP 8
	RET NC

	; error: 5 (typed file), 6 (text) and 7 (untyped file)
	CALL L72E1		; no condition
	DB 43H			; error 67: Files must be variable parameters

L4F35:	CALL L4EB5		; parse variable names
	PUSH HL			; save variable position
	PUSH BC			; save number of names parsed
	CALL L6F40		; match(':')
	XOR A
	LD (L7B8F),A		; 0 = no VAR, 255 = VAR
	CALL L4EDD
	POP BC
	LD A,(L7B90)		; 0 = not absolute, 255 = absolute
	OR A			; absolute?
	JR Z,L4F51		; no, continue
	LD A,B
	DEC A

	CALL L72DA		; NonZero --> error
	DB 4BH			; error 75: Illegal use of ABSOLUTE

L4F51:	POP HL

L4F52:	; in:	B = number of variable names parsed before the type
	PUSH BC
	PUSH HL
	LD A,(L7B8F)		; 0 = no VAR, 255 = VAR
	LD HL,0002		; assume size = 2 if VAR
	OR A
	JR NZ,L4F60		; jump if VAR
	LD HL,(L7B62)		; get real size

L4F60:	EX DE,HL
	LD A,(L7B91)
	OR A
	JR NZ,L4F72
	LD A,(L7B90)		; 0 = not absolute, 255 = absolute
	OR A			; variable at absolute address ?
	JR NZ,L4F72		; yes, no allocation

	CALL L6C30		; allocate data space, HL = address
	JR L4F7B

L4F72:	LD HL,(L7B7F)
	PUSH HL
	ADD HL,DE
	LD (L7B7F),HL
	POP HL
L4F7B:	EX DE,HL 		; DE = address of variable space
	POP HL			; HL = start of declaration
	DEC HL
L4F7E:	DEC HL
	BIT 7,(HL)
	JR Z,L4F7E
	DEC HL			; HL = points to byte after name
	LD A,(L7B8F)		; 0 = no VAR, 255 = VAR
	LD (HL),A		; place on byte after name
	DEC HL
	LD (HL),D		; high byte of variable space address
	DEC HL
	LD (HL),E		; put low byte
	DEC HL
	LD DE,(L7B5A)		; type info address
	LD (HL),D
	DEC HL
	LD (HL),E
	DEC HL			; point to high byte of offset
	DEC HL			; point to low byte of offset
	DEC HL			; address of next possible declaration
	POP BC
	DJNZ L4F52		; repeat for the next variable
				; of the same type
	RET

L4F9B:	; in:	HL = start of identifier list
	; out:	-
	CALL L4FC8		; find type identifier
	RET Z			; quit if found

	CALL L6E76
	DW L7542 		; start of reserved word: PACKED
				; just reads(eats) it away

	CALL L4FDB		; parses an ARRAY
	RET Z			; quit if an ARRAY was parsed

	CALL L5039		; parses a RECORD
	RET Z			; quit if a RECORD was parsed

	CALL L5106		; parses a SET
	RET Z			; quit if a SET was parsed

	CALL L5140
	RET Z

	CALL L516B		; parses a FILE
	RET Z			; quit if a FILE was parsed

	CALL L51A5		; parses a STRING type
	RET Z			; quit if a STRING was parsed

	CALL L51C5		; parses a SCALAR type
	RET Z			; quit if a SCALAR type was parsed

	CALL L5210		; parses a subrange-type
	RET Z			; quit if a <m>..<n> parsed

	CALL L72E1		; no condition
	DB 24H			; error 36: Type identifier expected

L4FC8:	; SYNTAX: type-identifier ::= identifier
	; in:	IX = address of current type identifier in text
	; out:	Z = 0, type identifier found and L7B5C..L7B63 filled in
	LD BC,300H		; type identifier ?
	CALL L6E54		; check if current in id list, types
				; HL = address of info
	RET NZ			; quit if type identifier not found

	; HL = address of pointer to definition of type
	LD D,(HL)		; DE = address of type definition
	DEC HL
	LD E,(HL)
	EX DE,HL
	LD (L7B5A),HL		; save address to definition info
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)
	XOR A
	RET

L4FDB:	; parses a complete ARRAY type
	CALL L6E76
	DW L7548 		; start of reserved word: ARRAY
	RET NZ

	CALL L6F30		; match('[')

	LD B,0			; 0 indices

L4FE6:	PUSH BC
	CALL L523B		; parse a simple-type = index-type
	POP BC

	LD HL,(L7B5A)		; HL = address of type info
	PUSH HL

	LD HL,(L7B60)		; HL = maximum value
	LD DE,(L7B5E)		; DE = minimum value
	OR A
	SBC HL,DE
	INC HL
	LD A,H
	OR L

	CALL L72D4		; Zero --> error
	DB 62H			; error 98: Memory overflow

	PUSH HL			; push range size

	INC B			; increase # indices
	CALL L6F13		; match(','), if present
	JR Z,L4FE6		; jump if ',' matched

	PUSH BC

	CALL L6F38		; match(']')
	CALL L6F88		; match('OF')
	CALL L4F9B		; parse every possible type

	POP BC			; B = # indices

	; parsed: 0..15 , 15..32
	; stack: 	<type info>	info of 0..15
	;		<range size>	16
	;		<type info>	info of 15..32
	;		<range size>	18

L5012:	LD HL,(L7B5A)		; HL = address of last type info
	LD (L7B5E),HL

	LD HL,(L7B62)		; HL = total size of array declaration

	POP DE			; DE = range size of last

	PUSH BC			; save count
	CALL L729A		; multiply HL = HL * DE

	CALL L72C8		; carry set --> error
	DB 62H			; error 98: Memory overflow
	POP BC			; restore count

	LD (L7B62),HL		; set new size of array declaration

	POP HL
	LD (L7B60),HL		; HL = address to info about index-type
	LD A,1
	LD (L7B5C),A
	PUSH BC
	CALL L5254		; add L7B5C..L7B63 as new struct
				; L7B5A = address of this struct
	POP BC
	DJNZ L5012
	RET

L5039:	; parses a complete RECORD type
	CALL L6E76
	DW L7554 		; start of reserved word: RECORD
	RET NZ
	LD A,(L7B9A)
	PUSH AF
	LD A,(L7B91)
	PUSH AF
	LD HL,L7B92
	INC (HL) 		; increase depth within record ?
	LD A,(HL)
	LD (L7B91),A
	LD HL,(L7B7F)
	PUSH HL
	LD HL,(L7B81)
	PUSH HL
	LD HL,0000
	LD (L7B7F),HL
	LD (L7B81),HL
	XOR A
	LD (L7B9A),A
	CALL L508B
	LD HL,(L7B81)
	LD (L7B62),HL
	POP HL
	LD (L7B81),HL
	POP HL
	LD (L7B7F),HL
	LD A,(L7B91)
	LD (L7B5D),A
	POP AF
	LD (L7B91),A
	POP AF
	LD (L7B9A),A
	LD A,2
	LD (L7B5C),A
	JP L5254 		; add L7B5C..L7B63 as new struct
				; L7B5A = address of this struct

L508B:	CALL L50F9
	RET Z
	CALL L6E76
	DW L75DA 		; start of reserved word: CASE
	JR Z,L50B0
	CALL L4F35
	LD HL,(L7B7F)
	LD DE,(L7B81)
	OR A
	SBC HL,DE
	JR C,L50A9
	ADD HL,DE
	LD (L7B81),HL
L50A9:	CALL L6F0F		; match(';'), if present
	JR Z,L508B		; jump if ';' matched
	JR L50E8

L50B0:	CALL L4FC8		; find type identifier
	CALL NZ,L4F35

	CALL L6F88		; match('OF')

L50B9:	CALL L50F9
	RET Z

	LD HL,(L7B7F)
	PUSH HL

L50C1:	CALL L69EA		; parse a constant of any type
				; error if not found
	CALL L6F13		; match(','), if present
	JR Z,L50C1		; jump if ',' matched
	CALL L6F40		; match(':')
	CALL L6F66		; match('(')
	LD A,(L7B9A)
	PUSH AF
	LD A,0FFH
	LD (L7B9A),A
	CALL L508B
	POP AF
	LD (L7B9A),A
	POP HL
	LD (L7B7F),HL
	CALL L6F0F		; match(';'), if present
	JR Z,L50B9		; jump if ';' matched
L50E8:	LD A,(L7B9A)
	OR A
	JP NZ,L6F6E		 ; match(')')
	CALL L6E76
	DW L7530 		; start of reserved word: END
	RET Z

	CALL L72E1		; no condition
	DB 0EH			; error 14: END expected

L50F9:	LD A,(L7B9A)
	OR A
	JP NZ,L6F1F		; match(')'), if present
				; and return
	CALL L6E76
	DW L7530 		; start of reserved word: END
	RET

L5106:	; parses a complete SET type
	CALL L6E76
	DW L7551 		; start of reserved word: SET
	RET NZ
	CALL L6F88		; match('OF')
	CALL L523B		; parse a simple-type = base-type
	LD HL,(L7B60)
	LD DE,(L7B5E)
	LD A,H
	OR D

	CALL L72DA		; NonZero --> error
	DB 46H			; error 70: Set base type out of range

	SRL L
	SRL L
	SRL L
	SRL E
	SRL E
	SRL E
	LD A,L
	INC A
	SUB E
	LD L,A
	LD (L7B62),HL
	LD HL,(L7B5A)
	LD (L7B5E),HL
	LD A,3
	LD (L7B5C),A		; type = SET
	JP L5254 		; add L7B5C..L7B63 as new struct
				; L7B5A = address of this struct

L5140:	CALL L6F27		; match('^')
	RET NZ
	LD DE,0000
	CALL L6D75		; add DE to id table
	LD HL,(L7B73)
	PUSH HL
	CALL L6DBA
	CALL L6DC6		; add length
	POP HL
	LD (L7B5E),HL
	LD A,4			; type = POINTER
	LD (L7B5C),A
	LD A,0FFH
	LD (L7B5D),A
	LD HL,0002
	LD (L7B62),HL		; length = 2 bytes
	JP L5254 		; add L7B5C..L7B63 as new struct
				; L7B5A = address of this struct

L516B:	; parses a complete FILE type
	CALL L6E76
	DW L754D 		; start of reserved word: FILE
	RET NZ			; return if no FILE found

	CALL L6E76
	DW L7560 		; start of reserved word: OF
	JR NZ,L5197		; jump if no OF found, untyped file found

	CALL L4F9B		; parse every possible type

	LD A,(L7B5C)
	CP 5
	JR C,L518A		; < 5, a typed file
	CP 8
	JR NC,L518A		; jump if >= 8

	CALL L72E1		; no condition
	DB 44H			; error 68: File components can not be files

L518A:	LD HL,(L7B5A)
	LD (L7B5E),HL
	LD A,5			; typed file does have a sector buffer
         LD HL,DOS_LEN-128          ; 33e bug ????? ; length of FIB with sector buffer
	JR L519C

L5197:	LD A,7			; untyped file has no sector buffer
         LD HL,DOS_LEN-128          ; length of FIB without sector buffer

L519C:	LD (L7B5C),A		; save type (5, 6 or 7)
	LD (L7B62),HL		; save length
	JP L5254 		; add L7B5C..L7B63 as new struct
				; L7B5A = address of this struct

L51A5:	; parses a complete STRING type
	CALL L6E76
	DW L755A 		; start of reserved word: STRING
	RET NZ

	CALL L6F30		; match('[')

	CALL L69F2		; parse integer constant

	INC H			; length >= 256 ?
	DEC H

	CALL L72DA		; NonZero --> error
	DB 31H			; error 49: Invalid String length

	INC L			; length = 0 ?
	DEC L

	CALL L72D4		; Zero --> error
	DB 31H			; error 49: Invalid String length

	CALL L6F38		; match(']')
	INC HL			; length + 1 = string + count byte
	LD A,8			; type = STRING
	JR L519C

L51C5:	; SYNTAX: scalar-type ::= ( identifier {, identifier } )
	; parses a complete SCALAR type
	CALL L6F1B		; match('('), if present
	RET NZ			; return if '(' not matched

	LD HL,-1 		; HL = upper bound = -1

	; (Maandag,Dinsdag,Woensdag,Donderdag,Vrijdag)
	; (0,	  1,	 2,	 3,	  4	)

L51CC:	PUSH HL
	LD DE,200H		; constant
	CALL L6D75		; add DE to id table
	CALL L6D87		; add identifier to id table
	LD A,(L7B93)
	CALL L6D7A		; add byte to id table

	POP DE
	INC DE			; increase upper bound, value of constant
	PUSH DE

	CALL L6D75		; add DE to id table, value of constant
	CALL L6DC6		; add length

	POP HL			; HL = upper bound

	CALL L6F13		; match(','), if present
	JR Z,L51CC		; jump if ',' matched

	CALL L6F6E		; match(')')

	PUSH HL

	LD HL,L7B93
	LD A,(HL)
	INC (HL) 		; increase type for next SCALAR

	POP HL			; HL = upper bound

	LD DE,0000		; SCALAR lower bound = 0

L51F8:	LD (L7B5C),A		; save type
	LD (L7B5E),DE		; save lower bound
	LD (L7B60),HL		; save upper bound
	LD A,D			; difference >= 256 ?
	OR H
	LD HL,0001		; assume one byte
	JR Z,L520A		; jump if only one byte needed

	INC HL			; no, two bytes needed

L520A:	LD (L7B62),HL		; save size
	JP L5254 		; add L7B5C..L7B63 as new struct
				; L7B5A = address of this struct

L5210:	; SYNTAX: subrange-type ::= constant .. constant
	; parses a complete <m>..<n> type
	LD A,0AH 		; default type = INTEGER
	LD (DEF_TYPE),A

	CALL L6A0D		; parse a constant of any type
	RET NZ			; return if not succeeded

	LD A,B
	PUSH AF

	CP 0AH			; type = INTEGER, BOOLEAN or CHAR ?
	CALL L72C8		; carry set --> error (type < 0AH)
	DB 33H			; error 51: Invalid subrange base type

	CP 0EH			; type = LONGINT ?
	CALL L72D4		; Zero --> error
	DB 33H			; error 51: Invalid subrange base type

	PUSH HL			; save value of <m>

	CALL L6E76
	DW L7580 		; start of reserved word: ..

	CALL L72DA		; NonZero --> error
	DB 0BH			; error 11: '..' expected

	CALL L69EA		; parse a constant of any type
				; error if not found

	POP DE			; HL = value of <n>
				; DE = value of <m>
	POP AF			; A = type of <m>
	PUSH AF
	CP B			; <m> type = <n> type ?

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

	CALL L728D		; check if lower bound <= upper bound

	CALL L72C8		; carry set --> error
	DB 34H			; error 52: Lower bound > upper bound

	POP AF			; A = type of <m>
	JR L51F8

L523B:	; SYNTAX: base-type   ::=
	;	 index-type  ::=
	;	 simple-type ::= scalar-type | subrange-type | type-identifier
	CALL L5210		; parses a subrange-type
	RET Z			; quit if a <m>..<n> parsed

	CALL L51C5		; parses a SCALAR type
	RET Z			; quit if a SCALAR type was parsed

	CALL L4FC8		; find type identifier

	CALL L72DA		; NonZero --> error
	DB 1EH			; error 30: Simple type expected

	LD A,(L7B5C)
	CP 0AH
	RET NC			; return if type = INTEGER, BOOLEAN or CHAR

	CALL L72E1		; no condition
	DB 1EH			; error 30: Simple type expected

L5254:	; add L7B5C .. L7B63
	; out:	A = 0, NonCarry, Z-flag = 1
	;	L7B5A points to last added type
	LD DE,800H
	CALL L6D75		; add DE to id table
	LD HL,(L7B73)
	LD (L7B5A),HL		; save for connection with last added type

	LD HL,L7B5C
	LD B,8

L5265:	LD A,(HL)
	CALL L6D7A		; add byte to id table
	INC HL
	DJNZ L5265

	CALL L6DC6		; add length
	XOR A
	RET

L5271:	; 8 bytes from HL (down) to 7B69 (up)
	LD DE,L7B69
	JR L528A

L5276:	; in:	HL = address after word in id table
	; out:	byte at (HL) moved to L7B57
	;	address at (HL-1), (HL-2) move to L7B58
	;	8 bytes from address (HL-3), (HL-4) to L7B5C
	LD A,(HL)		; A = 1e byte after word
	DEC HL
	LD (L7B57),A
	LD D,(HL)
	DEC HL
	LD E,(HL)
	DEC HL
	LD (L7B58),DE		; save lvalue of id
	LD D,(HL)
	DEC HL
	LD E,(HL)
	EX DE,HL

L5287:	; 8 bytes from HL (down) to 7B5C (up)
	LD DE,L7B5C

L528A:	PUSH BC
	; copy from HL to DE in the opposite directions
	LD B,8
L528D:	LD A,(HL)
	LD (DE),A
	DEC HL
	INC DE
	DJNZ L528D
	POP BC
	RET

L5295:	; update pointer references
	; in:	HL = top of symbol table
	LD (L7B79),HL		; address where to stop reference search
	LD HL,(L7B73)

L529B:	LD BC,(L7B79)
	OR A
	SBC HL,BC
;!	pushf
	ADD HL,BC
;!	popf
	RET Z			; quit if equal (end of struct reached)
	INC HL
	LD C,(HL)		; BC = length of added struct
	INC HL
	LD B,(HL)
	ADD HL,BC
	LD A,(HL)		; highest byte of struct = 8 ?
	CP 8
	JR NZ,L529B		; search for next while not 8

	LD (HL),0		; yes, make 0 ?!?
	PUSH HL
	DEC HL
	DEC HL
	LD A,(HL)
	CP 4			; type of struct = POINTER ?
	JR NZ,L52F8		; jump if not a POINTER, continue loop

	DEC HL
	LD A,(HL)
	OR A
	JR Z,L52F8		; jump if zero, no update necessary

	LD (HL),0
	DEC HL
	PUSH HL
	LD E,(HL)
	DEC HL
	LD D,(HL)

	LD HL,(L7B73)

L52C7:	LD BC,(L7B77)		; BC = absolute top of id list
	OR A
	SBC HL,BC
;!	pushf
	ADD HL,BC
;!	popf

	CALL L72D4		; Zero --> error
	DB 2AH			; error 42: Undefined pointer type in
				;	   preceding type definitions
	INC HL
	LD C,(HL)
	INC HL
	LD B,(HL)
	ADD HL,BC
	LD A,(HL)
	CP 3
	JR NZ,L52C7

	PUSH HL
	PUSH DE
	DEC HL
	DEC HL
L52E1:	LD A,(DE)
	CP (HL)
	JR Z,L52E9
	POP DE
	POP HL
	JR L52C7

L52E9:	BIT 7,(HL)
;!	pushf
	DEC HL
	DEC DE
;!	popf
	JR Z,L52E1
	POP BC
	POP BC
	LD B,(HL)
	DEC HL
	LD C,(HL)
	POP HL
	LD (HL),C
	DEC HL
	LD (HL),B
L52F8:	POP HL
	JP L529B

L52FC:	XOR A
	LD (L7B95),A
	LD (L7BC9),A

         CALL L5377                 ; statements ended by 'END'

	LD (L7BA4),IY
	CALL O_JPHL

         LD HL,(L7B73)

L5310:	LD DE,(L7B75)
	OR A
	SBC HL,DE
	ADD HL,DE
	JR NC,L5363
	INC HL
	LD C,(HL)
	INC HL
	LD B,(HL)
	INC HL
	LD A,(HL)
	INC HL
	LD E,(HL)
	INC HL
	LD D,(HL)
	PUSH HL
	PUSH BC
	LD B,A
	LD A,D
	OR E
	JR Z,L533A
	EX DE,HL
	DEC HL
	LD A,(HL)
	LD C,A
	INC A

	CALL L72D4		; Zero --> error
	DB 28H			; error 40: Undefined label

	DEC HL
	LD D,(HL)
	DEC HL
	LD E,(HL)
	JR L5340

L533A:	LD DE,(L7BA4)
	LD C,0
L5340:	POP HL
	LD A,B
	SUB C
	JR NZ,L534A

         CALL L6C42                 ; update address at HL with contents of DE

	JR L5360

L534A:	CALL L72C8		; carry set --> error
	DB 47H			; error 71: Invalid GOTO

	PUSH DE
	PUSH AF
         CALL L6C3F                 ; update address at HL with current address
	POP AF
	LD B,A

L5355:	CALL O_POPHL
	DJNZ L5355

	LD A,0C3H		; opcode: JP
	POP HL
	CALL O_OPHL		; JP HL

L5360:	POP HL
	JR L5310

L5363:	LD HL,(L7BA4)
	INC HL
	PUSH IY
	POP DE
	DEC DE
	DEC DE
	OR A
	SBC HL,DE
;!	pushf
	ADD HL,DE
;!	popf
         JP NZ,L6C3F                ; update address at HL with current address
	DEC HL
	JP L6CC2

L5377:   ; statement { ; statement } end
	CALL L5385		; statement

	CALL L6E76		; next word is END ?
	DW L7530 		; start of reserved word: END
	RET Z			; yes, return

	CALL L6F50		; match(';')
	JR L5377 		; repeat for next statement

L5385:	LD A,0AH 		; default type = INTEGER
	LD (DEF_TYPE),A
	LD A,0FFH
	LD (L7B98),A
	LD A,(L7B9D)		; compiler directives
	LD (L7B9E),A		; save them
	BIT 3,A			; 1 = User Interrupt on
	JR Z,L539C		; jump if off

	LD A,0CFH		; 0CFH = RST 0008H, patch
				; 0FFH = RST 0038H
	LD (L7BA0),A

	CALL O_BYTE

L539C:	CALL L6E5A
	DB 2			; 2 bytes following
	DW L75BB 		; start of reserved word list:
				; BEGIN, IF, WHILE, REPEAT, FOR
				; CASE, GOTO, WITH, INLINE
	JR Z,L53CB		; start code of found reserved word

	CALL L67B2
	JP Z,L57EA

	LD BC,500H		; procedure identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info
         JP Z,L573D                 ; jump if procedure

	LD BC,100H		; label identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info
	JR Z,L53D0		; jump if label

	LD BC,600H		; function identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info
         JP Z,L591F

	CALL L6E5A
	DB 2			; 2 byte following
	DW L7638 		; start of reserved word list:
				; standard library procedure's
				; WRITELN .. BIOS, 47
	RET NZ

L53CB:	; jumps to the address at hl
	; in:	HL = address of an address
	; out:	-
	LD E,(HL)
	INC HL
	LD D,(HL)
	EX DE,HL
	JP (HL)

L53D0:	CALL L6F40		; match(':')
	LD A,(L7B94)
	CP (HL)

	CALL L72DA		; NonZero --> error
	DB 48H			; error 72: Label not within current block

	DEC HL
	LD A,(HL)
	INC A

	CALL L72DA		; NonZero --> error
	DB 2BH			; error 43: Duplicate identifier or label

	LD A,(L7B95)
	LD (HL),A
	PUSH IY
	POP DE
	DEC HL
	LD (HL),D
	DEC HL
	LD (HL),E
	JR L5385 		; next statement

L53EF:	CALL L5EB0		; parse boolean expression

	CALL O_CODE
	DB 3
	DB 0CBH,45H		; BIT 0,L
	DB 0CAH			; opcode of 'JP Z,'

	PUSH IY
	CALL O_HL		; out: address for 'JP Z,'

	CALL L6E76
	DW L756A 		; start of reserved word: THEN

	CALL L72DA		; NonZero --> error
	DB 11H			; error 17: THEN expected

	CALL L5385		; statement

         CALL L6E76
	DW L756E 		; start of reserved word: ELSE
	JR NZ,L5420

         CALL O_C3

         POP HL
	PUSH IY
	CALL O_HL

         CALL L6C3F                 ; update address at HL with current address
	CALL L5385		; statement

L5420:   POP HL
         JP L6C3F                   ; update address at HL with current address

BOOLOPER:DB 0			; Zero = lowest level
BOOLOPTIM:DB 0			; Zero = no optimization in code
				; NonZero = optimize code for boolean
				;	   evaluation

L5424:	; while-statement ::= WHILE expression do statement
	XOR A
	LD (BOOLOPER),A		; default no operator
	DEC A
	LD (BOOLOPTIM),A		; boolean optimize on
	PUSH IY
	CALL L5EB0		; parse boolean expression
	CALL L6E76
	DW L7572 		; start of reserved word: DO

	CALL L72DA		; NonZero --> error
	DB 0DH			; error 13: DO expected

	CALL O_CODE
	DB 3
	DB 0CBH,45H		; BIT 0,L
	DB 0CAH			; opcode of 'JP Z,'

	PUSH IY
	CALL O_HL

	CALL L5385		; statement

	POP DE
	POP HL

	LD A,0C3H		; opcode: JP
	CALL O_OPHL		; JP HL

	EX DE,HL
         JP L6C3F                   ; update address at HL with current address

L544C:	; repeat-statement ::= REPEAT statement {; statement} UNTIL expression
	PUSH IY

L544E:	CALL L5385		; statement

	CALL L6E76
	DW L7574 		; start of reserved word: UNTIL
	JR Z,L545D

	CALL L6F50		; match(';')
	JR L544E

L545D:	CALL L5EB0		; parse boolean expression

	CALL O_CODE
	DB 3
	DB 0CBH,45H		; BIT 0,L
	DB 0CAH			; opcode for 'JP Z,'

	POP HL
	JP O_HL

L546B:	; for-statement::=for control-variable:=for-list do statement
	LD BC,400H		; variable identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info

	CALL L72DA		; NonZero --> error
	DB 29H			; error 41: Unknown identifier or syntax error

	CALL L5276		; id info at 7B5C
	LD A,(L7B57)
	OR A
	JR NZ,L5485

	LD A,(L7B5C)
	CP 0AH
	JR NC,L5489

L5485:	CALL L72E1		; no condition
	DB 1EH			; error 30: Simple type expected

L5489:	CALL L6D2A		; push 13, L7B57
	LD A,(L7B5C)
	PUSH AF			; save type before assignment

	CALL L6F7E		; match(':=')

	POP AF
	PUSH AF
	; A = type of before assignment
	CALL L5EE8		; parse expression

	CALL O_PSHHL		; generate code to push initial value

	POP AF
	PUSH AF
	CP B			; types are equal ?

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

	CALL L6E5A
	DB 1			; 1 byte following
	DW L75F5 		; start of reserved word list:
				; TO, DOWNTO

	CALL L72DA		; NonZero --> error
	DB 12H			; error 18: TO or DOWNTO expected

	LD E,(HL)		; E = opcode for INC HL or DEC HL
	PUSH DE

	LD A,0AH 		; default type = INTEGER
	CALL L5EE8		; parse expression

	POP DE
	POP AF
	PUSH DE
	CP B

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

	CALL L6E76
	DW L7572 		; start of reserved word: DO

	CALL L72DA		; NonZero --> error
	DB 0DH			; error 13: DO expected

	CALL O_CODE
	DB 1
	DB 0D1H			; POP DE

	POP DE			; E = opcode: INC HL or DEC HL

	CALL L6D63		; move 13, L7B57

	PUSH DE			; E = opcode: INC HL or DEC HL
	LD A,E
	LD HL,_L0666		; LIB, FOR xx:=start TO end
	CP 23H			; opcode: INC HL ?
	JR Z,L54D5

	; opcode: DEC HL
	LD HL,_L0676		; LIB, FOR xx:=start DOWNTO end

L54D5:	CALL O_CALHL
	PUSH IY			; save current code address

	CALL O_CODE
	DB 6
	DB 7AH			; LD A,D
	DB 0B3H			; OR E
	DB 0CAH,0,0		; JP Z,0000H
	DB 0D5H			; PUSH DE

	CALL L661B
	LD HL,L7B95
	INC (HL)

	CALL L5385		; statement

	LD HL,L7B95
	DEC (HL)
	POP HL			; address of 'LD A,D'

	POP DE			; E = opcode: INC HL or DEC HL
	CALL L6D49		; pop 13, L7B57

	PUSH HL			; address of 'LD A,D'

	LD HL,(L7B58)		; hl = lvalue of current id
	LD A,2AH
	CALL O_OPHL		; LD HL,( HL )

	LD A,(L7B62)
	DEC A			; size = 2 bytes ?
	JR NZ,L550C		; jump if size = 2, INTEGER

	CALL O_CODE
	DB 2
	DB 26H,0 		; LD H,0

L550C:	LD A,E
	CALL O_BYTE		; out: INC HL or DEC HL

	CALL O_CODE
	DB 3
	DB 0D1H			; POP DE
	DB 01BH			; DEC DE
	DB 0C3H			; opcode 'JP'

	POP HL
	CALL O_HL		; out: address of 'LD A,D'
	INC HL
	INC HL
	INC HL
         JP L6C3F                   ; update address at HL with current address

L5521:	; case-statement ::=
	;   case expression of case-element { ; case-element } end
	; | case expression of case-element { ; case-element }
	;   otherwise statement { ; statement } end
	LD A,0AH 		; A = default type = INTEGER
	CALL L5EBB		; parse simple expression
	LD (L7B9C),A
	XOR A
	LD (L7B9B),A
	CALL L6F88		; match('OF')
	LD B,0
	PUSH BC
L5531:	LD B,1
L5533:	PUSH BC
	LD HL,L7B9B
	BIT 7,(HL)
	JR Z,L5549

	CALL O_CODE
	DB 1
	DB 19H			; ADD HL,DE

	BIT 4,(HL)
	JR Z,L5549

	CALL O_CODE
	DB 1
	DB 09H			; ADD HL,BC

L5549:	CALL L69EA		; parse a constant of any type
				; error if not found
	LD A,(L7B9C)
	CP B

	CALL L72DA		; NonZero --> error
	DB 2EH			; error 46: constant and CASE selector type
				;	    does not match

	CALL O_LDDE		; output: 'LD DE,value HL'
	PUSH HL
	CALL L6E76
	DW L7580 		; start of reserved word: ..
	POP HL
	JR NZ,L5582
	PUSH HL
	CALL L69EA		; parse a constant of any type
				; error if not found
	LD A,(L7B9C)
	CP B

	CALL L72DA		; NonZero --> error
	DB 2EH			; error 46: constant and CASE seletector type
				;	    does not match

	POP DE
	OR A
	SBC HL,DE
	INC HL
	CALL O_LDBC

	CALL O_CODE
	DB 6
	DB 0B7H			; OR A
	DB 0EDH,52H		; SBC HL,DE
	DB 0B7H			; OR A
	DB 0EDH,42H		; SBC HL,BC

	LD A,0DAH
	JR L558B

L5582:	CALL O_CODE
	DB 3
	DB 0B7H			; OR A
	DB 0EDH,52H		; SBC HL,DE

	LD A,0CAH
L558B:	LD (L7B9B),A
	CALL L6F0B		; match(':'), if present
	POP BC
	JR Z,L55A5		; jump if ':' matched
	LD A,(L7B9B)
	CALL O_BYTE
	PUSH IY
	CALL O_HL
	CALL L6F5E		; match(',')
	INC B
	JR L5533

L55A5:	PUSH IY
	POP DE
	INC DE
	INC DE
	INC DE
L55AB:	DEC B
	JR Z,L55B4
	POP HL

         CALL L6C42                 ; update address at HL with contents of DE

	JR L55AB
L55B4:	LD A,(L7B9B)
	RES 3,A
	CALL O_BYTE
	POP BC
	PUSH IY
	INC B
	PUSH BC
	CALL O_HL
	LD A,(L7B9B)
	PUSH AF
	LD A,(L7B9C)
	PUSH AF

	CALL L5385		; statement

	POP AF
	LD (L7B9C),A
	POP AF
	LD (L7B9B),A
	CALL L6F0F		; match(';'), if present
	LD E,1
	JR Z,L55DF		; jump if ';' matched
	DEC E
L55DF:	PUSH DE
	CALL L6E76
	DW L7530 		; start of reserved word: END
	POP DE
	JR Z,L561E
	CALL O_C3
	POP BC
	POP HL
	PUSH IY
	PUSH BC
	PUSH DE
	CALL O_HL

         CALL L6C3F                 ; update address at HL with current address

	CALL L6E76
	DW L756E 		; start of reserved word: ELSE
	POP DE
	JR Z,L560F
	DEC E
	JP Z,L5531
	LD A,(L7B98)
	OR A

	CALL L72D4		; Zero --> error
	DB 0EH			; error 14: END expected

	CALL L72E1		; no condition
	DB 29H			; error 41: Unknown identifier or syntax error

L560F:	CALL L5385		; statement

	CALL L6E76
	DW L7530 		; start of reserved word: END
	JR Z,L561E

	CALL L6F50		; match(';')
	JR L560F

L561E:	POP BC
L561F:	POP HL

         CALL L6C3F                 ; update address at HL with current address

         DJNZ L561F
	RET

L5626:	LD BC,100H		; label identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info

	CALL L72DA		; NonZero --> error
	DB 28H			; error 40: Undefined label

	LD A,(L7B94)
	CP (HL)

	CALL L72DA		; NonZero --> error
	DB 48H			; error 72: Label not within current block

	EX DE,HL

L5639:	CALL L6D75		; add DE to id table
	LD A,(L7B95)
	CALL L6D7A		; add byte to id table
	CALL O_C3
	PUSH IY
	POP DE
	CALL L6D75		; add DE to id table
	JP O_HL

L564E:	LD A,(L7BC9)
	PUSH AF
L5652:	LD A,(L7BC6)
	LD HL,L7BC9
	CP (HL)

	CALL L72D4		; Zero --> error
	DB 61H			; error 97: Too many nested WITH's

	CALL L677F		; parse VAR parameter
	LD A,(L7B5C)
	CP 2			; record identifier ?

	CALL L72DA		; NonZero --> error
	DB 1DH			; error 29: Record variable expected

	LD HL,L7BC9
	LD E,(HL)
	LD D,0
	INC (HL)
	LD HL,L7BCC
	ADD HL,DE
	LD A,(L7B5D)
	LD (HL),A
	LD HL,(L7BCA)
	ADD HL,DE
	ADD HL,DE

	LD A,22H
	CALL O_OPHL		; LD ( HL ),HL

	CALL L6F13		; match(','), if present
	JR Z,L5652		; jump if ',' matched

	CALL L6E76
	DW L7572 		; start of reserved word: DO

L568C:	CALL L72DA		; NonZero --> error
	DB 0DH			; error 13: DO expected

	CALL L5385		; statement

	POP AF
	LD (L7BC9),A
	RET

L5698:	; statement inline
	CALL L6F66		; match('(')

L569B:	LD A,3EH
	CALL L6F29		; match('>')
	LD A,2			; 16 bits
	JR Z,L56AE		; jump if matched

	LD A,3CH
	CALL L6F29		; match('<')
	LD A,1			; 8 bits
	JR Z,L56AE		; jump if matched

	XOR A

L56AE:	LD (L7BA6),A		; 0 = automatic
				; 1 = always 8 bits
				; 2 = always 16 bits
	XOR A
	LD H,A
	LD L,A
	LD B,A

L56B5:	PUSH BC
	PUSH HL
	CALL L6A0D		; parse a constant of any type
	JR NZ,L56C5		; jump if no constant parsed

	LD A,B
	CP 0AH			; constant type = INTEGER ?
	JR Z,L5702

	CALL L72E1		; no condition
	DB 16H			; error 22: Integer constant expected

L56C5:	LD HL,L7BA6
	LD A,(HL)
	OR A
	JR NZ,L56CE
	LD (HL),2

L56CE:	LD A,2AH
	CALL L6F29		; match('*')
	JR NZ,L56DA		; jump if not matched

	PUSH IY			; IY = current position in code
	POP HL
	JR L5702

L56DA:	LD BC,400H		; variable identifier ?
	CALL L6E54		; check if current in id list, pointer
				; HL = address of info
	JR NZ,L56EA

	CALL L5276		; id info at 7B5C
	LD HL,(L7B58)		; hl = lvalue of current id
	JR L5702

L56EA:	LD BC,500H		; procedure identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info
         JR Z,L56FC

	LD BC,600H		; function identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info

	CALL L72DA		; NonZero --> error
	DB 4AH			; error 74: INLINE error

L56FC:	DEC HL
	DEC HL
	LD D,(HL)
	DEC HL
	LD E,(HL)
	EX DE,HL

L5702:	POP DE
	POP BC
	DEC B
	JR NZ,L570A
	CALL L6A30

L570A:	ADD HL,DE
	LD B,0
	LD A,2BH
	CALL L6F29		; match('+')
	JR Z,L56B5		; jump if matched

	INC B
	LD A,2DH 		; match('-')
	CALL L6F29		; jump if matched
	JR Z,L56B5

	LD A,(L7BA6)
	CP 1			; 8 bits ?
	JR Z,L5729		; jump if 8 bits

	JR NC,L572F		; jump if A = 2, output 16 bits value

	INC H
	DEC H
	JR NZ,L572F		; jump if HL >= 256, output HL

L5729:	; output 8 bits value
	LD A,L
	CALL O_BYTE
	JR L5732

L572F:	; output 16 bits value
	CALL O_HL

L5732:	LD A,2FH
	CALL L6F29		; match('/')
	JP Z,L569B		; repeat while '/' matched

	JP L6F6E 		; match(')')

L573D:   ; procedure
         DEC HL                     ; skip update flag

         LD B,(HL)                  ; B = # of different types
	DEC HL

         LD D,(HL)                  ; address of procedure/function
	DEC HL
	LD E,(HL)
	DEC HL
         PUSH DE                    ; save start address of procedure/function

         LD D,(HL)                  ; DE = function type definition address
	DEC HL
	LD E,(HL)
	DEC HL
	PUSH DE

         DEC HL                     ; skip address of function result variable
	DEC HL


         LD D,(HL)                  ; DE = first 128 byte block number of
                                    ; function/procedure in overlay
                                    ;Ok$$$$, will become long
                                    ;        push long !!
	DEC HL
	LD E,(HL)
	DEC HL
         PUSH DE                    ; push high-word

         LD D,(HL)                  ; push low-word
         DEC HL
         LD E,(HL)
         DEC HL
         PUSH DE


         LD D,(HL)                  ; DE = length in blocks of 128 bytes of
                                    ; the largest overlay part
                                    ;Ok$$$$, will become length in bytes
	DEC HL
	LD E,(HL)
	DEC HL
	PUSH DE

         INC B                      ; # different type = 0, no variables ?
	DEC B
         JP Z,L57D6                 ; jump if no variables

	CALL L6F66		; match('(')

L575E:	PUSH BC
	LD B,(HL)
	DEC HL
	LD A,(HL)
	DEC HL
	LD (L7B57),A
	LD D,(HL)
	DEC HL
	LD E,(HL)
	DEC HL
	LD C,B
L576B:	BIT 7,(HL)
;!	pushf
	DEC HL
;!	popf
	JR Z,L576B
	DJNZ L576B
	LD B,C
	PUSH HL
	EX DE,HL
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)

L5778:	PUSH BC
	LD A,(L7B57)
	OR A
	JR NZ,L57A9
	LD A,(L7B5C)
	CP 3
	JR C,L57A1

	; A = default type
	CALL L5E84		; parse a sub expression
	CALL L5864		; make type casts

	LD A,(L7B5C)
	CP 4
	JR Z,L57BD

	CP 0EH			; type = LONGINT ?
	JR Z,L57781

	CP 9
	JR C,L57C0

	JR NZ,L57BD		; jump to O_PSHHL if type = INTEGER,
				; BOOLEAN or CHAR

	; generate code to push rest of a REAL, HL is always pushed
	LD A,0C5H
	CALL O_BYTE		; out: 'PUSH BC'

L57781:	LD A,0D5H
	CALL O_BYTE		; out: 'PUSH DE'
	JR L57BD

L57A1:	CALL L6D2A		; push 13, L7B57
	CALL L6749
	JR L57AF

L57A9:	CALL L6D2A		; push 13, L7B57
	CALL L677F		; parse VAR parameter

L57AF:	CALL L6D5D		; move 13, L7B64
	LD A,(L7B69)
	CP 0
	CALL NZ,L58C5		; NonZero --> perform type checking
	CALL L6D49		; pop 13, L7B57

L57BD:	CALL O_PSHHL

L57C0:	POP BC
	DEC B
	JR Z,L57C9
	CALL L6F5E		; match(',')
	JR L5778

L57C9:	POP HL
	POP BC
	DEC B
	JR Z,L57D3
	CALL L6F5E		; match(',')
	JR L575E

L57D3:	CALL L6F6E		; match(')')


L57D6:
         POP BC                     ; length of data to read from overlay
                                    ;Ok$$$$, must be in BC in bytes

         POP HL                     ; first block of data where to read from
                                    ; in overlay
                                    ;Ok$$$$, must be a long
                                    ;       pop long !!
         POP DE

         LD A,B                     ; length = 0 ?
         OR C
         JR Z,L57E3                 ; jump if procedure/function is no overlay

         LD A,B
         AND C
         INC A
         JR NZ,L57E0                ; jump if not -1

         CALL O_CODE
         DB 2
         DB 16h,40H                 ; LD D,40H

         JR L57E3

L57E0:
         PUSH BC

         EX DE,HL
         CALL O_LDDE                ; high-word of position
         EX DE,HL
         CALL O_LDHL                ; low-word of position

         POP HL
         CALL O_LDBC                ; length of data block to read from overlay

;         CALL O_LDHL
;         EX DE,HL
;         CALL O_LDDE                ; output: 'LD DE,value HL'


L57E3:
         POP DE                     ; DE = function type definition address

         POP HL                     ; HL = start address of procedure/function

	LD A,0CDH
	JP O_OPHL		; CALL HL

L57EA:	LD A,(L7B5C)
	CP 0			; 0 ?
	JR Z,L57F9		; yes --> illegal assignment
	CP 5			; < 5 ?
	JR C,L57FD		; yes --> correct assignment
	CP 8			;>= 8 ?
	JR NC,L57FD		; yes --> correct assignment

	; illegal assignment with:
	; 0, 5 (typed file), 6 (text) and 7 (untyped file)
L57F9:	CALL L72E1		; no condition
	DB 36H			; error 54: Illegal assignment

L57FD:	LD A,(L7BBD)
	BIT 1,A
	JR NZ,L5812

	BIT 0,A
	JR Z,L580A		; jump if L7BBD = 0

	LD A,0FFH
L580A:	LD HL,(L7BBE)
	LD (L7B58),HL		; new lvalue of id
	JR L581A

L5812:	CALL L678B		; bit 0,1 of (L7BBD)
				; 00 = LD HL, value in L7BBE
				; 01 = LD HL,(value in L7BBE)
				; 10 = LD DE, value in L7BBE
				;      ADD HL,DE
				; 11 = no output
	CALL O_PSHHL
	LD A,1

L581A:	LD (L7B57),A		; = 1	   if bit 1,(L7BBD) = '1'
				; = 255	   if bit 1,0,(L7BBD) = '0','1'
				; = (L7BBD) if bit 1,0,(L7BBD) = '0','0'
	CALL L6F7E		; match(':=')
	LD A,(L7B5C)
	CP 3			; >= 3 ?
	JP NC,L593A

	CALL L6D2A		; push 13, L7B57

	CALL L6749

	CALL L6D43		; pop 13, L7B64

	CALL L58C5		; perform type checking

	LD A,(L7B64)
	DEC A
	JR Z,L5852
	INC A
	JR Z,L5845

	CALL O_CODE
	DB 2
	DB 0EDH,05BH		; opcode: 'LD DE,()'

	JR L584A

L5845:	CALL O_CODE
	DB 1
	DB 11H			; opcode: 'LD DE,'

L584A:	LD HL,(L7B65)
	CALL O_HL
	JR L5857

L5852:	CALL O_CODE
	DB 1
	DB 0D1H			; POP DE

L5857:	LD HL,(L7B6F)		; length of structured type
	CALL O_LDBC

	CALL O_CODE
	DB 2
	DB 0EDH,0B0H		; LDIR

	RET

L5864:	; ---------------------------------------------------------
	; make necessary type casts
	; ---------------------------------------------------------
	; in:	(L7B5C) = type of lvalue
	;	B = type of rvalue
	LD A,(L7B5C)
	CP 9			; lvalue type = REAL ?
	JR NZ,L5877

	; lvalue type = REAL
	LD A,B
	CP 0AH			; type rvalue = INTEGER ?
	JR NZ,L58641

	; lvalue type = REAL, rvalue type = INTEGER
	LD B,9			; new rvalue type = REAL
	LD HL,_L1008		; LIB, convert integer HL to REAL HLDEBC
	JR L589A

L58641:	CP 0EH			; type rvalue = LONGINT ?
	JR NZ,L589D

	; lvalue type = REAL, rvalue type = LONGINT
	LD B,9			; new rvalue type = REAL
	LD HL,_L_R		; LIB, convert LONGINT DE:HL to REAL HLDEBC
	JR L589A

L5877:	CP 8			; lvalue type = STRING ?
	JR NZ,L588C		; jump if not

	; lvalue type = STRING
	LD A,B
	CP 0CH			; rvalue type = CHAR ?
	JR NZ,L589D

	; lvalue type = STRING, rvalue type = CHAR
	LD B,8			; new rvalue type = CHAR

	CALL O_CODE
	DB 4
	DB 65H			; LD H,L  = character data
	DB 2EH,01H		; LD L,1  = length
	DB 0E5H			; PUSH HL, push string on stack

	JR L589D

L588C:	CP 0CH			; lvalue type = CHAR ?
	JR NZ,l588C1		; jump if not

	; lvalue type = CHAR
	LD A,B
	CP 8			; STRING ?
	JR NZ,L589D

	; lvalue = CHAR, rvalue = STRING
	LD B,0CH 		; CHAR
	LD HL,_L0996		; LIB, convert STRING to CHAR, clear
	JR L589A

L588C1:	CP 0EH			; lvalue type = LONGINT ?
	JR NZ,L588C3		; jump if not

	; lvalue type = LONGINT
	LD A,B
	CP 0AH			; rvalue type = INTEGER ?
	JR NZ,L588C2		; jump if not

	; lvalue type = LONGINT, rvalue = INTEGER
	LD B,0EH 		; new rvalue type = LONGINT
	CALL OP_L_I		; code to convert INTEGER to LONGINT with
				; sign extension
	JR L589D

L588C2:	CP 9			; rvalue type = REAL ?
	JR NZ,L589D

	; lvalue type = LONGINT, rvalue type = REAL
	LD B,0EH 		; new rvalue type = LONGINT
	LD HL,_R_L		; LIB, convert REAL HLDEBC to LONGINT
	JR L589A

L588C3:	CP 0AH			; lvalue type = INTEGER ?
	JR NZ,L589D		; jump if not

	; lvalue type = INTEGER
	LD A,B
	CP 0EH			; rvalue type = LONGINT ?
	JR NZ,L589D		; jump if not

	LD B,0AH 		; new rvalue type = INTEGER
	JR L589D

L589A:	CALL O_CALHL

L589D:	; all possible casts have been made now
	LD A,(L7B5C)
	CP B			; lvalue and expression have same type ?
	JR NZ,L58C1		; jump for Type mismatch

	CP 3			; lvalue type = 3 ?
	JR NZ,L58B1

	LD A,C
	OR A
	RET Z
	LD HL,(L7B5E)
	CP (HL)
	RET Z
	JR L58C1 		; jump for Type mismatch

L58B1:	CP 4			; lvalue type = 4 ?
	RET NZ
	LD HL,(L7B8B)
	LD A,H
	OR L
	RET Z
	LD DE,(L7B5E)
	SBC HL,DE
	RET Z

L58C1:	CALL L72E1		; no condition
	DB 2CH			; error 44: Type mismatch



	; ----------------------------------------------------------
	; perform type checking
	; ----------------------------------------------------------
	; in:	(L7B5C) = current type
	;
L58C5:	LD A,(L7B5C)
	CP 0			; lvalue type = 0 ?
	JR Z,L591B		; jump, type mismatch

	LD C,0BFH		; 10111111
	CP 0AH			; lvalue type = INTEGER,BOOLEAN,CHAR
				;	       or LONGINT ?
	JR NC,L5906

	LD C,83H 		; 10000011
	CP 8			; lvalue type = STRING ?
	JR NZ,L58E3

	; check if Var-parameter checking is ON for strings
	LD A,(L7B9E)		; compiler directives
	BIT 5,A			; 1 = Var-parameter Type Checking on
	JR NZ,L5906		; jump if on

	LD C,80H 		; 10000000
				; when bit 0,1 are zero the length will
				; not be checked, checks only the type
	JR L5906

L58E3:	CP 6			; lvalue type = TEXT,UNTYPED F.,STRING,REAL
	JR NC,L5906

	LD C,0B3H		; 10110011
	CP 3
	JR NC,L5906

	LD C,0C3H		; 11000011
	CP 2
	JR NC,L5906

	LD HL,(L7B60)
	LD A,H
	OR L
	LD C,0BFH		; 10111111
	JR NZ,L5906

	LD HL,(L7B6D)
	LD A,(HL)
	CP 0AH
	JR NZ,L591B

	LD C,0B3H		; 10110011

L5906:	LD HL,L7B5C
	LD DE,L7B69
	LD B,8
L590E:	RL C
	JR NC,L5916		; jump if byte not to compare

	LD A,(DE)
	CP (HL)
	JR NZ,L591B		; jump if not equal, type mismatch

L5916:	INC HL
	INC DE
	DJNZ L590E
	RET

L591B:	CALL L72E1		; no condition
	DB 2CH			; error 44: Type mismatch


L591F:	LD DE,-4
	ADD HL,DE
	LD D,(HL)
	DEC HL
	LD E,(HL)
	DEC HL
	PUSH DE
	LD D,(HL)
	DEC HL
	LD E,(HL)
	LD (L7B58),DE		; save lvalue of id
	POP HL
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)
	XOR A
	LD (L7B57),A
	CALL L6F7E		; match(':=')

	LD A,(L7B5C)		; A = default type

L593A:	CALL L5E84		; parse a sub expression
	CALL L5864		; make type casts
	JP L661B

L59E9:	; generate a CALL according to the type in L7B5C
	; in:	HL = address of table with three routine addresses
	;	1e word = typed file,	L7B5C = 5
	;	2e word = text file,	L7B5C = 6
	;	3e word = untyped file,	L7B5C = 7
	LD A,(L7B5C)
	SUB 5
	CALL TableIndex2

;	 ADD A,A
;	 LD E,A
;	 LD D,0
;	 ADD HL,DE
;	 LD E,(HL)
;	 INC HL
;	 LD D,(HL)
;	 EX DE,HL

	JP O_CALHL

L5A0C:	; parse '(' and file parameter
	CALL L6F66		; match('(')
	CALL L5A17		; parse file parameter
	RET Z

	CALL L72E1		; no condition
	DB 15H			; error 21: File variable expected

L5A17:	; parses a file parameter
	; out:	NonZero and Carry, no name parsed
	;	NonZero and NonCarry, name parsed but it is not a file
	;			    parameter
	;	Zero and NonCarry, file parameter parsed
	;	A = type of file parameter
	CALL L67B2		; parse var parameter
	SCF
	RET NZ			; return with NonZero and Carry

	LD A,(L7B5C)
	CP 5
	JR C,L5A2F		; type < 5, not a file type
	CP 8
	JR NC,L5A2F		; type > 7, not a file type

	CALL L678B		; bit 0,1 of (L7BBD)
				; 00 = LD HL, value in L7BBE
				; 01 = LD HL,(value in L7BBE)
				; 10 = LD DE, value in L7BBE
				;      ADD HL,DE
				; 11 = no output
	XOR A			; return NonCarry and Zero
	LD A,(L7B5C)		; return type
	RET

L5A2F:	XOR A			; no carry
	DEC A			; return with NonZero, A = 255
	RET

L5CAD:	; parses a VAR string variable
	CALL L677F		; parse VAR parameter
	LD A,(L7B5C)
	CP 8			; string var ?
	RET Z			; return if string var

	CALL L72E1		; no condition
	DB 22H			; error 34: String variable expected

L5D76:	PUSH HL
	CALL O_PSHHL
	CALL L6F5E		; match(',')
	CALL L5E97		; parse integer expression
	POP HL

L5960:	CALL L6F6E		; match(')')
	JP O_CALHL

L5E84:	; parses a sub expression
	; in:	A = default type
	CALL L6D2A		; push 13, L7B57
	CALL L5EE8		; parse expression
	CALL L6D49		; pop 13, L7B57
	RET

L5E8E:	; parses an array index, ':=' and integer expression
	CALL L65D5		; parse an array index
	CALL L6F7E		; match(':=')
	CALL O_PSHHL		; push index result

L5E97:	; parses an integer expression
	LD A,0AH 		; default type = INTEGER
	CALL L5EE8		; parse expression
	LD A,B
	CP 00AH			; expression type = integer ?
	RET Z			; yes, ok

	CALL L72E1		; no condition
	DB 17H			; error 23: Integer expression expected

L5EA2:	; parses an integer, longint or real expression
	; in:	A = default expression
	CALL L5EE8		; parse expression
	LD A,B
	CP 00AH
	RET Z			; return if type = INTEGER
	CP 9
	RET Z			; return if type = REAL
	CP 00EH
	RET Z			; return if type = LONGINT

	CALL L72E1		; no condition
	DB 1AH			; error 26: Integer or real expression expected

L5EB0:	; parses a boolean expression
	LD A,0BH 		; default boolean
	CALL L5EE8		; parse expression
	LD A,B
	CP 00BH
	RET Z			; return if type = BOOLEAN

	CALL L72E1		; no condition
	DB 14H			; error 20: Boolean expression expected

L5EBB:	; parses a simple expression
	CALL L5EE8		; parse expression

L5EBE:	LD A,B
	CP 00AH			; return if type = INTEGER, BOOLEAN or CHAR
				;	       or LONGINT
	RET NC
	CP 8

	CALL L72DA		; NonZero --> error
	DB 1FH			; error 31: Simple expression expected

	LD B,00CH
	LD HL,_L0996		; LIB, convert STRING to CHAR, clear
	JP O_CALHL

L5ED0:	; parse a string expression
	LD A,8			; default type = STRING
	CALL L5EE8		; parse expression
	LD A,B
	CP 8
	RET Z
	CP 00CH

	CALL L72DA		; NonZero --> error
	DB 21H			; error 33: String expression expected

L5EDD:	; generate code to push CHAR in L as STRING with length = 1
	; out:	type = STRING, B = 8
	LD B,8

	CALL O_CODE
	DB 4
	DB 65H			; LD H,L
	DB 2EH,01H		; LD L,1
	DB 0E5H			; PUSH HL

	RET

DEF_TYPE:DB 0AH

SETDFT:	; set new default type
	; in:	A = type,
	; out:	A = type,
	; changes: F
	CP 0FFH
	JR Z,SETDF1
	CP 0AH
	JR Z,SETDF1
	CP 0EH
	JR Z,SETDF1
	CP 09H
	RET NZ			; leave old value if not INTEGER or LONGINT

	LD A,0FFH

SETDF1:	LD (DEF_TYPE),A
	RET

L5EE8:	; parse a complete expression
	; SYNTAX: expression ::= simple-expression
	;		       { relational-operator simple-expression }

	CALL SETDFT

	LD HL,BOOLOPER
	INC (HL) 		; increase one level
				; 1 = the FIRST level

	CALL L5F98		; simple-expression
				; B = type
	LD A,B
	CALL SETDFT		; set new default type

L5EEB:	; { relational-operator simple-expression }
	PUSH BC
	CALL L6E5A		; is '=' the next word
	DB 1			; 1 byte following
	DW L7625 		; list of reserved words:
				; =, <>, >=, <=, >, <, IN
	POP BC
	RET NZ			; return if no relational-operator

	LD A,(HL)		; 0 = =, 1 = <>, 2 = >=, 3 = <=
				; 4 = >, 5 = <,  ffh = IN
	INC A
	JR Z,L5F34		; jump if 'IN'

	DEC A
	PUSH AF			; save relational-operator
	PUSH BC			; save type

	CALL L6148		; generate code to push REAL, INTEGER,
				; BOOLEAN, CHAR, POINTER or LONGINT
				; on the stack

	LD HL,(L7B8B)
	PUSH HL
	CALL L5F98		; simple-expression
				; B = type
	POP HL
	LD (L7B8D),HL
	POP DE			; D = type of previous simple-expression
	CALL L6160		; convert previous and current to same type

	LD A,B
	CALL SETDFT		; set new default type

	POP AF			; restore relational-operator

	ADD A,A			; * 2
	ADD A,A			; * 4
	ADD A,A			; * 8
	ADD A,A			; * 16
	LD E,A			; DE = 16 * A
	LD D,0
	LD HL,L5F68
	ADD HL,DE		;+0  = =,+16 = <>,+32 = >=,+48 = <=
				;+64 = >,+80 = <
	LD A,B
	CP 3			; operator type = SET ?
	JR Z,L5F28		; jump if operator at SET

	INC HL
	INC HL
	CP 9			; operator type = REAL ?
	JR Z,L5F28		; jump if operator at REAL

	INC HL
	INC HL
	CP 8			; operator type = STRING ?
	JR Z,L5F28		; jump if operator at STRING

	INC HL
	INC HL
	CP 0EH			; operator type = LONGINT ?
	JR Z,L5F28		; jump if LONGINT

	INC HL
	INC HL
	CP 0AH			; operator type = INTEGER ?
	JR Z,L5F28		; jump if INTEGER

	INC HL
	INC HL
	CP 0BH			; operator type = BOOLEAN ?
	JR Z,L5F28		; jump if BOOLEAN

	INC HL
	INC HL
	; operator type = CHARACTER

L5F28:	LD E,(HL)
	INC HL
	LD D,(HL)
	LD A,D
	OR E

	CALL L72D4		; Zero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator
	EX DE,HL
	JR L5F62

L5F34:	; operator = 'IN'
	LD A,B
	CP 00AH
	JR NC,L5F47		; jump if type = INTEGER, BOOLEAN or CHAR

	CP 8			; type = STRING ?

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	LD HL,_L0996		; LIB, convert STRING to CHAR, clear
	CALL O_CALHL
	LD B,00CH		; result type = CHAR

L5F47:	PUSH BC

	; generate code to save the value to search in the 'SET'
	CALL O_PSHHL

	CALL L5F98		; simple-expression
				; B = type
	POP DE
	LD A,B
	CP 3			; type = SET ?

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	LD A,C
	OR A
	JR Z,L5F5F
	CP D

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

L5F5F:	LD HL,_L134F		; LIB, clear

L5F62:	CALL O_CALHL
	LD B,00BH		; return type = boolean
	RET

L5F68:	DW _L12E1		; LIB, clear, =  SET
	DW _L0688		; LIB, clear, =  REAL
	DW _L068D		; LIB, clear, =  STRING
	DW _L_EQ 		; LIB,	     =  LONGINT
	DW _L067F		; LIB, clear, =  INTEGER
	DW _L067F		; LIB, clear, =  BOOLEAN
	DW _L067F		; LIB, clear, =  CHAR
	DW 0

	DW _L12DD		; LIB, clear, <> SET
	DW _L069B		; LIB, clear, <> REAL
	DW _L06A0		; LIB, clear, <> STRING
	DW _L_NEQ		; LIB,	     <> LONGINT
	DW _L0692		; LIB, clear, <> INTEGER
	DW _L0692		; LIB, clear, <> BOOLEAN
	DW _L0692		; LIB, clear, <> CHAR
	DW 0

	DW _L1300		; LIB, clear, >= SET
	DW _L06AE		; LIB, clear, >= REAL
	DW _L06B3		; LIB, clear, >= STRING
	DW _L_GTE		; LIB,	     >= LONGINT
	DW _L06A5		; LIB, clear, >= INTEGER
	DW _L06A5		; LIB, clear, >= BOOLEAN
	DW _L06A5		; LIB, clear, >= CHAR
	DW 0

	DW _L12FC		; LIB, clear, <= SET
	DW _L06C2		; LIB, clear, <= REAL
	DW _L06C7		; LIB, clear, <= STRING
	DW _L_LSE		; LIB,	     <= LONGINT
	DW _L06B8		; LIB, clear, <= INTEGER
	DW _L06B8		; LIB, clear, <= BOOLEAN
	DW _L06B8		; LIB, clear, <= CHAR
	DW 0

	DW 0			; ----	   , >  SET
	DW _L06D6		; LIB, clear, >  REAL
	DW _L06DB		; LIB, clear, >  STRING
	DW _L_GT 		; LIB,	     >  LONGINT
	DW _L06CC		; LIB, clear, >  INTEGER
	DW _L06CC		; LIB, clear, >  BOOLEAN
	DW _L06CC		; LIB, clear, >  CHAR
	DW 0

	DW 0			; ----	   , <  SET
	DW _L06E9		; LIB, clear, <  REAL
	DW _L06EE		; LIB, clear, <  STRING
	DW _L_LS 		; LIB,	     <  LONGINT
	DW _L06E0		; LIB, clear, <  INTEGER
	DW _L06E0		; LIB, clear, <  BOOLEAN
	DW _L06E0		; LIB, clear, <  CHAR
	DW 0

L5F98:	; SYNTAX: simple-expression ::= term { adding-operator term }
	; out:	B = type

	CALL L6054		; term
				; B = type

	LD A,B
	CALL SETDFT		; set new default type

L5F9B:	; { adding-operator term }
	PUSH BC			; save type
	CALL L6E5A
	DB 1			; 1 byte following
	DW L7619 		; start of reserved word list:
				; +, -, OR, XOR
	POP BC			; restore type
	RET NZ			; return if no adding-operator

	; pointer types do not match with an adding-operator
	LD A,B
	CP 4			; type = POINTER ?
	CALL L72D4		; Zero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	LD A,(HL)		; 0 = +,  1 = -,
				; 2 = OR  3 = XOR
	PUSH AF			; save operator

	PUSH BC			; save type of previous term
	CALL L6148		; generate code to push REAL, INTEGER,
				; BOOLEAN, CHAR, POINTER or LONGINT
				; on the stack

	CALL L6054		; term
				; B = type of term

	POP DE			; D = type of previous term

	POP AF			; A = operator
				; 0 = +,  1 = -,
				; 2 = OR  3 = XOR
	PUSH AF			; save operator
	OR A
	JR NZ,L5FC9		; jump if operator = 1, 2 or 3


	LD A,B
	CP 00CH			; current type = CHAR ?
	JR NZ,L5FC9		; jump if not

	; generate code to concatenate two strings

	; generate code to convert HL (CHAR) in to a string
	CALL O_CODE
	DB 4
	DB 65H			; LD H,L
	DB 2EH,01H		; LD L,1
	DB 0E5H			; PUSH HL

	LD B,8			; current type = STRING

L5FC9:	CALL L6160		; convert previous and current to same type

	LD A,B
	CALL SETDFT		; set new default type

	POP AF			; A = operator
	CP 2
	JR NC,L601B		; jump if 'OR' or 'XOR'

	; operator = '+' or '-'
	PUSH AF
	LD A,B
	LD HL,_L1318		; LIB, SET + SET
	LD DE,_L1326		; LIB, SET - SET
	CP 3			; type = SET ?
	JR Z,L6006		; jump if type = SET

	LD HL,_L09E9		; LIB, REAL + REAL
	LD DE,_L09F2		; LIB, REAL - REAL
	CP 9			; type = REAL ?
	JR Z,L6006		; jump if type = REAL

	LD HL,_L_ADD
	LD DE,_L_SUB
	CP 00EH			; type = LONGINT ?
	JR Z,L6006		; jump if type = LONGINT

	CP 8			; type = STRING ?
	JR Z,L6010		; jump if type = STRING

	CP 00AH			; type = INTEGER ?

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	POP AF
	DEC A			; type = '-'
	JR Z,L5FFC		; jump if type = '-'

	; generate code to add two INTEGERS
	CALL O_CODE
	DB 1
	DB 19H			; ADD HL,DE

	JP L5F9B 		; repeat { adding-operator term }

L5FFC:	; generate code to subtract two INTEGERS
	CALL O_CODE
	DB 4
	DB 0EBH			; EX DE,HL
	DB 0B7H			; OR A
	DB 0EDH,52H		; SBC HL,DE

	JP L5F9B

L6006:	POP AF
	DEC A
	JR NZ,L600B		; jump if operator = '+'

	EX DE,HL
	; HL = address of '-' routine

L600B:	CALL O_CALHL
	JP L5F9B

L6010:	POP AF
	DEC A			; operator = '-' ?

	CALL L72D4		; Zero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	LD HL,_L083D		; LIB, STRING + STRING
	JR L600B

L601B:	; generate code for 'OR' and 'XOR' operators
	LD A,B
	JR NZ,L6039		; jump if operator = 'XOR'

	; operator = 'OR'

	CP 00BH			; type = BOOLEAN ?
	JR Z,L602F		; jump if boolean

	LD HL,_L_OR
	CP 00EH			; type = LONGINT ?
	JR Z,L600B

	CP 00AH			; type = INTEGER ?

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	CALL O_CODE
	DB 3
	DB 7CH			; LD A,H
	DB 0B2H			; OR D
	DB 67H			; LD H,A

L602F:	CALL O_CODE
	DB 3
	DB 7DH			; LD A,L
	DB 0B3H			; OR E
	DB 6FH			; LD L,A

	JP L5F9B

L6039:	; operator = 'XOR'

	CP 00BH			; type = BOOLEAN ?
	JR Z,L604A		; jump if type = BOOLEAN

	LD HL,_L_XOR
	CP 00EH			; type = LONGINT ?
	JR Z,L600B		; jump if type = LONGINT

	CP 00AH			; type = INTEGER ?

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	CALL O_CODE
	DB 3
	DB 7CH			; LD A,H
	DB 0AAH			; XOR D
	DB 67H			; LD H,A

L604A:	CALL O_CODE
	DB 3
	DB 7DH			; LD A,L
	DB 0ABH			; XOR E
	DB 6FH			; LD L,A

	JP L5F9B

L6054:	; SYNTAX: term ::= complemented factor |
	;		 { multiplying-operator complemented-factor }
	; out:	B = type

	CALL L60E9		; complemented factor
				; B = type

	LD A,B
	CALL SETDFT		; set new default type

L6057:	PUSH BC
	CALL L6E5A
	DB 1			; 1 byte following
	DW L7600 		; start of reserved word list:
				; *, /, AND, DIV, MOD, SHL, SHR
	POP BC
	RET NZ			; return if no multiplying operator

	; pointer types do not match with an multiplying-operator
	LD A,B
	CP 4			; type = POINTER ?
	CALL L72D4		; Zero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	LD A,(HL)		; 0 = *,   1 = /, 2 = AND,
				; 3 = DIV, 4 = MOD,
				; 5 = SHL, 6 = SHR
	PUSH AF
	PUSH BC
	CALL L6148		; generate code to push REAL, INTEGER,
				; BOOLEAN, CHAR, POINTER or LONGINT
				; on the stack

	CALL L60E9		; complemented factor
				; B = type

	POP DE
	POP AF			; A = multiplying-operator
	PUSH AF
	DEC A
	JR NZ,L6083		; jump if operator 0, 2, 3, 4, 5 or 6

	LD A,B
	CP 00AH			; current type = INTEGER ?
	JR NZ,L6083

	LD HL,_L1008		; LIB, convert integer HL to REAL HLDEBC
	CALL O_CALHL
	LD B,9			; current type = REAL

L6083:	CALL L6160		; convert previous and current to same type

	LD A,B
	CALL SETDFT		; set new default type

	POP AF
	LD E,A			; E = multiplying-operator

	LD A,B
	INC E
	DEC E
	JR NZ,L60A9

	; multiplying-operator = 0, *
	LD HL,_L1333		; LIB, multiply two SETS
	CP 3
	JR Z,L60A4

	LD HL,_L06F5		; LIB, multiply two INTEGERS
	CP 00AH
	JR Z,L60A4

	LD HL,_L_MUL		; LIB, multiply two LONGS
	CP 00EH			; LONG ?
	JR Z,L60A4

	LD HL,_L09FA		; LIB, multiply two REALS

L609E:	CP 9			; REAL ?

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	   operator

L60A4:	CALL O_CALHL
	JP L6057 		; repeat {
				;    multiplying-operator
				;    complemented-factor
				; }

L60A9:	LD HL,_L09FF		; LIB, divide two REALS
	DEC E			; multiplying-operator = '/' = 1
	JR Z,L609E

	DEC E
	JR NZ,L60CC		; jump if >= 2, DIV, MOD, SHL, SHR

	; multiplying-operator = 'AND'
	LD HL,_L_AND		; LIB, LONGINT AND LONGINT
	CP 00EH			; type = LONGINT ?
	JR Z,L60A4		; jump if type = LONGINT ?

	CP 00BH			; type = BOOLEAN ?
	JR Z,L60C3		; jump if BOOLEAN

	CP 00AH			; type = INTEGER ?

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	CALL O_CODE
	DB 3
	DB 7CH			; LD A,H
	DB 0A2H			; AND D
	DB 67H			; LD H,A

L60C3:	CALL O_CODE
	DB 3
	DB 7DH			; LD A,L
	DB 0A3H			; AND E
	DB 6FH			; LD L,A

	JP L6057

L60CC:	CP 00AH			; operator type = INTEGER ?
	JR NZ,L60CC1		; jump if not

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	LD HL,_L070F		; LIB, X div Y, INTEGER
	DEC E
	JR Z,L60A4
	LD HL,_L0745		; LIB, X mod Y, INTEGER
	DEC E
	JR Z,L60A4
	LD HL,_L074E		; LIB, X shl Y, INTEGER
	DEC E
	JR Z,L60A4
	LD HL,_L0756		; LIB, X shr Y, INTEGER
	JR L60A4

L60CC1:	CP 00EH			; operator type = LONGINT ?

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	LD HL,_L_DIV		; LIB, X div Y, LONGINT
	DEC E
	JR Z,L60A4
	LD HL,_L_MOD		; LIB, X mod Y, LONGINT
	DEC E
	JR Z,L60A4
	LD HL,_L_SHL		; LIB, X shl Y, INTEGER
	DEC E
	JR Z,L60A4
	LD HL,_L_SHR		; LIB, X shr Y, LONGINT
	JR L60A4

	CALL L72E1		; no condition
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

L60E9:	; SYNTAX: complemented factor ::= signed-factor | not signed-factor
	; out:	B = type
	CALL L6E76
	DW L7579 		; start of reserved word: NOT
	JR NZ,L6112		; jump if no NOT, signed-factor

	; NOT found in the text

	CALL L6112		; signed-factor
				; out: B = type
	LD A,B
	CALL SETDFT		; set new default type

	CP 00AH			; type = INTEGER ?
	JR Z,L6107		; jump if type = INTEGER

	CP 00EH			; type = LONGINT ?
	JR Z,L61071		; jump if type = LONGINT

	CP 00BH			; type = BOOLEAN;

	CALL L72DA		; NonZero --> error
	DB 2FH			; error 47: Operand type(s) does not match
				;	    operator

	; generate code for a NOT <BOOLEAN>
	CALL O_CODE
	DB 4
	DB 7DH			; LD A,L
	DB 0EEH,01H		; XOR 1
	DB 6FH			; LD L,A

	RET

L6107:	; generate code for a NOT <integer>
	CALL O_CODE
	DB 6
	DB 7DH			; LD A,L
	DB 2FH			; CPL
	DB 6FH			; LD L,A
	DB 7CH			; LD A,H
	DB 2FH			; CPL
	DB 67H			; LD H,A

	RET

L61071:	; generate code for a NOT <longint>
	LD HL,_L_NOT
	JP O_CALHL

L6112:	; SYNTAX: signed-factor ::= factor | sign factor
	; out:	B = type
	LD A,(L7BA1)		; 255 = minus sign
				;   0 = no sign
				;   1 = plus sign
	PUSH AF			; save old sign

	CALL L6A39		; get current sign, E = 0 if no sign
	LD A,E
	LD (L7BA1),A		; 255 = minus sign
				;   0 = no sign
				;   1 = plus sign

	CALL L621D		; factor
				; B = type

	LD A,B
	CALL SETDFT		; set new default type

	LD A,(L7BA1)
	LD E,A			; 255 = minus sign
				;   0 = no sign
				;   1 = plus sign

	CALL L6A4A		; sign = '-' ?
	JR Z,L6143		; jump if no minus sign

	LD A,B
	CP 00AH			; type = INTEGER ?
	JR NZ,L61121		; jump if not

	; generate code for integer negation
;	 PUSH HL
;	 LD HL,_L0783
;	 CALL O_CALHL		; a call is shorter, but slower !!
;	 POP HL
	CALL O_CODE		; out: code for negation of HL
	DB 7
	DB 7DH			; LD A,L
	DB 2FH			; CPL
	DB 6FH			; LD L,A
	DB 7CH			; LD A,H
	DB 2FH			; CPL
	DB 67H			; LD H,A
	DB 23H			; INC HL

	JR L6143

L61121:	CP 00EH			; type = LONGINT ?
	JR NZ,L613B		; jump if not

	; generate code for LONGINT negation
	PUSH HL
	LD HL,_L_NEG
	CALL O_CALHL
	POP HL
	JR L6143

L613B:	; generate code for REAL negation
	CALL O_CODE
	DB 4
	DB 78H			; LD A,B
	DB 0EEH,80H		; XOR 80H
	DB 47H			; LD B,A

L6143:	POP AF			; restore old sign
	LD (L7BA1),A		; 255 = minus sign
				;   0 = no sign
				;   1 = plus sign
	RET

L6148:	; generates code to PUSH a REAL, INTEGER, BOOLEAN, CHAR,
	;			POINTER or LONGINT on the stack
	; on the stack
	; in:	B = type
	; out:	-
	; changes: AF
	LD A,B
	CP 00EH
	JR Z,O_PSHLONG

	CP 00AH
	JR NC,L615D		; jump if type = INTEGER, BOOLEAN or CHAR

	CP 4
	JR Z,L615D		; jump if type = POINTER

	CP 8
	RET Z			; return if type = STRING
				; strings are already on the stack

	CP 3
	RET Z			; return if type = SET
				; sets are already on the stack

	LD A,0C5H
	CALL O_BYTE		; output: PUSH BC

O_PSHLONG:
	LD A,0D5H
	CALL O_BYTE		; output: PUSH DE

L615D:	JP O_PSHHL		; output: PUSH HL

L6160:	; in:	D = previous type, data is already pushed onto the stack
	;	E = type of SET, if previous type = SET
	;	B = current type,  data is in registers
	;	C = type of SET, if current type = SET

;	 LD A,D
;	 CP B
;	 JR Z,OP_TYPES_EQ

	PUSH DE
	LD A,D
	ADD A,A
	ADD A,A
	ADD A,A
	ADD A,A
	OR B			; A = ppppcccc, combination of operands

	LD HL,OP_CNVTAB
OP_CNV_SRCH:
	INC (HL) 		; end of table ?
	DEC (HL)
	JP Z,OP_CNV_END		; jump to quit search

	CP (HL)			; operand combination found ?
	JR Z,OP_CNV_FOUND

	INC HL
	INC HL
	INC HL
	JP OP_CNV_SRCH

OP_CNV_FOUND:
	INC HL
	LD A,(HL)
	INC HL
	LD H,(HL)
	LD L,A

	EX DE,HL
	LD HL,L61D3
	EX (SP),HL		; push return address L61D3 and
				; restore pushed DE
	EX DE,HL

	JP (HL)

OP_R_R:	CALL O_CODE
	DB 4
	DB 0D9H			; EXX	      ; HLDEBC' = current
	DB 0E1H			; POP HL
	DB 0D1H			; POP DE
	DB 0C1H			; POP BC       ; HLDEBC = previous
	RET

OP_R_I:	CALL O_CODE
	DB 7
	DB 0CDH			; CALL _L1008  ; convert HL to REAL HLDEBC
	DW _L1008
	DB 0D9H			; EXX	      ; HLDEBC' = current
	DB 0E1H			; POP HL
	DB 0D1H			; POP DE
	DB 0C1H			; POP BC       ; HLDEBC = previous

	LD B,9			; previous type = REAL
	RET

OP_R_L:	CALL O_CODE
	DB 7
	DB 0CDH			; CALL _L_R    ; convert DE:HL to REAL
	DW _L_R
	DB 0D9H			; EXX	      ; HLDEBC' = current
	DB 0E1H			; POP HL
	DB 0D1H			; POP DE
	DB 0C1H			; POP BC       ; HLDEBC = previous

	LD B,9			; previous type = REAL
	RET

OP_I_R:	CALL O_CODE
	DB 5
	DB 0D9H			; EXX	      ; HLDEBC' = current
	DB 0E1H			; POP HL       ; HL = value of previous
	DB 0CDH			; CALL _L1008  ; convert HL to REAL
	DW _L1008

	LD D,9			; previous type = REAL
	RET

OP_L_R:	CALL O_CODE
	DB 6
	DB 0D9H			; EXX	      ; HLDEBC' = current
	DB 0E1H			; POP HL       ; DE:HL = value of previous
	DB 0D1H			; POP DE       ;
	DB 0CDH			; CALL _L_R    ; convert DE:HL to REAL
	DW _L_R

	LD D,9			; previous type = REAL
	RET

OP_SCALAR:
OP_B_B:
OP_C_C:
OP_I_I:	; DE = previous, HL = current
	LD A,0D1H		; opcode: 'POP DE'
	JP O_BYTE

OP_S_C:	; generate code to convert CHAR to STRING (on the stack)

	CALL O_CODE
	DB 4
	DB 65H			; LD H,L
	DB 2EH,01H		; LD L,1
	DB 0E5H			; PUSH HL

	LD B,8			; current type = STRING
	RET

OP_C_S:	LD HL,_L09A2		; LIB, clear
	CALL O_CALHL		; convert the previous type to a STRING

	LD D,8			; previous type = STRING
	RET

OP_L_I:  ; previous LONGINT DE:HL on stack
	; current  INTEGER in HL --> LONGINT DE:HL
	CALL O_CODE
	DB 8
	DB 11H,0,0		;	LD DE,0
	DB 0CBH,7CH		;	BIT 7,H
	DB 28H,1 		;	JR Z,continue
	DB 1BH			;	DEC DE
				; continue:

	LD B,0EH 		; current type = LONGINT
	RET

OP_I_L:	; previous INTEGER on stack --> LONGINT DE:HL on stack
	; current  LONGINT in DE:HL
	CALL O_CODE
	DB 13
	DB 0D9H			;	EXX
	DB 0E1H			;	POP HL
	DB 11H,0,0		;	LD DE,0
	DB 0CBH,7CH		;	BIT 7,H
	DB 28H,1 		;	JR Z,continue
	DB 1BH			;	DEC DE
				; continue:

	DB 0D5H			;	PUSH DE
	DB 0E5H			;	PUSH HL
	DB 0D9H			;	EXX

	LD D,0EH 		; previous type = LONGINT
	RET

OP_CNV_END:
	POP DE

	LD A,D
	CP 10H
	CALL NC,OP_SCALAR 	; SCALAR type ?

L61D3:	LD A,B
	CP D			; types are equal ?

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

L61D31:	; types equal
	CP 3			; type = SET ?
	JR NZ,L61EA		; jump if not

	; type = SET
	LD A,E
	CP C
				; SET types compatible ?
	RET Z			; yes, return

	OR A			; previous SET = empty SET ?
	RET Z			; return C = type of current SET

	LD A,C
	LD C,E			; C = previous SET type
	OR A			; current SET = empty SET ?
	RET Z			; return C = type of previous SET

	CALL L72E1		; no condition
	DB 2CH			; error 44: Type mismatch

L61EA:	CP 4			; type = POINTER ?
	RET NZ			; return if not

	LD HL,(L7B8B)
	LD A,H
	OR L
	RET Z

	LD DE,(L7B8D)
	LD A,D
	OR E
	RET Z
	SBC HL,DE
	RET Z

	CALL L72E1		; no condition
	DB 2CH			; error 44: Type mismatch

OP_CNVTAB:
	DB 0AAH			; integer   integer
	DW OP_I_I

	DB 0BBH			; boolean   boolean
	DW OP_B_B

	DB 0CCH			; character character
	DW OP_C_C

         DB 044H                    ; 33e, pointer   pointer
         DW OP_I_I                  ; 33e

	DB 99H			; real	   real
	DW OP_R_R

	DB 9AH			; real	   integer
	DW OP_R_I

	DB 9EH			; real	   long
	DW OP_R_L

	DB 0A9H			; integer   real
	DW OP_I_R

	DB 0E9H			; long	   real
	DW OP_L_R

	DB 8CH			; string    character
	DW OP_S_C

	DB 0C8H			; character string
	DW OP_C_S

	DB 0EAH			; long	   integer
	DW OP_L_I

	DB 0AEH			; integer   long
	DW OP_I_L

	DB 0			; end of table

L6201:	LD DE,L5EEB		; { relational-operator simple-expression }
	PUSH DE
	LD DE,L5F9B		; { adding-operator term }
	PUSH DE
	LD DE,L6057		; { multiplying-operator complemented-factor }
	PUSH DE
	JR L622D 		; after parsing of an unsigned-constant

L620F:	LD DE,L5EEB		; { relational-operator simple-expression }
	PUSH DE
	LD DE,L5F9B		; { adding-operator term }
	PUSH DE
	LD DE,L6057		; { multiplying-operator complemented-factor }
	PUSH DE
	JR L6276

L621D:	; SYNTAX: factor ::= variable | unsigned-constant | (expression) |
	;		   function-designator | set
	; in:	E = sign (0 = no sign, 255 = minus, 1 = plus)
	; out:	B = type
	CALL L6A5C		; unsigned-constant
				; parse constant or constant identifier
	JR NZ,L6257		; jump if no constant parsed

	; constant parsed
	LD A,(L7BA1)
	LD E,A			; 255 = minus sign
				;   0 = no sign
				;   1 = plus sign

	CALL L6A1F		; negate REAL or INTEGER constant if there
				; is a '-' sign

	XOR A
	LD (L7BA1),A		; 255 = minus sign
				;   0 = no sign
				;   1 = plus sign

L622D:	; continue just parsing an unsigned-constant
	LD A,B
	CP 9
	JR NZ,L6249		; type = real ?, no skip

	; generate code for real constant:
	; 'LD HL,'
	; 'LD DE,'
	; 'LD BC,'
	EXX
	PUSH BC			; push real on compiler stack
	PUSH DE
	PUSH HL
	LD BC,331H		; B = 3 times, C = 21H + 10H
L6239:	LD A,C
	SUB 010H
	LD C,A
	CALL O_BYTE		; output opcode 'LD HL,' or
				;	       'LD DE,' or
				;	       'LD BC,'
	POP HL			; get 16 bits value
	CALL O_HL
	DJNZ L6239
	LD B,9			; return type = real
	RET

L6249:	CP 8			; type = STRING ?
	JP NZ,L62491		; jump if not

	LD HL,_L054D		; LIB, clear
	CALL O_CALHL
	JP L6B5E 		; output length (C) and data at L7A57

L62491:	CP 0EH			; type = LONGINT ?
	JP NZ,O_LDHL		; jump if not, assume INTEGER, CHAR, BOOL

	; generate code for LONGINT constant
	EXX
	CALL O_LDHL
	EX DE,HL
	CALL O_LDDE
	EX DE,HL
	LD B,0EH 		; return type = LONGINT
	RET

L6257:	LD BC,600H		; function identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info
	JR NZ,L6271		; jump if no function identifier

	; function identifer
	CALL L573D
	EX DE,HL
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)
	LD HL,(L7B5E)		; HL = address of functions type definition
	LD (L7B8B),HL		; save type definition
	LD A,(L7B5C)
	LD B,A			; B = result type of function
	JP SETDFT		; set new default type

L6271:	CALL L67B2
	JR NZ,L62D2

L6276:	LD A,(L7B5C)
	CP 8
	JR NC,L6285
	CP 3
	JR Z,L6285
	CP 4
	JR NZ,L629D

L6285:	CALL L66DA
	LD HL,(L7B5E)
	LD (L7B8B),HL
	LD A,(L7B5C)
	LD B,A
	CP 3			; type = SET ?
	RET NZ			; return if not SET

	; type = SET
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)
	LD A,(L7B5C)
	LD C,A
	RET

L629D:	CP 1

	CALL L72DA		; NonZero --> error
	DB 3EH			; error 62: Structured variables are not
				;	    allowed here

	CALL L678B		; bit 0,1 of (L7BBD)
				; 00 = LD HL, value in L7BBE
				; 01 = LD HL,(value in L7BBE)
				; 10 = LD DE, value in L7BBE
				;      ADD HL,DE
				; 11 = no output
	LD HL,(L7B5E)
	LD A,(HL)
	CP 00CH

	CALL L72DA		; NonZero --> error
	DB 3EH			; error 62: Structured variables are not
				;	    allowed here

	LD HL,(L7B60)
	LD A,(HL)
	CP 00AH

	CALL L72DA		; NonZero --> error
	DB 3EH			; error 62: Structured variables are not
				;	    allowed here

	LD HL,(L7B62)		; HL = length
	LD A,H			; length >= 256 ?
	OR A

	CALL L72DA		; NonZero --> error
	DB 3EH			; error 62: Structured variables are not
				;	    allowed here

	LD H,L			; H = length, operand
	LD L,6			; L = opcode 'LD B,'
	CALL O_HL

	LD HL,_L0638		; LIB, clear
	CALL O_CALHL

	LD B,8			; result type = STRING
	RET

L62D2:	CALL L6EE0		; match('[') or match('(.')
	JR NZ,L631C		; jump if not matched

	LD HL,_L0581		; LIB, push new empty SET on stack
	CALL O_CALHL
	CALL L6EF7		; match(']') or match('.)')
	LD BC,300H		; C = 0, no first time yet
				; B = 3, type = SET
	RET Z			; return if matched

L62E4:	PUSH BC
	LD A,0AH 		; A = default type = INTEGER
	CALL L5EBB		; parse simple expression
	LD A,B
	POP BC
	INC C			; already filled yet ?
	DEC C
	JR NZ,L62EF		; jump if already filled

	LD C,A

L62EF:	CP C

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

	PUSH BC

	CALL L6E76
	DW L7580 		; start of reserved word: ..

	LD HL,_L0591		; LIB, done
	JR NZ,L6310		; jump if no '..' found

	CALL O_PSHHL

	LD A,0AH 		; A = default type = INTEGER
	CALL L5EBB		; parse simple expression
	LD A,B
	POP BC
	PUSH BC
	CP C

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

	LD HL,_L059B		; LIB, done

L6310:	CALL O_CALHL
	POP BC
	CALL L6F13		; match(','), if present
	JR Z,L62E4		; jump if ',' matched

	JP L6F38 		; match(']')

L631C:	CALL L6F1B		; match('('), if present
	JR NZ,L6327		; jump if '(' not matched

	CALL L5EE8		; parse expression
	JP L6F6E 		; match(')')

L6327:	CALL L6E5A
	DB 2			; 2 bytes following
	DW L77B1 		; start of reserved word list:
				; standard library functions
				; CHR .. BIOS, 47
	JR NZ,L6335
	LD E,(HL)
	INC HL
	LD D,(HL)
	EX DE,HL
	XOR A
	JP (HL)

L6335:	CALL L6E76
	DW L757C 		; start of reserved word: NIL
	JR NZ,L6345		; jump if NIL not parsed

	; generate code for the NIL value
	LD HL,0000
	CALL O_LDHL

	LD HL,0000
	LD (L7B8B),HL
	LD B,4			; type = pointer
	RET

L6345:	LD BC,300H		; type identifier ?
	CALL L6E54		; check if current in id list, types
				; HL = address of info

;	 CALL Print_ABC

	CALL L72DA		; NonZero --> error
	DB 29H			; error 41: Unknown identifier or syntax error

	LD D,(HL)
	DEC HL
	LD E,(HL)
	LD A,(DE)
	CP 00AH

	CALL L72C8		; carry set --> error
	DB 1EH			; error 30: Simple type expected

	PUSH AF
	; A = default type
	CALL L65EF
	POP AF
	LD B,A
	RET

L6540:	CALL L6F6E		; match(')')

	CALL O_CALHL

	POP AF			; pop flag
	LD B,00AH		; set result type = INTEGER
	OR A
	RET NZ			; return if called as PROCEDURE

	; code to convert A in HL to return as function result
	CALL O_CODE
	DB 3
	DB 6FH			; LD L,A
	DB 26H,00H		; LD H,0

	RET

L65D5:	; parses an array index
	CALL L6F30		; match('[')
	CALL L5E97		; parse integer expression
	JP L6F38 		; match(']')

L65DE:	; parses a '(' integer expr. ')'
	CALL L6F66		; match('(')
	CALL L5E97		; parse integer expression
L65E4:	JP L6F6E 		; match(')')

L65E7:	PUSH AF
	CALL L6F66		; match('(')
	POP AF
	CALL L5EA2		; parse integer, longint or real expression
	JP L6F6E 		; match(')')

PARSE_O_IL_C:
	PUSH AF
	CALL L6F66		; match('(')
	POP AF
	CALL L5EA2		; parse integer, longint or real expression

	CP 0EH			; type = LONGINT ?
	JP Z,L6F6E		; match(')') if type = LONGINT

	CP 0AH

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

	JP L6F6E 		; match(')')

L65EF:	PUSH AF
	CALL L6F66		; match('(')
	POP AF
	CALL L5EBB		; parse simple expression
	JR L65E4 		; match(')')

L65F7:	CALL L6F1B		; match('('), if present
	JR Z,L6608		; jump if '(' matched
	LD HL,_OUTPUT		; LIB
	CALL O_LDHL

	LD A,6			; type = text
	LD (L7B5C),A
	RET

L6608:	CALL L5A17		; parse a file parameter

	CALL L72DA		; NonZero --> error
	DB 15H			; error 21: File variable expected

	PUSH AF
	CALL L6F6E		; match(')')
	POP AF
	RET

L661B:	; generate code to store a SET, STRING, REAL, POINTER, INTEGER,
	; BOOLEAN, CHAR, LONGINT
	;
	; in:	(L7B57) = 0, store direct
	;	(L7B57) = 1, store at pushed address
	;	(L7B57) = 2, store at indirect address
	LD A,(L7B57)
	LD C,A

	LD HL,(L7B58)		; HL = lvalue of id
	LD A,(L7B5C)
	CP 3			; type = SET ?
	JR NZ,L6634		; jump if not

	; type is SET

	; generate 'LD BC,offset * 256 + length'
	CALL L6734

	LD HL,_L0623		; LIB, save SET at pushed HL
	LD DE,_L0612		; LIB, save SET at HL
	JR L6648

L6634:	CP 8			; type = STRING ?
	JR NZ,L665E		; jump if not

	; type is STRING
	LD A,(L7B62)
	DEC A
	LD H,A
	LD L,6
	CALL O_HL		; output: 'LD B,max length of string'

	LD HL,_L0601		; LIB, save string at pushed HL
	LD DE,_L05E2		; LIB, save string at HL

L6648:	DEC C
	JR Z,L665B		; jump if C = 1, used pushed version

	EX DE,HL 		; use call with destination directly in HL

L664C:	LD A,021H		; LD HL,
	INC C
	JR Z,L6653		; jump if C = 0

	; C = 2
	LD A,02AH		; LD HL,()

L6653:	PUSH HL
	LD HL,(L7B58)		; HL = lvalue of id
	CALL O_OPHL
	POP HL

L665B:	JP O_CALHL

L665E:	CP 9			; type = REAL ?
	JR NZ,L6672		; jump if not

	; type is REAL

	; CODE: HLDEBC = current REAL
	CALL O_CODE
	DB 1
	DB 0D9H			; opcode: EXX

	LD HL,_L05D1		; LIB, PUTFLT, save HLDEBC' at HL
	DEC C
	JR NZ,L664C		; jump if C = 0 or C = 2

	; C = 1, destination address is pushed at stack
	CALL O_POPHL
	JP O_CALHL		; generate call PUTFLT

L6672:	CP 0EH			; type = LONGINT ?
	JR Z,ST_LONG		; generate code to store a LONGINT

	CP 4			; type = POINTER ?
	JR Z,L669D		; jump if POINTER

	LD A,(L7B9E)		; compiler directives
	BIT 1,A			; 1 = Index Range Checking on
	JR Z,L669D		; jump if off

	LD HL,(L7B5E)		; start address of variable
	LD DE,(L7B60)
	INC DE
	OR A
	SBC HL,DE
;!	pushf
	ADD HL,DE
;!	popf
	JR Z,L669D		; no checking if base = 0
	DEC DE
	CALL O_LDDE		; output: LD DE,base=HL
	EX DE,HL
	OR A
	SBC HL,DE
	INC HL
	CALL O_LDBC		; output: LD BC,length
	LD HL,_L0656		; LIB, clear
	CALL O_CALHL		; output call for range checking

L669D:	DEC C
	JR NZ,L66B7		; jump if C = 0 or C = 2

	; C = 1, use pushed version
	CALL O_CODE
	DB 2
	DB 0EBH			; EX DE,HL
	DB 0E1H			; POP HL 	; HL = destination address

L66A6:	CALL O_CODE
	DB 1
	DB 73H			; LD (HL),E

	LD A,(L7B62)
	DEC A
	RET Z

	CALL O_CODE
	DB 2
	DB 23H			; INC HL
	DB 72H			; LD (HL),D

	RET

L66B7:	LD HL,(L7B58)		; HL = lvalue of id
	INC C
	JR NZ,L66CF

	; C = 0, store direct
	; generates code to save a byte size expression or an integer size
	; expression
	LD A,(L7B62)		; A = low byte of length of lvalue
	DEC A			; expression is word or byte?

	LD A,22H 		; assume: opcode 'LD (),HL'
	JR NZ,L66CC

	; expression is byte
	CALL O_CODE
	DB 1
	DB 7DH			; LD A,L

	LD A,32H 		; opcode 'LD (),A'

L66CC:	JP O_OPHL		; out: LD (LVALUE),A or LD (LVALUE),HL

L66CF:	; C = 2, store indirect
	CALL O_CODE
	DB 2
	DB 0EBH			; EX DE,HL
	DB 2AH			; opcode: 'LD HL,()'

	CALL O_HL		; output destination address
	JR L66A6

ST_LONG: DEC C
	JR NZ,ST_LONG02		; jump if C = 0 or C = 2

	; C = 1, use pushed version
	CALL O_CODE
	DB 3
	DB 4DH			; LD C,L
	DB 44H			; LD B,H
	DB 0E1H			; POP HL 	; HL = destination address

ST_LONG_HL:
	CALL O_CODE
	DB 7
	DB 71H			; LD (HL),C	; store low-word
	DB 23H			; INC HL
	DB 70H			; LD (HL),B
	DB 23H			; INC HL
	DB 73H			; LD (HL),E	; store high-word
	DB 23H			; INC HL
	DB 72H			; LD (HL),D

	RET

ST_LONG02:
	LD HL,(L7B58)		; HL = lvalue of id
	INC C
	JR NZ,ST_LONG_INDIRECT	; jump if C = 2

	; C = 0
	LD A,22H
	CALL O_OPHL		; LD (lvalue),HL

	INC HL
	INC HL
	LD A,0EDH
	CALL O_BYTE
	LD A,53H
	JP O_OPHL		; LD (lvalue+2),DE

ST_LONG_INDIRECT:
	; C = 2, store indirect
	CALL O_CODE
	DB 3
	DB 4DH			; LD C,L
	DB 44H			; LD B,H
	DB 2AH			; opcode: 'LD HL,()'

	CALL O_HL		; output loading of destination address
	JR ST_LONG_HL

L66DA:	; generate code to load a REAL, STRING, SET, INTEGER, BOOLEAN,
	; CHAR or LONGINT
	LD A,(L7B5C)
	CP 00AH
	JR NC,L6701		; jump if INTEGER, BOOLEAN, CHAR or LONGINT

	CP 4
	JR Z,L6701		; jump if pointer

	PUSH AF
	CALL L678B		; bit 0,1 of (L7BBD)
				; 00 = LD HL, value in L7BBE
				; 01 = LD HL,(value in L7BBE)
				; 10 = LD DE, value in L7BBE
				;      ADD HL,DE
				; 11 = no output
	POP AF

	LD HL,_L052C		; LIB, GETFLT, clear
	CP 9
	JR Z,L66FE		; jump if REAL

	LD HL,_L053A		; LIB, clear
	CP 8
	JR Z,L66FE		; jump if STRING

	; generate 'LD BC,offset * 256 + length'
	CALL L6734
	LD HL,_L055D		; LIB, push a set on to a stack

L66FE:	JP O_CALHL

L6701:	LD A,(L7BBD)
	OR A			; indexed or VAR ?
	JR NZ,L671B

	; normal addressing of variable
	LD A,02AH
	LD HL,(L7BBE)
	CALL O_OPHL		; LD HL,( HL )

	LD A,(L7B5C)
	CP 00EH			; type = LONGINT ?
	JR NZ,L67011		; jump if not

	; output code to load high-word of longint
	LD A,0EDH		; opcode: LD DE,()
	CALL O_BYTE
	LD A,5BH
	INC HL
	INC HL
	JP O_OPHL		; LD DE,( L7BBE+2 )

L67011:	LD A,(L7B62)
	DEC A			; size = 1 ?
	RET NZ			; return if size > 1

L6714:	CALL O_CODE
	DB 2
	DB 26H,00H		; LD H,0

	RET

L671B:	CALL L678B		; bit 0,1 of (L7BBD)
				; 00 = LD HL, value in L7BBE
				; 01 = LD HL,(value in L7BBE)
				; 10 = LD DE, value in L7BBE
				;      ADD HL,DE
				; 11 = no output
	LD A,(L7B62)
	CP 4			; size = 4 ?
	JR Z,O_LDLONG		; output load indirect long

	DEC A			; size = 1 ?
	JR NZ,L672B		; jump if size > 1

	; size = 1
	CALL O_CODE
	DB 1
	DB 6EH			; LD L,(HL)

	JR L6714 		; LD H,0

O_LDLONG:CALL O_CODE
	DB 9
	DB 5EH			; LD E,(HL)	; DE = low-word
	DB 23H			; INC HL
	DB 56H			; LD D,(HL)
	DB 23H			; INC HL
	DB 7EH			; LD A,(HL)
	DB 23H			; INC HL
	DB 66H			; LD H,(HL)	; HL = high-word
	DB 6FH			; LD L,A
	DB 0EBH			; EX DE,HL	; complete LONGINT DE:HL

	RET

L672B:	CALL O_CODE
	DB 4
	DB 5EH			; LD E,(HL)
	DB 23H			; INC HL
	DB 56H			; LD D,(HL)
	DB 0EBH			; EX DE,HL

	RET

L6734:	; generate 'LD BC,offset * 256 + length'
	LD HL,(L7B5E)		; HL = address of type definition
	CALL L5271		; 8 bytes from HL (down) to 7B69 (up)

	LD HL,(L7B62)		; L = lenght of SET in bytes
	LD A,(L7B6B)		; A = low byte of lower bound
	RRA
	RRA
	RRA
	AND 01FH
	LD H,A			; H = byte offset in SET

	JP O_LDBC		; B = offset, C = length

L6749:	CALL L6A0D		; parse a constant of any type
	JR NZ,L677F		; jump to parse var parameter

	LD A,B
	CP 8			; type = STRING ?

	CALL L72DA		; NonZero --> error
	DB 3CH			; error 60: Constants are not allowed here

	LD L,018H		; opcode: JR
	LD H,C			; H = length of STRING constant
	CALL O_HL		; jump over constant 'JR length'

	LD (L7B58),IY		; save address of STRING constant
	LD A,1
	LD (L7B5C),A
	LD HL,L74E2		; definition of a char
	LD (L7B5E),HL
	LD HL,0000
	LD (L7B60),HL
	LD L,C
	LD (L7B62),HL		; size of constant
	CALL L6B62
	LD A,021H		; opcode: LD HL,
	LD HL,(L7B58)		; HL = address of STRING constant
	JP O_OPHL		; LD HL, HL

;Print_ABC:
;	 PUSH AF
;	 LD A,13
;	 CALL L03C9
;	 LD A,10
;	 CALL L03C9
;	 LD A,'A'
;	 CALL L03C9
;	 LD A,'B'
;	 CALL L03C9
;	 LD A,'C'
;	 CALL L03C9
;	 LD A,13
;	 CALL L03C9
;	 LD A,10
;	 CALL L03C9
;	 POP AF
;	 RET

L677F:	; parses a var parameter
	; out:	A = type of parsed var parameter
	CALL L6787
	RET Z

	CALL L72E1		; no condition
	DB 29H			; error 41: Unknown identifier or syntax error

L6787:	CALL L67B2
	RET NZ

L678B:	; bit 0,1 of (L7BBD)
	; 00 = LD HL, value in L7BBE
	; 01 = LD HL,(value in L7BBE)
	; 10 = LD DE, value in L7BBE
	;      ADD HL,DE
	; 11 = no output
	; out:

	LD A,(L7BBD)
	LD HL,(L7BBE)		; HL = address or normal value
	BIT 1,A
	JR NZ,L67A2
	BIT 0,A
	LD A,021H		; LD HL,
	JR Z,L679D
	LD A,02AH		; LD HL,()

L679D:	CALL O_OPHL
	XOR A			; return carry = 0, A = 0
	RET

L67A2:	BIT 0,A
	JR NZ,L67B0		; jump if no output, return carry=0, A = 0

	LD A,011H		; LD DE,
	CALL O_OPHL

	CALL O_CODE
	DB 1
	DB 19H			; ADD HL,DE

L67B0:	XOR A			; return carry = 0, A = 0
	RET

L67B2:	CALL L680C
	JR Z,L67D9

	LD BC,400H		; variable identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info
	JR NZ,L67ED		; jump if no variable identifier

	; variable identifier found
	CALL L5276		; id info at 7B5C
	LD A,(L7B57)
	OR A			; 0?, 0 = no VAR, 1 = VAR
	LD A,021H		; opcode 'ld hl,'
	LD B,0
	JR Z,L67CF		; jump if no VAR

	LD A,02AH		; opcode 'ld hl,()'
	INC B			; B = 1

L67CF:	LD HL,L7BBD
	LD (HL),B		; B = 0: 'LD HL,'
				; B = 1: 'LD HL,()'

	LD HL,(L7B58)		; HL = lvalue of id
	LD (L7BBE),HL		; current address of variable

L67D9:	CALL L683A
	JR Z,L67D9

	CALL L6931		; '.' variablename ?
	JR Z,L67D9		; yes, repeat for next

	CALL L6974		; variablename '^' ?
	JR Z,L67D9		; yes, repeat for next

	CALL L699F
	XOR A
	RET

L67ED:	CALL L6E76		; MEM is following ?
	DW L78FA 		; start of reserved word: MEM
	RET NZ			; quit if not

	CALL L65D5		; parses an array index

	LD A,00AH
	LD (L7B5C),A		; type = byte / integer
	LD HL,1
	LD (L7B62),HL		; size = 2
	DEC L
	LD (L7B5E),HL		; = 0	  , min value
	DEC L
	LD (L7B60),HL		; = 0FFFFH , max value
	JP L6903

L680C:	LD A,(L7BC9)
	LD B,A

L6810:	DEC B
	RET M			; quit if < 0
	PUSH BC
	LD E,B
	LD D,0
	LD HL,L7BCC
	ADD HL,DE
	LD A,(HL)
	LD C,A
	LD B,4			; variable identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info
	POP BC
	JR NZ,L6810

	PUSH HL
	LD A,B
	ADD A,A
	LD E,A
	LD D,0
	LD HL,(L7BCA)
	ADD HL,DE
	LD (L7BBE),HL
	LD HL,L7BBD
	LD (HL),1
	POP HL
	JP L6948

L683A:	LD A,(L7B5C)
	CP 1
	RET NZ

	CALL L6EE0		; match('[') or match('(.')
	RET NZ			; quit if no '[' or '(.' matched

	CALL L678B		; bit 0,1 of (L7BBD)
				; 00 = LD HL, value in L7BBE
				; 01 = LD HL,(value in L7BBE)
				; 10 = LD DE, value in L7BBE
				;      ADD HL,DE
				; 11 = no output

L6847:	CALL O_PSHHL

	LD A,(L7B5C)		; A = default type
	CALL L5E84		; parse a sub expression

	LD HL,(L7B60)
	CALL L5271		; 8 bytes from HL (down) to 7B69 (up)
	LD A,(L7B69)
	CP B

	CALL L72DA		; NonZero --> error
	DB 2CH			; error 44: Type mismatch

	LD HL,(L7B6B)
	LD A,H
	OR A
	JR NZ,L6874
	LD A,L
	CP 4
	JR NC,L6888

L6867:	OR A
	JR Z,L6893
	PUSH AF

	CALL O_CODE
	DB 1
	DB 2BH			; DEC HL

	POP AF
	DEC A
	JR L6867

L6874:	INC A
	JR NZ,L6888
	LD A,L
	CP 0FDH
	JR C,L6888

L687C:	PUSH AF

	CALL O_CODE
	DB 1
	DB 23H			; INC HL

	POP AF
	INC A
	JR NZ,L687C
	JR L6893

L6888:	CALL L6A30
	CALL O_LDDE		; output: 'LD DE,value HL'

	CALL O_CODE
	DB 1
	DB 19H			; ADD HL,DE

L6893:	LD A,(L7B9E)		; compiler directives
	BIT 1,A			; 1 = Index Range Checking on
	JR Z,L68AE		; jump if off

	LD HL,(L7B6D)
	LD DE,(L7B6B)
	OR A
	SBC HL,DE
	INC HL
	CALL O_LDDE		; output: 'LD DE,value HL'
	LD HL,_L064C		; LIB
	CALL O_CALHL

L68AE:	LD HL,(L7B5E)
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)

	LD HL,(L7B62)		; HL = variable size
	LD A,H
	OR A
	JR NZ,L68D8		; jump if size >= 256

	LD A,L
	DEC A			; size = 1 ?
	JR Z,L68ED		; jump if size = 1

	DEC A			; size = 2 ?
	JR NZ,L68AE1		; jump if not

	; size = 2
	CALL O_CODE
	DB 1
	DB 29H			; ADD HL,HL

	JR L68ED 		; add base

L68AE1:	CP 2			; size = 4 ?, already 2 subtracted
	JR NZ,L68C9

	; size = 4
	CALL O_CODE
	DB 2
	DB 29H			; ADD HL,HL
	DB 29H			; ADD HL,HL

	JR L68ED 		; add base

L68C9:	CP 4			; size = 6 ?, already 2 subtracted
	JR NZ,L68D8

	; generate code for HL * 6, size = 6
	CALL O_CODE
	DB 5
	DB 29H			; ADD HL,HL   , * 2
	DB 5DH			; LD E,L
	DB 54H			; LD D,H
	DB 29H			; ADD HL,HL   , * 4
	DB 19H			; ADD HL,DE   , * 2 + * 4

	JR L68ED 		; add base

L68D8:	LD A,(L7B9E)		; compiler directives
	BIT 4,A			; 1 = Array Optimization on
	JR NZ,L68EA		; jump if on

	CALL O_LDDE		; output: 'LD DE,value HL'
	LD HL,_L06F5		; LIB
	CALL O_CALHL
	JR L68ED

L68EA:	CALL L690A

L68ED:	CALL O_CODE
	DB 2
	DB 0D1H			; POP DE
	DB 19H			; ADD HL,DE

	LD A,(L7B5C)
	CP 1
	JR NZ,L6900
	CALL L6F13		; match(','), if present
	JP Z,L6847		; jump if ',' matched
L6900:	CALL L6F38		; match(']')

L6903:	LD A,3
	LD (L7BBD),A
	XOR A
	RET

L690A:	LD B,1

L690C:	LD A,H
	OR A
	JR NZ,L6914		; HL non-zero

	LD A,L
	DEC A
	JR Z,L6927

L6914:	BIT 0,L			; bit 0 = '0' ?
	JR Z,L691C		; jump if '0', generate 'ADD HL,HL'

	; save current value to be added later
	CALL O_PSHHL
	INC B

L691C:	CALL O_CODE
	DB 1
	DB 29H			; ADD HL,HL

	SRL H			; HL = HL / 2
	RR L
	JR L690C

L6927:	DEC B
	RET Z

	CALL O_CODE
	DB 2
	DB 0D1H			; POP DE
	DB 19H			; ADD HL,DE

	JR L6927

L6931:	LD A,(L7B5C)
	CP 2			; record type ?
	RET NZ			; return if not

	CALL L6F17		; match('.'), if present
	RET NZ			; return if '.' not matched

	LD A,(L7B5D)
	LD C,A			; level within record
	LD B,4			; variable identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info

	CALL L72DA		; NonZero --> error
	DB 29H			; error 41: Unknown identifier or syntax error

L6948:	CALL L5276		; id info at 7B5C
	LD HL,(L7B58)		; HL = lvalue of id or offset of base of id
	LD A,H
	OR L
	RET Z			; quit if lvalue of id == 0
				; can only be 0 if it is an offset which
				; is zero (first variable in a record),
				; it generates no code

	LD HL,L7BBD
	BIT 0,(HL)
	JR Z,L6967		; jump if LD HL, value in L7BBE
				;      or LD DE, value in L7BBE
				;	 ADD HL,DE

	PUSH HL
	CALL L678B		; bit 0,1 of (L7BBD)
				; 00 = LD HL, value in L7BBE
				; 01 = LD HL,(value in L7BBE)
				; 10 = LD DE, value in L7BBE
				;      ADD HL,DE
				; 11 = no output
	POP HL
	LD (HL),2
	LD HL,(L7B58)		; HL = lvalue of id
	LD (L7BBE),HL		; set new current address of variable

	XOR A			; return Zero
	RET

L6967:	LD HL,(L7BBE)
	LD DE,(L7B58)		; HL = offset to field id
	ADD HL,DE
	LD (L7BBE),HL		; set new current address of variable

	XOR A			; return Zero
	RET

L6974:	; variablename '^'
	LD A,(L7B5C)
	CP 4			; type = POINTER ?
	RET NZ			; return if not a pointer

	CALL L6F27		; match('^')
	RET NZ

	LD HL,L7BBD
	LD A,(HL)
	OR A
	JR NZ,L6988

	; direct value --> make indirect
	INC (HL) 		; 01 = LD HL,(value in L7BBE)
	JR L6997

L6988:	PUSH HL
	CALL L678B		; bit 0,1 of (L7BBD)
				; 00 = LD HL, value in L7BBE
				; 01 = LD HL,(value in L7BBE)
				; 10 = LD DE, value in L7BBE
				;      ADD HL,DE
				; 11 = no output
	POP HL
	LD (HL),3		; no output next time

	CALL O_CODE
	DB 4
	DB 5EH			; LD E,(HL)
	DB 23H			; INC HL
	DB 56H			; LD D,(HL)
	DB 0EBH			; EX DE,HL

L6997:	LD HL,(L7B5E)
	CALL L5287		; 8 bytes from HL (down) to 7B5C (up)

	XOR A			; return Zero
	RET

L699F:	LD A,(L7B5C)
	CP 8			; type = STRING ?
	RET NZ

	CALL L6EE0		; match('[') or match('(.')
	RET NZ			; quit if no '[' or '(.' matched

	CALL L678B		; bit 0,1 of (L7BBD)
				; 00 = LD HL, value in L7BBE
				; 01 = LD HL,(value in L7BBE)
				; 10 = LD DE, value in L7BBE
				;      ADD HL,DE
				; 11 = no output
	CALL O_PSHHL
	LD HL,(L7B62)
	PUSH HL
	CALL L5E97		; parse integer expression
	POP HL
	LD A,(L7B9E)		; compiler directives
	BIT 1,A			; 1 = Index Range Checking on
	JR Z,L69C7		; jump if off
	CALL O_LDDE		; output: 'LD DE,value HL'
	LD HL,_L064C		; LIB
	CALL O_CALHL

L69C7:	CALL O_CODE
	DB 2
	DB 0D1H			; POP DE
	DB 19H			; ADD HL,DE

	CALL L6F38		; match(']')
	LD A,00CH
	LD (L7B5C),A
	LD HL,0001
	LD (L7B62),HL
	DEC HL
	LD (L7B5E),HL
	DEC L
	LD (L7B60),HL
	LD A,3
	LD (L7BBD),A
	XOR A
	RET

L69EA:	CALL L6A0D		; parse a constant of any type
	RET Z

	CALL L72E1		; no condition
	DB 29H			; error 41: Unknown identifier or syntax error

L69F2:	; parses an integer constant
	LD A,0AH
	LD (DEF_TYPE),A		; default type = INTEGER
	CALL L69EA		; parse a constant of any type
				; error if not found
	LD A,B
	CP 00AH
	RET Z

	CALL L72E1		; no condition
	DB 16H			; error 22: Integer constant expected

L69FD:	; parses a string constant
	; out:	B = 8, character constant will be casted to string constant
	;	C = length of string constant
	CALL L69EA		; parse a constant of any type
				; error if not found
	LD A,B
	CP 8			; STRING constant ?
	RET Z			; return if STRING constant

	CP 00CH			; CHAR constant ?

	CALL L72DA		; NonZero --> error
	DB 20H			; error 32: String constant expected

	LD B,8			; return as STRING constant
	RET

L6A0D:	; parses a constant of any type
	CALL L6A39		; get current sign, E = 0 if no sign
	PUSH DE

	CALL L6A5C		; unsigned-constant
				; parse constant or constant identifier
	POP DE
	JR Z,L6A1F		; jump to negate constant if the sign = '-'

	INC E			; sign before constant ?
	DEC E

	CALL L72DA		; NonZero --> error
	DB 19H			; error 25: Integer or real constant expected

	DEC E			; return E = 255
	RET

L6A1F:	; negates the REAL, LONGINT or INTEGER constant if there is a '-' sign ?
	CALL L6A4A		; sign = '-' ?
	RET Z			; return if no minus sign

	LD A,B
	CP 9			; type = REAL ?
	JR NZ,L6A1F1		; jump if not

	; negate REAL constant internally
	EXX
	LD A,B
	XOR 080H
	LD B,A
	EXX
	XOR A
	RET

L6A1F1:	CP 0AH			; type = INTEGER ?
	JR NZ,L6A31		; jump if not

L6A30:	CALL L0783		; negate INTEGER constant internally
	XOR A
	RET

L6A31:	; negate LONGINT constant internally
	EXX
	CALL L_NEG
	EXX
	XOR A
	RET

L6A39:	; SYNTAX: sign ::= + | -
	; in:	IX = current text pointer
	; out:	E = 255, if current character  = '-'
	;	E =   0, if current character != '+', no sign
	;	E =   1, if current character  = '+'
	LD E,0FFH
	LD A,(IX+0)
	CP '-'                     ; '-' ?
	JR Z,L6A47		; next non-blank if '-' found

	INC E			; E = 0
	CP '+'                     ; '+' ?
	RET NZ			; quit if no '-' nor '+'

	INC E			; E = 1
L6A47:	JP L6F92 		; to next non-blank

L6A4A:	; in:	E = sign, 255 = '-', 0 = no sign, 1 = '+'
	;	B = type
	INC E
	DEC E
	RET Z			; return if no sign
	LD A,B
	CP 00AH			; type = INTEGER ?
	JR Z,L6A56

	CP 9			; type = REAL ?
	JR Z,L6A56

	CP 0EH			; type = LONGINT ?
	JR NZ,L6A58		; jump if error

L6A56:	DEC E			; return NZ if sign = '-'
	RET

L6A58:	CALL L72E1		; no condition
	DB 19H			; error 25: Integer, longint or real constant expected

L6A5C_SIGN:
	DB 0

L6A5C:	; SYNTAX: unsigned-constant ::= unsigned-number | string |
	;			     constant-identifier
	; in:	IX = current text pointer
	;	E = sign (0 = no sign, 255 = minus, 1 = plus)
	; out:	B = 08h, type = string, C = length, L7A57 filled with value
	;	B = 0Ch, type = char,   C = 1, HL character value
	;	B = 09h, type = real,   HLDEBC' = real value
	;	B = 0Ah, type = integer, HL = integer value
	;	E = 0Eh, type = longint, DEHL' = longint value
	;	Z-flag = 1, succeeded
	;	Z-flag = 0, not a constant nor a constant variable identifier
	LD A,E
	LD (L6A5C_SIGN),A
	CALL L6A99		; check for an unsigned-constant | string
	RET Z			; return if a constant found

	LD BC,200H		; constant identifier ?
	CALL L6E54		; check if current in id list
				; HL = address of info
	RET NZ			; return if not in id list

	LD B,(HL)		; B = type of constant name
	LD A,B
	DEC HL

	CP 00EH			; type = LONGINT ?
	JR Z,L6A741		; jump if type = LONGINT

	CP 00AH			; not an INTEGER, BYTE, CHAR nor BOOLEAN
	JR C,L6A74		; jump if type < 10

	; return INTEGER, BYTE, CHAR or BOOLEAN constant in HL
	LD D,(HL)
	DEC HL
	LD E,(HL)
	EX DE,HL

	XOR A			; return with Zero
	RET

L6A74:	CP 9
	JR NZ,L6A88		; jump if type not REAL

	; return REAL value in HLDEBC'
	PUSH BC

	LD B,(HL)
	DEC HL
	LD C,(HL)
	DEC HL

L6A742:	LD D,(HL)
	DEC HL
	LD E,(HL)
	DEC HL
	LD A,(HL)
	DEC HL
	LD L,(HL)
	LD H,A
	EXX

	XOR A			; return with Zero
	POP BC
	RET

L6A741:	; return LONGINT constant in DEHL'
	PUSH BC
	JR L6A742

L6A88:	LD C,(HL)		; C = length
	LD DE,L7A57
	PUSH BC
	INC C

L6A8E:	DEC C
	JR Z,L6A97		; jump and return with Zero

	DEC HL
	LD A,(HL)
	LD (DE),A
	INC DE
	JR L6A8E

L6A97:	POP BC
	RET

L6A99:	; in:	IX = current text position
	; out:	B = 08h, type = string, C = length, L7A57 filled with value
	;	B = 0Ch, type = char,   C = 1, HL character value
	;	B = 09h, type = real,   HLDEBC' = real value
	;	B = 0Ah, type = integer, HL = integer value
	;	B = 0Eh, type = longint, DE'HL' = longint value
	;	Z-flag = 1, succeeded
	LD A,(IX+0)
	CP 27H			; ', start of string constant ?
	JR Z,L6AA8		; jump if true

	CP '^'                     ; start of CTRL-<character> constant ?
	JR Z,L6AA8		; jump if true

	CP '#'                     ; start of #<num> constant ?
	JR NZ,L6B0E		; jump if not string nor character constant

L6AA8:	; read multiple <string>, <num> or CTRL-<character> constants
	LD HL,L7A57
	LD C,0
L6AAD:	LD A,(IX+0)
	CP '^'
	JR Z,L6AD8		; jump for CTRL-<character> constant

	CP '#'
	JR Z,L6AEE		; jump for #<num> constant

	CP 27H			; ', start of string constant ?
	JR NZ,L6AFE		; quit if none of these constants

	; read <string> constant
L6ABC:	INC IX
	LD A,(IX+0)
	OR A

	JR Z,L6AD31
;	 CALL L72D4		 ; Zero --> error
;	 DB 37H			 ; error 55: String constant exceeds line

	CP 027H			; last character = ' ?
	JR NZ,L6AD3		; jump and store character if not

	INC IX
	LD A,(IX+0)
	CP 027H			; two '-characters in a row ?
	JR NZ,L6AAD		; if not, jump to end string

	; store a '-character

L6AD3:	LD (HL),A		; store character
	INC HL
	INC C			; increase string length
	JR L6ABC 		; repeat

L6AD31:	CALL L72E1		; Zero --> error
	DB 37H			; error 55: String constant exceeds line

L6AD8:	; read CTRL-<character> constant
	INC IX
	LD A,(IX+0)
	CALL L04A6		; upcase
	OR A

	JR Z,L6AD31
;	 CALL L72D4		 ; Zero --> error
;	 DB 37H			 ; error 55: String constant exceeds line

	XOR 040H 		; ^A = #1, ^B = #2 etc.
	INC IX

L6AE9:	LD (HL),A
	INC HL
	INC C
	JR L6AAD 		; repeat for next string constant

L6AEE:	; read #<num> constant
	INC IX
	PUSH BC
	PUSH HL
	CALL L07F7		; convert hexadecimal or decimal to HL
	LD A,L
	POP HL
	POP BC

	CALL L72C8		; carry set --> error
	DB 38H			; error 56: Error in integer constant

	JR L6AE9

L6AFE:	LD B,8			; assume type = STRING
	LD A,C
	DEC A
	JR NZ,L6B0B		; STRING if length > 1

	LD H,A			; H = 0
	LD A,(L7A57)
	LD L,A			; HL = character
	LD B,00CH		; type = CHAR

L6B0B:	JP L6F95 		; get non-blank

L6B0E:	CP '$'                     ; hexadecimal constant ?
	JR Z,L6B45

	CALL L7286		; carry reset if A = digit
L6B15:	JR NC,L6B1A		; jump for start of REAL or integer
	XOR A
	DEC A			; return A = 255, and NonZero
	RET

L6B1A:	PUSH IX
	POP DE
L6B1D:	INC DE
	LD A,(DE)
	CALL L7286		; carry reset if A = digit
	JR NC,L6B1D		; yes, check next character

	CALL L04A6		; upcase
	CP 'E'                     ; 'E' from exponent ?
	JR Z,L6B39		; make REAL conversion to HLDEBC'
	CP '.'                     ; comma ?
	JR NZ,L6B45		; make integer conversion to HL

	INC DE
	LD A,(DE)
	CP '.'                     ; <num>.. ?
	JR Z,L6B45		; make integer conversion to HL
	CP ')'                     ; <num>)
	JR Z,L6B45		; make integer conversion to HL

L6B39:	; converts ascii REAL to HLDEBC
	; out:	HLDEBC' = binary REAL
	;	B = 9, type = real
	CALL L11A3		; convert ascii REAL to binary REAL HLDEBC

	CALL L72C8		; carry set --> error
	DB 39H			; error 57: Error in real constant

	EXX
	LD B,9			; type of real
	JR L6B0B 		; to next non-blank

L6B45:	; converts integer to HL or longint to DE'HL'
	; out:	HL = integer value
	;	B = 0Ah, type = INTEGER
	;	DE'HL' = longint value
	;	B = 0Eh, type = LONGINT
	CALL A2L 		; convert hexadecimal or decimal to DE:HL

	CALL L72C8		; carry set --> error
	DB 38H			; error 56: Error in integer constant

	LD C,A			; C = 0 if hexadecimal parsed

	LD A,(DEF_TYPE)
	CP 0FFH
	JR Z,SMART_CONST

	CP 0AH
	JR Z,L6B46		; check on integer

SMART_CONST_LONGINT:
	; check on longint
	INC C			; hexadecimal parsed ?
	DEC C
	JR Z,L6B451		; yes, don't check sign

	; DE = 0
	BIT 7,D			; DE negative ?
	JP Z,L6B451		; jump if not, OK

	LD A,(L6A5C_SIGN)
	INC A			; 255 ?, a minus sign present ?
	JP NZ,L4AE7		; error: constant out of range

	LD A,D			; long > MAXLONGINT + 1
	AND 7FH
	OR E
	OR H
	OR L
	JP NZ,L4AE7		; error: constant out of range

L6B451:	EXX			; save in DE'HL'
	LD B,0EH
	JP L6B0B

L6B46:	; constant must be integer
	LD A,D
	OR E
	JP NZ,L4AE7		; error: constant out of range

SMART_CONST_INTEGER:
	INC C			; hexadecimal parsed ?
	DEC C
	JR Z,L6B461		; jump if hexadecimal

	BIT 7,H			; HL >= 0 and HL <= 32767 ?
	JP Z,L6B461		; jump if OK

	LD A,(L6A5C_SIGN)
	INC A			; 255 ?, a minus sign present ?
	JP NZ,L4AE7		; error: constant out of range

	LD A,H
	AND 7FH
	OR L
	JP NZ,L4AE7		; error: constant out of range

L6B461:	LD B,0AH 		; type integer
	JP L6B0B 		; to next non-blank

SMART_CONST:
	LD A,D
	OR E
	JR NZ,SMART_CONST_LONGINT

	INC C			; hexadecimal parsed ?
	DEC C
	JR Z,L6B461		; return type = INTEGER

	BIT 7,H			; HL >= 32768 and HL <= 65535 ?
	JR Z,L6B461		; jump if within INTEGER positive range

	LD A,(L6A5C_SIGN)
	INC A			; 255 ?, a minus sign present ?
	JP NZ,L6B451		; no sign but out of range >> LONGINT

	LD A,H
	AND 7FH
	OR L
	JP Z,L6B461		; if 8000h then return type = INTEGER

	JP L6B451		; return type = LONGINT

;	 JR NZ,L6B451		 ; INTEGER out of range >> LONGINT
;
;	 JR L6B461		 ; return type = INTEGER

O_CODE:	; in:	first byte after call-instruction is non-zero length
	;	followed by 'length' data byte outputted by 'O_BYTE'
	; changes: HL, BC unchanged
	EX (SP),HL
	PUSH BC
	LD B,(HL)		; B = length
L6B53:	INC HL
L6B54:	LD A,(HL)
	CALL O_BYTE
	INC HL
	DJNZ L6B54
	POP BC
	EX (SP),HL		; jump to byte after last data byte
	RET

L6B5E:	; outputs length byte (C) and data at L7A57
	; in:	C = length of data
	; out:	C = 0
	;	Z-flag = 1
	;	B = unchanged !
	LD A,C			; output first 'C' bytes from L7A57
	CALL O_BYTE

L6B62:	LD HL,L7A57
	INC C
L6B66:	DEC C
	RET Z

	LD A,(HL)
	INC HL
	CALL O_BYTE

	JR L6B66

O_PSHHL: LD A,0E5H		 ; out: push hl
	JR O_BYTE

O_POPHL: LD A,0E1H		 ; out: pop hl
	JR O_BYTE

O_C3:	LD A,0C3H		; out: 'jp' opcode
	JR O_BYTE

O_DE:	LD A,E			; out: value of de
	CALL O_BYTE
	LD A,D
	JR O_BYTE

O_JPHL:	LD A,0C3H		; out: 'jp' opcode + value of hl
	JR O_OPHL

O_CALHL: LD A,0CDH                  ; out: 'call' opcode + value of hl
	JR O_OPHL

O_LDBC:	LD A,1			; out: 'ld bc,' opcode + value of hl
	JR O_OPHL

O_LDDE:	LD A,11H 		; out: 'ld de,' opcode + value of hl
	JR O_OPHL

O_LDHL:	LD A,21H 		; out: 'ld hl,' opcode + value of hl

O_OPHL:	CALL O_BYTE

O_HL:	LD A,L			; out: value of hl
	CALL O_BYTE
	LD A,H

O_BYTE:				; out: value of a
	PUSH BC
	LD B,A
	LD A,(L7900)		; 0 = compile to memory
				; 1 = code generation to disk
				; 2 = search address

;	 OR A
;	 JR NZ,L6BA7		 ; jump if not compiling to memory
;
;	 LD (IY+0),B
;
;L6BA7:
	INC IY
;	 OR A
;	 JR Z,L6BC6		 ; jump if compiling to memory

	PUSH HL
	PUSH DE

	DEC A			; A = 1 ?
	JR Z,L6BC1		; jump if compiling to disk

	PUSH IY
	POP DE
	DEC DE
	LD HL,(L00CE)
	OR A
	SBC HL,DE

	CALL L72D4		; Zero --> error
	DB 0C8H			; error 200: run-time error address found

	JR L6BC4

L6BC1:	CALL L6C02		; write B in record to update

L6BC4:	POP DE
	POP HL
L6BC6:	POP BC

L6BC7:	; check compiler/memory overflow
	; in:	-
	; out:	-
	PUSH HL
	PUSH DE

	LD DE,(L7BE1)		; start of free area + 1024

	; DE = lowest address that is still free

	LD (COMPCUR),DE		; current compiler address
	LD HL,(L7B73)		; top of variable table
	DEC H			; 256 bytes tolerance
	SCF
	SBC HL,DE
	JR C,ERR63

;	 CALL L72C8		 ; carry set --> error
;	 DB 63H			 ; error 99: Compiler overflow

	PUSH IY
	POP DE			; DE = destination address for code

	LD HL,(L7908)		; HL = data start address
	DEC H			; minus 512 bytes tolerance
	DEC H
	SBC HL,DE

	JR C,ERR62

	POP DE
	POP HL
	RET

	; these are used for printing more info during compilation about
	; the amount of free compiler memory and free space for code
COMPCUR: DW 0
;MEMCUR:  DW 0


ERR62:	CALL L72E1		; no condition
	DB 62H			; error 98: Memory overflow

ERR63:	CALL L72E1		; no condition
	DB 63H			; error 99: Compiler overflow


L6C02:	; With this routine a previous written block can be updated.
	; Used by FORWARD ?
	; in:	B = data byte to write in 128 byte buffer L7957
	;
	LD HL,L7BDB
	SET 1,(HL)		; block is dirty

	BIT 0,(HL)		; already read ?
	JR Z,L6C12		; jump if block already read

	RES 0,(HL)		; make already read

	PUSH BC
         CALL L6CF9                 ; read record to update in buffer L7957
	POP BC


L6C12:	; in:	B = data byte to write in 128 byte buffer L7957
	; out:	L7BDC increased to next byte in block
	;	reset if 0 if it became equal to block size

         ; CodeFileBufferPos
;         LD A,(L7BDC)               ; A = index to 128 byte buffer
;         LD E,A
;         LD D,0
;         LD HL,L7957                ; start of block buffer
         LD DE,(CodeFileBufferPos)
         LD HL,CodeFileBuffer
	ADD HL,DE

         LD (HL),B                  ; write data byte to buffer

;         INC A
;         JP P,L6C2C                 ; jump if index <= 127

         INC DE
         BIT 2,D                    ; test tenth bit, equals 1024 ?
         JP Z,L6C2C                 ; jump if < 1024

         CALL L6CFD                 ; write to file

         PUSH HL
         LD HL,(CodeFilePos)
         LD L,0
         LD A,H
         AND 0FCH
         LD H,A
;         LD A,L
;         AND 80H                    ; CodeFileBufferSize
;         LD L,A

;         LD DE,128                  ; CodeFileBufferSize
         LD DE,CodeFileBufferSize
         ADD HL,DE
         LD (CodeFilePos),HL
         POP HL

         JR NC,L6C2B

         LD HL,(CodeFilePos+2)
         INC HL
         LD (CodeFilePos+2),HL

L6C2B:
;         LD HL,(L7954)              ; increase file block count
;         INC HL                     ; because RANDOM READ/WRITE don't update
;         LD (L7954),HL              ; the block count

;         XOR A                      ; start all over with index = 0
         LD DE,0                    ; start over at byte 0 of buffer

L6C2C:
         LD (CodeFileBufferPos),DE
;         LD (L7BDC),A               ; save for next byte
	RET

L6C30:	;
	; in:	DE = number of data bytes to allocate
	; out:	-
	LD HL,(L7908)		; HL = data start address
	OR A
	SBC HL,DE		; carry set if (L7908) < DE

	CALL L72C8		; carry set --> error
	DB 62H			; error 98: Memory overflow

	LD (L7908),HL		; set new data start address
         JP L6BC7                   ; check compiler, memory overflow

L6C3F:   ; update address at HL with current address in IY
         ; in:    HL = address to update
         PUSH IY
	POP DE

L6C42:   ; in:    HL = address to update
	;	DE = data to update address HL with
	LD A,(L7900)
	DEC A
	JR Z,L6C53		; jump if compiling to disk

	; update directly in RAM
	PUSH IY			; save old code address

	PUSH HL
	POP IY			; set destination address for data
	CALL O_DE		; update data

	POP IY			; restore code address
	RET

L6C53:	PUSH BC
	PUSH DE			; save update data
	PUSH HL			; save address to update

	LD HL,(L7BDF)		; start address of update table

	LD A,(L7BE3)
	LD B,A			; B = number of update entries in table
	INC B

	; insert an entry in the update table
	; table is sorted from high to low
	; 7FFFH, 7865H, 7600H, 75FEH etc.
L6C5E:	DEC B
	JR Z,L6C84		; jump if end of table reached

	LD E,(HL)
	INC HL
	LD D,(HL)

         EX (SP),HL                 ; push update table pointer
				; pop address to update in HL
	OR A
	SBC HL,DE		; update address - DE
	ADD HL,DE

         EX (SP),HL                 ; pop update table pointer
				; push address to update

	JR C,L6C71		; jump if update address < DE
				; in range

	INC HL			; next entry in update table
	INC HL
	INC HL
	JR L6C5E

L6C71:	; DE = address read from update table
	DEC HL

	EX DE,HL 		; DE = pointer to first byte of entry
				; in update table
	LD L,B
	LD H,0
	ADD HL,HL		; HL = 4 * entries left in update table
	ADD HL,HL
	LD B,H			; BC = size of entries left
	LD C,L
	ADD HL,DE
	LD D,H
	LD E,L
	DEC HL			; HL = address last byte of lastused entry

	INC DE
	INC DE
	INC DE			; DE =
	LDDR

	INC HL
	; HL = address of new free inserted entry

L6C84:   POP DE                     ; pop address to update
	LD (HL),E
	INC HL
	LD (HL),D
	INC HL
         POP DE                     ; pop update data
	LD (HL),E
	INC HL
	LD (HL),D
	POP BC
	LD HL,L7BE3		; increase number to update ?
	INC (HL)
	RET NZ

	XOR A			; write 256 updates
	JR L6C9B

L6C96:	LD A,(L7BE3)
	OR A
	RET Z			; return if no updates

L6C9B:	PUSH BC
	PUSH DE
	PUSH IY
	LD B,A
	LD HL,(L7BDF)

L6CA3:	PUSH BC			; save number of updates left

	LD E,(HL)
	INC HL
	LD D,(HL)
	INC HL

	PUSH HL
	EX DE,HL
	CALL L6CC2
	POP HL

	LD B,(HL)
	INC HL

	PUSH HL
	CALL L6C02		; write B in record to update
	POP HL

	LD B,(HL)
	INC HL
	PUSH HL

         CALL L6C02                 ; write B in record to update

         POP HL

	POP BC			; B = number of updates left
	DJNZ L6CA3

	POP HL
	POP DE
	POP BC

L6CC2:   ; in:    HL = addres to update
	; out:	IY = HL
	; unchanged: BC, DE
	PUSH HL
	POP IY			; init IY with code address

	LD A,(L7900)
	DEC A
	RET NZ			; return if searching

	PUSH DE
	PUSH BC

	; calculate from current address in HL the
	; block position and
	; relative block number
	LD DE,(L7902)
	OR A
	SBC HL,DE		; HL = relative address to start of code

;         LD A,L
;         AND 07FH
;         LD (L7BDC),A               ; set position within block

;         LD A,L
;         AND 80H
;         LD L,A

         LD DE,(CodeFileStart)
         ADD HL,DE

         LD DE,(CodeFileStart+2)
         JR NC,L6CC3

         INC DE
L6CC3:

;         LD A,L
;         AND 07FH
;         LD (L7BDC),A               ; set position within block
         LD A,L
         LD (CodeFileBufferPos),A
         LD A,H
         AND 3
         LD (CodeFileBufferPos+1),A ; mask for CodeFileBufferSize = 1024

;         LD A,L
;         AND 80H
;         LD C,A

;         ADD HL,HL
;         LD L,H
;         RLA
;         AND 1
;         LD H,A                     ; HL = relative block number
;
;         LD DE,(L7BDD)              ; DE = first block of current part
;         ADD HL,DE

;         LD A,(CodeFilePos)
;         AND 80H
;         CP C
;         JR NZ,L6CC4

         LD A,H
         AND 0FCH                   ; mask for CodeFileBufferSize = 1024
         LD C,A

         LD A,(CodeFilePos+1)
         AND 0FCH                   ; mask for CodeFileBufferSize = 1024
         CP C
         JR NZ,L6CC4

         LD A,(CodeFilePos+2)
         CP E
         JR NZ,L6CC4

         LD A,(CodeFilePos+3)
         CP D
         JR Z,L6CF6

;         LD DE,(L7954)              ; DE = current block
;         OR A
;         SBC HL,DE
;;!       pushf
;         ADD HL,DE
;;!       popf
;         JR Z,L6CF6                 ; jump if equal to current block

L6CC4:
         PUSH DE
         PUSH HL
	CALL L6CFD		; write 128 bytes to file
	POP HL
         POP DE

         LD (CodeFilePos),HL
         LD (CodeFilePos+2),DE
;         LD (L7954),HL

L6CF6:	POP BC
	POP DE
	RET

L6CF9:   ; in:    FCB at L7933 filled in
	; out:	read 128 bytes from FCB to buffer at L7957
	; changes: HL, DE, BC
	; unchanged: IY

         PUSH IY

         LD HL,(CodeFilePos)
         LD L,0
         LD A,H
         AND 0FCH                   ; mask for CodeFileBufferSize == 1024
         LD H,A
;         LD A,L
;         AND 80H                    ; CodeFileBufferSize
;         LD L,A
         LD DE,(CodeFilePos+2)
         LD BC,CodeFile
         CALL FileSeek              ; set to current position

         LD HL,CodeFileBufferSize   ; read 128 bytes from file
                                    ; CodeFileBufferSize
         LD DE,CodeFileBuffer       ; L7957
         CALL ReadFile              ; read from file

         POP IY

         OR A
         RET Z                      ; quit if no errors

	CALL L72E1		; no condition
	DB 0FAH			; error 250: Disk or directory full

;         LD C,021H                  ; random record read 128 bytes
;         JR L6D09

L6CFD:
	; in:	FCB at L7933 filled in
	; out:	writes 128 byte buffer at L7957 to file
	;	no errors
	; changes: HL, DE, BC
	; unchanged: IY
	LD HL,L7BDB
	SET 0,(HL)		; 1 = no record read to update

	BIT 1,(HL)
	RET Z			; return if not busy updating

	RES 1,(HL)		; 0 = updating finished
;         LD C,022H                  ; random record write 128 bytes

L6D09:	; in:	C = 21H, read
	;	C = 22H, write
	; unchanged: IY

         PUSH IY
         LD HL,(CodeFilePos)
         LD L,0
         LD A,H
         AND 0FCH                   ; mask for CodeFileBufferSize == 1024
         LD H,A
;         LD A,L
;         AND 80H                    ; CodeFileBufferSize
;         LD L,A
         LD DE,(CodeFilePos+2)
         LD BC,CodeFile
         CALL FileSeek              ; set to current position

         LD HL,CodeFileBufferSize   ; read 128 bytes from file
                                    ; CodeFileBufferSize
         LD DE,CodeFileBuffer
         CALL WriteFile             ; read to file
         POP IY

         OR A

;         PUSH BC
;         LD DE,L7957                ; buffer
;         LD C,01AH
;         CALL DOSIXIY               ; set dma address
;         POP BC
;         LD DE,L7933
;         CALL DOSIXIY               ; random record read/write 128 bytes
;         OR A
;         RET Z                      ; return if no error
;         DEC A
;         RET Z                      ; return if end of file or disk full error
;         CP 3
         RET Z                      ; return if ???

	CALL L72E1		; no condition
	DB 0FAH			; error 250: Disk or directory full

L6D24:	; pushes 13 bytes starting at L7B64 to the stack
	; changes: HL',DE',BC'
	EXX
	LD DE,L7B64
	JR L6D2E

L6D2A:	; pushes 13 bytes starting at L7B57 to the stack
	; changes: HL',DE',BC'
	EXX
	LD DE,L7B57
L6D2E:	POP HL
	LD (L7BD5),HL		; temporary save return address
	LD HL,-13
	ADD HL,SP
	LD SP,HL
	EX DE,HL
	LD BC,13
	LDIR
L6D3D:	LD HL,(L7BD5)		; restore return address
	PUSH HL
	EXX
	RET

L6D43:	; pops 13 bytes to L7B64
	; changes: HL',DE',BC'
	EXX
	LD DE,L7B64
	JR L6D4D

L6D49:	; pops 13 bytes to L7B57
	; changes: HL',DE',BC'
	EXX
	LD DE,L7B57
L6D4D:	POP HL
	LD (L7BD5),HL
	LD HL,0
	ADD HL,SP
	LD BC,13
	LDIR
	LD SP,HL
	JR L6D3D

L6D5D:	; moves 13 bytes from stack+2 to L7B64
	; changes: HL',DE',BC'
	EXX
	LD DE,L7B64
	JR L6D67

L6D63:	; moves 13 bytes from stack+2 to L7B57
	; changes: HL',DE',BC'
	EXX
	LD DE,L7B57
L6D67:	LD HL,2
	ADD HL,SP
	LD BC,13
	LDIR
	EXX
	RET

L6D72:	; add IY to id table
	PUSH IY
	POP DE

L6D75:	; add DE to id table
;	 LD A,D
;	 CALL L6D7A		 ; add byte to id table
;	 LD A,E
	PUSH HL
	LD HL,(L7B73)
	LD (HL),D
	DEC HL			; decrease bottom of the table
	LD (HL),E
	DEC HL			; decrease bottom of the table
	LD (L7B73),HL
	POP HL
	JP L6BC7 		; check compiler, memory overflow

L6D7A:	; in:	A = data byte to be added to the identifier table
	; out:	-
	PUSH HL
	LD HL,(L7B73)
	LD (HL),A
	DEC HL			; decrease bottom of the table
	LD (L7B73),HL
	POP HL
	JP L6BC7 		; check compiler, memory overflow

L6D87:	; add the identifier at address IX to the identifier table
	; in:	-
	; out:	-
	LD A,(IX+0)
	CALL L7271		; letter or underscore?

L6D8D:	CALL L72C8		; carry set --> error
	DB 3AH			; error 58: Illegal character in identifier

	CALL L6ED0		; check if already in identifier table

L6D94:	CALL L6EB8		; test if reserved word
				; gives error 53 if word is reserved
	LD A,(IX+0)		; A = first letter
L6D9A:	CP 'a'
	JR C,L6DA4
	CP 'z'+1
	JR NC,L6DA4
	SUB 'a'-'A'
L6DA4:	CALL L6D7A		; add byte to id table
	INC IX
	LD A,(IX+0)
	CALL L7282		; letter, underscore or decimal
	JR NC,L6D9A
	LD HL,(L7B73)
	INC HL
	SET 7,(HL)		; mark end of added identifier
	JP L6F95 		; get to next non-blank

L6DBA:	LD A,(IX+0)
	CALL L7271		; letter or underscore?

	CALL L72C8		; carry set --> error
	DB 3AH			; error 58: Illegal character in identifier

	JR L6D94

L6DC6:	; calculates and adds the length of the newly defined struct
	; as a word to the id table
	; in:	(L7B75), (L7B73)
	; out:	added (L7B75) - (L7B73)
	;	(L7B75) = (L7B73)
	LD HL,(L7B75)		; HL = top of id table before
	LD DE,(L7B73)		; DE = top of id table after
	OR A
	SBC HL,DE		; calculate the difference
	EX DE,HL
	CALL L6D75		; add the length of the variable declaration
	LD HL,(L7B73)
	LD (L7B75),HL		; equal top before and top after
	RET

L6DDB:	; in:	B =
	;	C =
	LD HL,(L7B7B)		; HL = start of identifier list
	JR L6DE3

L6DE0:	; out:	-
	LD HL,(L7B77)		; HL = absolute top of id list

L6DE3:	; in:	HL = end of list to search
	;	B = 1 = LABEL,	2 = CONSTANT
	;	    3 = TYPE,	4 = VARIABLE
	;	    5 = PROCEDURE 6 = FUNCTION
	LD (L7B7D),HL
	LD A,(L7BC0)
	CP C
	JP Z,L6E48
	LD A,C
	LD (L7BC0),A
	LD HL,(L7B75)
L6DF3:
	LD DE,(L7B7D)

	LD A,E
	CP L
	JP NZ,L6E03
	LD A,D
	CP H
	JR NZ,L6E03

;	 XOR A
;	 SBC HL,DE		 ; tabel is empty if HL = DE
;;!	 pushf
;	 ADD HL,DE
;;!	 popf
;	 JR NZ,L6E03		 ; no, tabel is not empty
	XOR A
	LD (L7BC1),A
	DEC A			; return with 255 and NonZero
				; not found
	RET

L6E03:	INC HL
	LD E,(HL)		; DE = offset, # bytes of struct
	INC HL
	LD D,(HL)
	ADD HL,DE
	LD A,(HL)
	OR A			; first byte zero, does not contain a name
	JR Z,L6DF3		; yes, search next
	DEC HL
	LD A,(HL)
	INC HL
	CP C			; gelijk C?
	JR NZ,L6DF3		; no, search next

	PUSH BC
	PUSH HL
	LD DE,TEMPID
	DEC HL
	DEC HL			; HL = address of first letter of ID

	CALL FASTCMPR
	JP Z,L6E3B		; jump if equal

;L6E19:	 LD A,(DE)		 ; A = byte from text
;	 INC DE
;	 CP (HL)
;	 JR NZ,L6E37		 ; quit if not equal
;	 DEC HL
;	 BIT 7,A
;	 JR Z,L6E19		 ; repeat until end of string

;	 JP L6E3B		 ; jump if equal

;L6E19:	 LD B,(HL)
;	 LD A,(DE)		 ; A = byte from text
;	 DEC HL			 ; next from id tab
;	 INC DE			 ; next from text
;	 LD C,B
;	 RES 7,B
;	 CP 'a'                     ; >= 'a' ?
;	 JR C,L6E2A
;	 CP 'z'+1                   ; < 'z'+1 ?
;	 JR NC,L6E2A
;	 SUB 'a'-'A'                ; up case
;L6E2A:	 CP B
;	 JR NZ,L6E37
;	 BIT 7,C 		 ; end of this string?
;	 JR Z,L6E19		 ; no, compare next
;	 LD A,(DE)		 ; A = next letter to compare from DE string
;	 CALL L7282		 ; test if this character did not belong to
;				 ; the compared word
;	 JR C,L6E3B		 ; carry set if this string was terminated too
L6E37:	POP HL
	POP BC
	JR L6DF3 		; search next

FASTCMPR:; in:	HL = address of identifier from id table, downwards
	;	DE = address of upcased text identifier, upwards
	; out:	HL = position below last keyword character
	;	Z-flag = 1, found
	;	Z-flag = 0, not found
	LD A,(DE)		; A = byte from text
	INC DE
	CP (HL)
	RET NZ			; quit if not equal
	DEC HL
	BIT 7,A
	JR Z,FASTCMPR		; repeat until end of string
	XOR A
	RET

FASTCMP: ; in:	HL = address keyword, upwards
	;	DE = address of upcased text identifier, upwards
	; out:	HL = position after last keyword character
	;	DE = position after identifier in text
	;	Z-flag = 1, found
	;	Z-flag = 0, not found
	PUSH BC
	LD DE,TEMPID
FASTCMPL:LD A,(DE)		; A = byte from text
	INC DE
	CP (HL)
;!	pushf
	INC HL
;!	popf
	JR NZ,FASTCMPQ
	RET NZ			; quit if not equal
	OR A
	JP P,FASTCMPL		; repeat until end of string
	LD DE,(TEMPPTR)
	XOR A
FASTCMPQ:POP BC
	RET

BUILDID: ; out:	IX = current text pointer
	;	TEMPPTR = position after word in text
	PUSH DE
	PUSH IX
	POP DE
	LD HL,TEMPID-1
	LD A,(DE)		; A = first byte from text
	CALL L04A6		; up case
	INC DE
	INC HL
	LD (HL),A
	CALL L7282
	JR C,BUILDI2		; quit if no character of word

BUILDI1: LD A,(DE)
	CALL L7282		; legal character ?
	JR C,BUILDI2

	CALL L04A6		; up case
	INC DE			; next from text
	INC HL
	LD (HL),A		; save character
	JR BUILDI1

BUILDI2:
	SET 7,(HL)
	LD (TEMPPTR),DE
	POP DE
	RET

;	 LD A,(DE)
;BUILDI1: INC DE			 ; next from text
;	 CALL L04A6		 ; up case
;	 INC HL
;	 LD (HL),A		 ; save character
;	 LD A,(DE)
;	 CALL L7282		 ; test if this character did not belong to
;				 ; the compared word
;	 JR NC,BUILDI1		 ; carry set if this string was terminated too
;	 SET 7,(HL)
;	 LD (TEMPPTR),DE
;	 POP DE
;	 RET

TEMPPTR: DW 0
TEMPID:	DS 128

L6E3B:	LD (L7BC2),HL		; save position before known word
	LD DE,(TEMPPTR)
	LD (L7BC4),DE		; save position after word in text
	POP HL			; HL = start of known word declaration
	POP BC			; BC = (300H for type identifier or
				;       200H for constant identifier)
	LD A,(HL)		; A = type of known word
	LD (L7BC1),A

L6E48:	; in:	B =
	;	C =
	; out:	Z-flag set if B = (L7BC1)
	;	HL = position before known word
	;	DE = position after word in text
	LD HL,(L7BC2)
	LD DE,(L7BC4)
	LD A,(L7BC1)
	CP B			; identical types?
	RET

L6E54:	; searches if current word is an identifier list
	; in:	B = 1 = LABEL,	 2 = CONSTANT
	;	    3 = TYPE,	 4 = VARIABLE
	;	    5 = PROCEDURE, 6 = FUNCTION
	;	C =
	; out:	Z-flag = NonZero if not found
	;		Zero if found
	CALL L6DE0
	RET NZ			; return if not found
	JR L6E96 		; go to next non-blank

L6E5A:	; in:	first byte after call instruction is #bytes following the name
	;	second two byte form an address of a reserved word list
	; out:	Z-flag set if a reserved word is found that equals the word
	;	at position IX. HL then contains the address of the byte
	;	directly after the reserved word
	EX (SP),HL
	LD C,(HL)
	INC HL
	LD E,(HL)
	INC HL
	LD D,(HL)
	INC HL
	EX (SP),HL
	EX DE,HL

L6E63:	CALL L6E7D
	RET Z			; quit if okay

	DEC HL			; go back to last character tested
L6E68:	BIT 7,(HL)		; was this the last character?
;!	pushf
	INC HL
;!	popf
	JR Z,L6E68		; no, try again
	LD B,0
	ADD HL,BC
	LD A,(HL)
	OR A			; last word of this table checked?
	JR NZ,L6E63		; no, continue searching
	DEC A			; return with A = 255 and NonZero
				; for not found
	RET

L6E76:	; searches for the word in the text at IX in the given list
	;
	EX (SP),HL
	LD E,(HL)		; DE = address of reserved word
	INC HL
	LD D,(HL)
	INC HL
	EX (SP),HL		; new return address after 2 data bytes
	EX DE,HL 		; HL = address of reserved word

L6E7D:	PUSH IX
	POP DE
	LD A,(HL)		; get first character
	CALL L7271		; check if letter or underscore
	JR C,L6E92		; carry set if error
	CALL L6E9C		; compare strings
	RET NZ			; quit if not equal

	; at this point the strings are equal
	LD A,(DE)
	CALL L7282		; letter, underscore or decimal
	JR C,L6E96		; jump if not letter, underscore or decimal

	OR A
	RET

L6E92:	CALL L6E9C1		; compare strings
	RET NZ			; quit if not equal

L6E96:	; in:	DE = current text pointer
	; out:	IX = updated text pointer to next non-blank
	PUSH DE
	POP IX			; update text pointer to text buffer 79D7
	JP L6F95 		; moves IX to the next non-blank

L6E9C	EQU FASTCMP
	; compares string at HL with string at DE
	; stops if string at HL has bit 7 set or the current character
	; does not match
	; characters from DE are UPCASEed if necessary
	; in:	HL = string terminated by setting bit 7 of the last byte
	;	DE = string to compare with
	; out:	BC unchanged
	;	NonZero if the strings where not the same
	;	Zero if the strings are the same
	;	HL = first byte after the string
	;	DE = first byte after the string to compare with
;	 LD DE,TEMPID
;	 PUSH BC
;	 CALL FASTCMP
;	 POP BC
;	 RET

L6E9C1:	PUSH BC
L6E9D:	LD B,(HL)
	LD A,(DE)
	INC HL
	INC DE
	LD C,B
	RES 7,B
	CP 'a'                     ; < 'a'?
	JR C,L6EAE		; yes, continue
	CP 'z'+1                   ; > 'z'?
	JR NC,L6EAE		; yes, continue
	SUB 'a'-'A'
L6EAE:	CP B			; equal characters?
	JR NZ,L6EB6		; no, return with NonZero
	BIT 7,C			; last character of string in HL tested ?
	JR Z,L6E9D		; no, go for then next
	XOR A			; found, return with Zero
L6EB6:	POP BC
	RET

L6EB8:	; tests if the current name is a reserved word, slow!!!
	LD HL,L7513
L6EBB:	LD C,(HL)
	INC C
	RET Z			; quit if C was 255
	DEC C
	INC HL
	LD E,(HL)		; DE = address to table of reserved words
	INC HL
	LD D,(HL)
	INC HL
	PUSH HL
	EX DE,HL
	CALL L6E63
	POP HL
	JR NZ,L6EBB

	CALL L72E1		; no condition
	DB 35H			; error 53: Reserved word

L6ED0:	LD A,(L7B91)
	LD C,A
	CALL L6DDB

L6ED7:	LD A,(L7BC1)
	OR A
	RET Z

	CALL L72E1		; no condition
	DB 2BH			; error 43: Duplicate identifier or label

L6EE0:	; in:	-
	; out:	Zero if '[' parsed
	;	Zero if '(.' parsed
	LD A,'['
	CALL L6F29		; match('[')
	RET Z			; return if matched

	LD A,(IX+0)
	CP '('                     ; match('(')
	RET NZ			; return if not '(' matched

	LD A,(IX+1)
	CP '.'
	RET NZ			; return if not '(.' matched

L6EF2:	INC IX
	JP L6F92 		; to next non-blank

L6EF7:	; in:	-
	; out:	Zero if ']' parsed
	;	Zero if '.)' parsed
	LD A,']'
	CALL L6F29		; match(']')
	RET Z
	LD A,(IX+0)
	CP '.'
	RET NZ
	LD A,(IX+1)
	CP ')'
	RET NZ
	JR L6EF2

L6F0B:	; matches ':', if present
	; returns NZ if not matched
	LD A,':'
	JR L6F29

L6F0F:	; matches ';', if present
	; returns NZ if not matched
	LD A,';'
	JR L6F29

L6F13:	; matches ',', if present
	; returns NZ if not matched
	LD A,','                   ; checkes if ',' is the next symbol
	JR L6F29

L6F17:	; matches '.', if present
	; returns NZ if not matched
	LD A,'.'
	JR L6F29

L6F1B:	; matches '(', if present
	; returns NZ if not matched
	LD A,'('
	JR L6F29

L6F1F:	; matches ')', if present
	; returns NZ if not matched
	LD A,')'
	JR L6F29

L6F23:	; matches '=', if present
	; returns NZ if not matched
	LD A,'='
	JR L6F29

L6F27:	; matches '^', if present
	; returns NZ if not matched
	LD A,'^'

L6F29:	; matches character in A, if this is the next character
	; returns NZ if this is not the next character
	CP (IX+0)
	RET NZ			; quit if not equal
	JP L6F92 		; get next non-blank character if equal

L6F30:	; matches a '[' or '(.' and gives error 8 otherwise
	CALL L6EE0		; match('[') or match('(.')
	RET Z			; quit if '[' or '(.' matched

	CALL L72E1		; no condition
	DB 8			; error 8: '[' expected

L6F38:	; matches a ']' and gives error 9 otherwise
	CALL L6EF7		; match(']') or match('.)')
	RET Z			; return if matched

	CALL L72E1		; no condition
	DB 9			; error 9: ']' expected

L6F40:	; matches a ':' and gives error 2 otherwise
	CALL L6F0B		; match(':'), if present
	RET Z			; return if ':' matched

	CALL L72E1		; no condition
	DB 2			; error 2: ':' expected

L6F48:	; matches a ';' and gives error 1 otherwise
	; match(';')
	; in:	-
	; out:	-
	CALL L6F0F		; match(';'), if present
	RET Z			; return if ';' matched

L6F4C:	CALL L72E1		; no condition
	DB 1			; error 1: ';' expected

L6F50:	; matches a ';' and gives error 1 or 41 otherwise
	CALL L6F0F		; match(';'), if present
	RET Z			; return if ';' matched
	LD A,(L7B98)
	OR A
	JR Z,L6F4C		; generate error 1 if (L7B98)=0

	CALL L72E1		; no condition
	DB 29H			; error 41: unknown identifier or syntax error

L6F5E:	; matches a ',' and gives error 3 otherwise
	CALL L6F13		; match(','), if present
	RET Z			; return if ',' matched

	CALL L72E1		; no condition
	DB 3			; error 3: ',' expected

L6F66:	; matches a '(' and gives error 4 otherwise
	CALL L6F1B		; match('('), if present
	RET Z			; return if '(' matched

	CALL L72E1		; no condition
	DB 4			; error 4: '(' expected

L6F6E:	; matches a ')' and gives error 5 otherwise
	CALL L6F1F		; match(')'), if present
	RET Z			; return if ')' matched

	CALL L72E1		; no condition
	DB 5			; error 5: ')' expected

L6F76:	; matches a '=' and gives error 6 otherwise
	CALL L6F23		; match('='), if present
	RET Z			; return if '=' matched

	CALL L72E1		; no condition
	DB 6			; error 6: '=' expected

L6F7E:	; matches a ':=' and gives error 7 if this is not present
	; in:	-
	; out:	-
	CALL L6E76
	DW L7582 		; start of reserved word: :=
	RET Z			; return if ':=' parsed

	CALL L72E1		; no condition
	DB 7			; error 7: ':=' expected

L6F88:	; matches OF and gives error 15 if this is not present
	CALL L6E76
	DW L7560 		; start of reserved word: OF
	RET Z

	CALL L72E1		; no condition
	DB 0FH			; error 15: OF expected

L6F92:	; moves to next non-blank
	CALL L7124		; read next character from input

L6F95:	; moves IX to the next non-blank character
	; out:	Zero on succes
	XOR A
	LD (L7B98),A
	DEC A
	LD (L7BC0),A
	LD A,(IX+0)
	OR A			; end of text line buffer?
	JR Z,L6F92		; read next line and next non blank
	CP 20H			; start with space ?
	JR Z,L6F92
	CP 9			; start with TAB ?
	JR Z,L6F92
	CP '('                     ; first character of comment '(*   *)'
	JR Z,L6FB5
	CP '{'                     ; compiler option or comment
	JR Z,L6FBF

L6FB3:	LD (FileBufferLastPos),IX
	PUSH BC
	PUSH HL
	CALL BUILDID
	POP HL
	POP BC
	XOR A
	RET

L6FB5:	LD A,(IX+1)
	CP '*'
	JR NZ,L6FB3
	CALL L7124		; read next character from input
L6FBF:	PUSH BC
	LD B,(IX+0)
	LD A,(IX+1)
	CP '$'                     ; '{' followed by a '$'
	JR Z,L6FEB

L6FCA:	CALL L7124		; read next character from input

L6FCD:	LD A,B
	CP '*'
	LD A,(IX+0)
	JR NZ,L6FE4
	CP B
	JR NZ,L6FCA
	LD A,(IX+1)
	CP ')'
	JR NZ,L6FCA
	CALL L7124		; read next character from input
	JR L6FE8

L6FE4:	CP '}'
	JR NZ,L6FCA

L6FE8:	POP BC
	JR L6F92 		; move to next non blank

L6FEB:	; found: '{$'
	PUSH BC
	PUSH DE
	PUSH HL
	CALL L7124		; read '{' away
L6FF1:	CALL L7124		; read '$' away
	LD A,(IX+0)
	CALL L04A6		; upcase
	CP 'I'                     ; I  = include or i/o checking ?
				; I+ = I/O Error Handling on
	LD B,1			; bit 0
	JR Z,L704D

	CP 'R'                     ; R+ = Index Range Check on
	LD B,2			; bit 1
	JR Z,L704D

	CP 'A'                     ; A+ = Absolute code on
	LD B,4			; bit 2
	JR Z,L704D

	CP 'U'                     ; U+ = User Interrupt on
	LD B,8			; bit 3
	JR Z,L704D

	CP 'X'                     ; X+ = Array Optimization
	LD B,10H 		; bit 4
	JR Z,L704D

	CP 'V'                     ; V+ = Var-parameter Type Checking on
	LD B,20H 		; bit 5
	JR Z,L704D

	CP 'B'                     ; B+ = I/O Mode Selection
	LD B,40H 		; bit 6
	JR Z,L704D

	CP 'C'                     ; C+ = Control C and S interpretation on
	LD B,80H 		; bit 7
	JR Z,L704D

	CP 'W'                     ; W# = # levels of nesting With statements
	JR Z,L707A
	LD B,0

	CP 'K'                     ; n.a.
	JR Z,L704D
	CP 'D'                     ; n.a.
	JR Z,L704D
	CP 'F'                     ; n.a.
	JR Z,L708E
	CP 'G'                     ; n.a.
	JR Z,L708E
	CP 'P'                     ; n.a.
	JR Z,L708E

	CALL L72E1		; no condition
	DB 5DH			; error 93: Invalid compiler directive

L7048:	POP HL
	POP DE
	POP BC
	JR L6FCD

L704D:	CALL L7124		; read letter away
	LD A,(IX+0)
	LD C,0
	CP '+'
	JR Z,L7065
	DEC C			; C = 255
	CP '-'
	JR Z,L7065
	DEC B			; B = 1 (include command) ?

	CALL L72DA		; NonZero --> error
	DB 5DH			; error 93: Invalid compiler directive

	JR L709B 		; yes, {$i filename}

L7065:	LD HL,L7B9D
	LD A,(HL)
	XOR C			; XOR 0 = +, XOR 255 = -
	OR B			; set corresponding bit
	XOR C			; XOR 0 = +, XOR 255 = -
	LD (HL),A

L706D:	CALL L7124		; read next character from input
L7070:	LD A,(IX+0)
	CP 02CH
	JP Z,L6FF1
	JR L7048

L707A:	CALL L7124		; read letter 'W'
	LD A,(IX+0)
	CALL L7286		; carry reset if A = digit

	CALL L72C8		; carry set --> error
	DB 5DH			; error 93: Invalid compiler directive

	SUB '0'
         LD (WITHDEPTH),A           ; new WITHDEPTH
	JR L706D

L708E:	CALL L7124		; read next character from input
	LD A,(IX+0)
	CALL L7286		; carry reset if A = digit
	JR NC,L708E
	JR L7070

L709B:	; parse spaces and then the include file name
	CP ' '                     ; followed by a space ?
	JR NZ,L70A7		; no, end
	CALL L7124		; read next character from input
	LD A,(IX+0)
	JR L709B

L70A7:
;	 LD A,(L790E)
;	 OR A			 ; already reading from a secondary file ?
;				 ; (an include file)
;
	LD A,(FileLevel)
	CP MaxFileLevels
	CALL L72D4		; Zero --> error
	DB 60H			; error 96: No nesting of include files

	PUSH IX
	POP HL			; HL = compiler source text pointer

	PUSH HL

         LD DE,TEMPFileData
	LD A,'P'
	LD BC,'A'*256+'S'
	CALL ParseName

	POP DE			; DE = start of filename

;	 CALL L2D2A		 ; parse filename at DE with no wildcards and
;				 ; a default extension of '.PAS'

	PUSH HL			; save current compiler source text pointer
	EX DE,HL

         CALL GoNextFileLevel

	POP IX			; IX = new compiler source text pointer

;	 LD DE,L005C
;	 PUSH DE
;	 LD C,00FH
;	 CALL DOSIXIY		 ; open file
;	 POP HL
;	 INC A			 ; A was 0FFH if error occurred
;
;	 CALL L72D4		 ; Zero --> error
;	 DB 5AH			 ; error 90: File not found
;
;	 LD DE,L790F
;	 LD BC,FCB_LEN
;	 LDIR			 ; copy opened FCB at L005C to FCB at L790F
;
;	 LD A,(L7900)
;	 DEC A
;	 JR Z,L70E2		 ; jump if compiling to disk
;				 ; that is calculate a buffer to read more
;				 ; text at once for more efficiency
;
;	 LD HL,L7957		 ; start address buffer
;	 LD (L7BE4),HL
;	 LD HL,L79D7		 ; end address buffer
;	 LD A,1			 ; read from file = NonZero
;	 JR L7103
;
;L70E2:	 LD HL,(L7B73)		 ; bottom of variable table
;	 LD DE,(L7BE1)		 ; start address of free area
;	 LD (L7BE4),DE		 ; save start of text buffer
;	 OR A
;	 SBC HL,DE		 ; HL = total space that is still free
;
;	 SRL H			 ; divide by 2
;	 RR L
;;	  SRL H
;;	  RR L			  ; divide by 4
;
;	 LD A,H			 ; check if >= 256
;	 OR A
;
;	 CALL L72D4		 ; Zero --> error
;	 DB 63H			 ; error 99: Compiler overflow
;
;	 LD A,L			 ; round off to 128 bytes
;	 AND 128
;	 LD L,A
;	 PUSH HL
;	 ADD HL,HL
;	 LD A,H			 ; A = number of blocks of
;
;	 POP HL
;	 ADD HL,DE
;
;L7103:
;	 LD (L7BE6),HL
;	 LD (L7BE9),HL
;	 LD (L7BE8),A		 ; save number of records of 128 bytes
;	 LD (L790E),A		 ; set: read from file = non-zero
;
;	 LD HL,0
;	 LD (L7BEB),HL		 ; init current position in include file
;	 LD HL,0
;	 LD (INCLINE),HL		 ; restart line number

	CALL L718F		; print current line number

	LD A,(L7B9D)		; compiler directives
	LD (L7B9F),A		; save them
	LD A,(WITHDEPTH)
	LD (L7BC8),A		; save ?
	JP L7048

L7124:   ; -----------------------------------------------------------
	; ReadLine
	; -----------------------------------------------------------

	; read next character from input buffer
	LD A,(IX+0)
	INC IX
	OR A			; begins with a zero?
	RET NZ			; no, buffer is not empty,
				; quit with character

	; read a new line from the input buffer
	PUSH BC
	PUSH DE
	PUSH HL

	LD A,(L7BA2)
	OR A			; end of file found ?

	CALL L72DA		; NonZero --> error
	DB 5BH			; error 91: Unexpected end of source

;	 LD HL,(L7BD7)		 ; current text pointer
;	 LD (L7BD9),HL		 ; save start of line of text in memory

;	 LD HL,(L7BEB)		 ; HL = character position in include file
;	 LD (L7BED),HL		 ; save start of line in include file

	LD HL,L79D7
	PUSH HL
	POP IX			; set IX at start of text line buffer again

	LD B,07FH		; maximum number of characters is 127
L714A:	PUSH HL
	PUSH BC
	CALL L71F3		; read character from input
	POP BC
	POP HL
	CP 0DH			; carriage return?
	JR Z,L7175
	CP 1AH			; end of text?
	JR Z,L716A
	CP 9			; TAB?, exception on characters < 20H
	JR Z,L7161
	CP ' '                     ; < 20H, < space
	JR C,L714A		; yes, read next character
L7161:	DJNZ L7166

	; skip rest of line until return, end of text, tab or space
	INC B
	JR L714A

L7166:	LD (HL),A		; store character in buffer
	INC HL
	JR L714A 		; next character

L716A:	LD (L7BA2),A		; set to non-zero, end of file found = true

	CALL L717E		; increase and print line number
	CALL L718F		; print line number
	JR L7178

L7175:	CALL L717E		; increase and print line number

L7178:	LD (HL),0
	POP HL
	POP DE
	POP BC
	RET

L717E:	; increases and prints the current line number each time
	; line number and 3fh = 0
	; and gives an 'abort compilation' message if a key is pressed
	; in:	-
	; out:	-
	PUSH AF
	PUSH HL

	LD HL,(FileBufferLine)
	INC HL
	LD (FileBufferLine),HL

	LD HL,(TotalLines)
	INC HL
	LD (TotalLines),HL

	LD A,L
	AND 3FH			; line number mod 64 = 0?
	JR Z,L7191		; yes, print this number and skip PUSH AF,HL
	POP HL
	POP AF
	RET

PrintFileName:
         ; in:    DE = handle/FCB block

	INC DE
	EX DE,HL

PrintASCIIZUPCASED:
	LD A,(HL)
	OR A
	RET Z
	CALL UPCASE
	CALL L03C9
	INC HL
	JR PrintASCIIZUPCASED

PrintASCIIZ:
	LD A,(HL)
	OR A
	RET Z
	CALL L03C9
	INC HL
	JR PrintASCIIZ

L718F:	; prints current line number and tests keypressing during compilation
	; changes: -
	PUSH AF
	PUSH HL

L7191:	PUSH BC
	PUSH DE
	PUSH IX
	PUSH IY

IFDEF MSX
;	 LD HL,(0FC9EH)
;	 PUSH HL
ENDIF	; MSX

	LD A,13
	CALL L03C9		; print carriage return

;	 LD A,(L7BE3)
;	 CALL L04B4		 ; print update count
;
;	 LD A,' '
;	 CALL L03C9

	LD HL,(L7B73)
	LD DE,(COMPCUR)
	OR A
	SBC HL,DE
	CALL L2E5C		; print free memory in compiler
				; print in decimals, always 5 characters

;	 LD HL,(COMPCUR)		 ; current compiler address
;	 CALL L04AF		 ; print HL hexadecimal
;	 LD A,'-'
;	 CALL L03C9		 ; print '-'
;	 LD HL,(L7B73)		 ; bottom of variable table
;	 CALL L04AF

	LD A,' '
	CALL L03C9
	CALL L03C9

;	 LD HL,(MEMCUR)		 ; current address for new code
;	 CALL L04AF		 ; print
;	 LD A,'-'
;	 CALL L03C9
;	 LD HL,(L7908)		 ; highest possible address for generated code
;	 DEC H			 ; minus 512
;	 DEC H
;	 CALL L04AF
;
;	 LD A,' '
;	 CALL L03C9

	LD HL,(TotalLines)
	CALL L2E5C		; print total compiled pascal lines

	LD A,' '
	CALL L03C9

	LD HL,(FileBufferLine)
	CALL L2E5C		; print current line number in file

	LD A,' '
	CALL L03C9
	CALL L03C9

	LD A,(FileLevel)
	ADD A,'0'
	CP '0'
	JR NZ,L7192		; jump to print include level

	LD A,' '

L7192:	CALL L03C9		; print include level or space

	LD A,' '
	CALL L03C9		; space between level and filename

;	 LD A,(L790E)		 ; reading from include file?
;	 OR A
;	 JR Z,L71A6		 ; jump if reading from memory
;
;	 LD HL,(INCLINE)
;	 LD DE,L790F		 ; HL = address of include file FCB
;	 LD A,'I'                   ; print 'I' if reading from include file
;	 JR L71A8
;
;L71A6:

	LD DE,FileCurrentInfo
         CALL PrintFileName

;         LD A,(DOS2Present)
;         OR A
;	 PUSH AF
;	 CALL Z,L2DF8		 ; print FCB if DOS 1
;	 INC DE
;	 POP AF
;	 EX DE,HL
;	 CALL NZ,PrintASCIIZ	 ; print drive/path/filename if DOS 2

;	 LD DE,L451D		 ; work filename FCB
;	 JR Z,L71A61
;
;	 LD DE,L44F9		 ; main filename FCB
;
;L71A61:  LD A,' '                   ; otherwise print space
;
;L71A8:	 PUSH DE 		 ; save FCB address
;	 PUSH HL
;
;	 CALL L03C9
;	 LD A,' '
;	 CALL L03C9		 ; print space
;
;	 POP HL			 ; current line number
;	 CALL L2E5C		 ; print in decimals, always 5 characters
;	 CALL L2E61		 ; print line number
;	 LD A,' '
;	 CALL L03C9		 ; print space
;
;	 POP DE			 ; DE = FCB address
;	 CALL L2DF8		 ; print file name in DE

	LD A,27
	CALL L03C9
	LD A,'K'
	CALL L03C9		; print ESC K, delete until end of line

;	 LD B,8
;L71A81:  LD A,' '
;	 CALL L03C9
;	 DJNZ L71A81

	CALL CONSTPTR		; keypressed ?
	OR A
	JR Z,L71EA
	CALL L0200
	DB '   *** Abort compilation',0
	CALL L2D01		; print ' (Y/N)? '

	CALL L72DA		; NonZero --> error
	DB 0CAH			; staat niet in Herman's boek(je)

	LD B,20H
L71E1:	CALL L0200
	DB 8,' ',8,0               ; backspace, space, backspace
	DJNZ L71E1

L71EA:

IFDEF MSX
;	 POP HL
;	 LD (0FC9EH),HL
ENDIF	; MSX

	POP IY
	POP IX
	POP DE
L71EF:	POP BC
	POP HL
	POP AF
	RET

L71F3:   ; in:    -
	; out:	A = next character from text file, memory or include
	;	Z-flag set if A was 1AH, end of text
;	 LD HL,(FileBufferCount)
;	 DEC HL
;	 LD A,H
;	 OR L
;; ;!	   pushf
;	 DEC HL
;; ;!	   popf
;	 LD (FileBufferCount),HL
;
;	 CALL Z,FileReadBuffer	 ; read new buffer if count == 0

	LD HL,(FileBufferPos)
	LD A,(HL)
;	 CALL L03C9
	INC HL
	LD (FileBufferPos),HL

	PUSH AF

	LD HL,(FileBufferCount)
	DEC HL
	LD A,H
	OR L
	CALL Z,FileReadBuffer	; read new buffer if count = 0
	LD (FileBufferCount),HL

	POP AF

	CP 1AH			; end of file marker (^Z) ?
	RET NZ			; quit if it was not end of file
; 33e

         LD BC,FileCurrentInfo      ; 33e TODO, 568A
         CALL CloseFile
         CALL L72DA
         DB 85H

; 33e
	LD A,(FileLevel)
	OR A			; previous level = include file ?
	LD A,1AH
	RET Z			; return with end of file if end of all

	CALL GoPreviousFileLevel

	CALL L718F		; update display status

	JR L71F3 		; read next character from this level

;	 LD A,(L790E)
;	 OR A
;	 JR NZ,L7205		 ; jump if reading from include file
;
;L71F9:	 LD HL,(L7BD7)		 ; HL = current text pointer
;	 LD A,(HL)
;	 CP 1AH			 ; end of text?
;	 RET Z
;	 INC HL			 ; next position
;	 LD (L7BD7),HL
;	 RET
;
;L7205:	 ; read from text file
;
;	 LD HL,(L7BE9)		 ; current text pointer for include file
;	 LD DE,(L7BE6)		 ; end address of include file data
;	 OR A
;	 SBC HL,DE
;	 ADD HL,DE
;	 JR C,L7242		 ; jump if current pointer < end address
;				 ; still data present
;
;	 LD DE,(L7BE4)		 ; destination address, start address for
;				 ; include file data
;	 LD A,(L7BE8)		 ; calculate number of records
;	 LD B,A			 ; 128 bytes to read
;L721A:	 PUSH BC
;	 PUSH DE
;	 LD C,1AH
;	 CALL DOSIXIY		 ; set DMA address
;
;	 LD DE,L790F		 ; include FCB
;	 LD C,14H
;	 CALL DOSIXIY		 ; sequential read 128 bytes
;	 POP DE
;	 POP BC
;	 OR A
;	 JR NZ,L7237		 ; truncate at last DMA address
;
;	 LD HL,128
;	 ADD HL,DE		 ; destination address for next block
;	 EX DE,HL
;	 DJNZ L721A
;	 JR L723F
;
;L7237:	 ; error occurred during loading of text place a CTRL-Z (end-of-text)
;	 ; error means a partially read last block of 128 bytes so the end
;	 ; address of the include file text must be adjusted
;	 LD A,1AH
;	 LD (DE),A
;	 INC DE
;	 LD (L7BE6),DE		 ; set new end address of include file
;
;L723F:	 ; init current pointer
;	 LD HL,(L7BE4)		 ; HL = start address of loaded text
;
;L7242:	 LD A,(HL)
;	 INC HL			 ; point to next character
;	 LD (L7BE9),HL		 ; set new current text pointer
;	 CP 1AH
;	 JR NZ,L725D
;
;	 XOR A
;	 LD (L790E),A		 ; set: read from memory
;
;	 LD A,(L7B9F)		 ; saved directives
;	 LD (L7B9D),A		 ; restore compiler directives
;
;	 LD A,(L7BC8)
;	 LD (WITHDEPTH),A 	 ; restore
;
;	 JR L71F9
;
;L725D:	 LD HL,(L7BEB)
;	 INC HL			 ; increase current file position
;				 ; in include file
;	 LD (L7BEB),HL
;	 RET

;DOSIXIY: PUSH IX
;         PUSH IY
;         CALL MSXDOS
;         POP IY
;         POP IX
;         RET

L7271:	; in:	A = testing character
	; out:	Carry Flag Reset if A in ['A'..'Z','a'..'z','_']
	;	Carry Flag Set if A is not a letter and not an underscore
	;	A unchanged
	CP 'A'
	RET C
	CP 'Z'+1
	CCF
	RET NC
	CP '_'
	RET Z
	CP 'a'
	RET C
	CP 'z'+1
	CCF
	RET

L7282:	; in:	A = testing character
	; out:	Carry Flag Reset if see condition at L7271 and if
	;	A in ['0'..'9']
	;	Carry Flag Set if not an letter, underscore or decimal
	CALL L7271		; letter or underscore
	RET NC

L7286:	; in:	A = testing character
	; out:	Carry Flag Reset if A in ['0'..'9']
	;	Carry Flag Set otherwise
	CP '0'                     ; < '0' ?
	RET C
	CP '9'+1                   ; > '9' ?
	CCF
	RET

L728D:	; checks if the lower bound <= upper bound
	; in:	HL = <n>, upper bound
	;	DE = <m>, lower bound
	; out:	Carry = 1, if HL < DE
	LD A,H
	XOR D

	LD A,H
	JP M,L7298		; jump if one bound is negative
	CP D
	RET NZ
	LD A,L
	CP E
	RET

L7298:	RLA			; return Carry = 1, if upper bound < 0
	RET

L729A:	; in:	HL, DE
	; out:	HL = HL * DE
	LD B,H
	LD C,L
	LD HL,0			; sum = 0
	LD A,16

L72A1:	ADD HL,HL
	RET C			; quit if overflow

	EX DE,HL
	ADD HL,HL
	EX DE,HL
	JR NC,L72AA

	ADD HL,BC
	RET C
L72AA:	DEC A
	JR NZ,L72A1
	RET

;	 divide ?
;	 LD B,D
;	 LD C,E
;	 EX DE,HL
;	 XOR A
;	 LD H,A
;	 LD L,A
;	 LD A,011H
;L72B6:	 ADC HL,HL
;	 SBC HL,BC
;	 JR NC,L72BE
;	 ADD HL,BC
;	 SCF
;L72BE:	 CCF
;	 RL E
;	 RL D
;	 DEC A
;	 JR NZ,L72B6
;	 EX DE,HL
;	 RET

L72C8:	EX (SP),HL		; error if carry set
	INC HL
	EX (SP),HL
	RET NC
	JR L72DE

L72CE:	EX (SP),HL		; error if carry reset ; unused ???
	INC HL
	EX (SP),HL
	RET C
	JR L72DE

L72D4:	EX (SP),HL		; error if zero flag set
;!	pushf
	INC HL
;!	popf
	EX (SP),HL
	RET NZ
	JR L72DE

L72DA:	EX (SP),HL		; error if zero flag reset
;!	pushf
	INC HL
;!	popf
	EX (SP),HL
	RET Z
L72DE:	POP HL
	DEC HL
	PUSH HL

L72E1:	POP HL
	LD A,(HL)		; A = error code

L72E3:	CALL L718F		; make update of current line

	LD (L7901),A		; save error code
	OR A
	JR Z,L730C

	PUSH IX
	POP HL
	LD DE,L79D7		; DE = start of line buffer
	; NonCarry
	SBC HL,DE		; HL = zero-based column

;	 LD DE,(L7BED)		 ; text position in include file
;	 LD A,(L790E)
;	 OR A
;	 JR NZ,L7308		 ; jump if reading from include file
;
;	 LD DE,(L4544)		 ; HL = start of text area
;	 SBC HL,DE
;	 LD DE,(L7BD9)		 ; DE = start of line of text in memory
;
;L7308:	 ADD HL,DE
;	 LD (L790C),HL

L730C:	LD A,(L7900)
	DEC A
	JR NZ,L731A		; jump if searching

         LD BC,CodeFile
         CALL CloseFile

;         LD DE,L7933
;         LD C,010H
;         CALL DOSIXIY               ; close

L731A:	LD SP,(L7B71)
	RET

L731F:	DW 0BH
	DW LONGDEF		; definition of a longint
	DB 'T' + 80H
	DB 'NIGNOL'                ; LONGINT
	DB 0,3			; type

	DW 0BH			; length
	DW L74DA 		; definition of an integer
	DB 0D2H,'EGETNI'           ; INTEGER
	DB 0,3			; type

	DW 8			; length
	DW L74E2 		; definition of a char
	DB 0D2H,'AHC'              ; CHAR
	DB 0,3			; type

	DW 8			; length
	DW L74EA 		; definition of a real
	DB 0CCH,'AER'              ; REAL
	DB 0,3			; type

	DW 0BH			; length
	DW L74F2 		; definition of a boolean
	DB 0CEH,'AELOOB'           ; BOOLEAN
	DB 0,3			; type

;	 DW 8
;	 DW FILEDEF
;	 DB 0C5H,'LIF'              ; FILE
;	 DB 0,3			 ; type

	DW 8			; length
	DW L74FA 		; definition of text
	DB 0D4H,'XET'              ; TEXT
	DB 0,3			; type

	DW 8			; length
	DW L7502 		; definition of a byte
	DB 0C5H,'TYB'              ; BYTE
	DB 0,3			; type


	DW 9			; length
	DW 0001H 		; value of true
	DB 0BH			; type: boolean
	DB 0C5H,'URT'              ; TRUE
	DB 0,2			; constant

	DW 0AH			; length
	DW 0000H 		; value of false
	DB 0BH			; type: boolean
	DB 0C5H,'SLAF'             ; FALSE
	DB 0,2			; constant

	DW 0BH			; length
	DW 7FFFH 		; value of MAXINT
	DB 0AH			; type: integer
	DB 0D4H,'NIXAM'            ; MAXINT
	DB 0,2			; constant

	DW 11H			  ; length
	DW 0FFFFH
	DW 07FFFH
	DB 0EH			; type: longint
	DB 0D4H,'NIGNOLXAM'        ; MAXLONGINT
	DB 0,2			; constant

	DW 0BH			; length
	DB 82H,21H,0A2H,0DAH,0FH,49H ; REAL value of PI
	DB 9			; type: real
	DB 0C9H,'P'                ; PI
	DB 0,2			; constant

	DW 0DH			; length
	DW L74FA 		; definition of a text
	DW _OUTPUT		; LIB, value
	DB 0
	DB 0D4H,'UPTUO'            ; OUTPUT
	DB 0,4			; var absolute

	DW 0CH			; length
	DW L74FA 		; definition of a text
	DW _OUTPUT		; LIB
	DB 0
	DB 0D4H,'UPNI'             ; INPUT
	DB 0,4			; var absolute

	DW 0AH			; length
	DW L74FA 		; definition of a text
	DW _L00B8		; LIB
	DB 0
	DB 0CEH,'OC'               ; CON
	DB 0,4

	DW 0AH			; length
	DW L74FA 		; definition of a text
	DW _L00B8		; LIB
	DB 0
	DB 0CDH,'RT'               ; TRM
	DB 0,4

	DW 0AH			; length
	DW L74FA 		; definition of a text
	DW _L00BA		; LIB
	DB 0
	DB 0C4H,'BK'               ; KBD
	DB 0,4

	DW 0AH			; length
	DW L74FA 		; definition of a text
	DW _LST			; LIB
	DB 0
	DB 0D4H,'SL'               ; LST
	DB 0,4

	DW 0AH			; length
	DW L74FA 		; definition of a text
	DW _L00BE		; LIB
	DB 0
	DB 0D8H,'UA'               ; AUX
	DB 0,4

	DW 0AH			; length
	DW L74FA 		; definition of a text
	DW _L00C0		; LIB
	DB 0
	DB 0D2H,'SU'               ; USR
	DB 0,4

	DW 0DH			; length
	DW L7502 		; definition of a byte
	DW _BUFLEN		; LIB
	DB 0
	DB 0CEH,'ELFUB'            ; BUFLEN
	DB 0,4

	DW 0EH			; length
	DW L74DA 		; definition of an integer
	DW _HEAPPTR		; LIB
	DB 0
	DB 0D2H,'TPPAEH'           ; HEAPPTR
	DB 0,4

	DW 0FH			; length
	DW L74DA 		; definition of an integer
	DW _RECURPTR		; LIB
	DB 0
	DB 0D2H,'TPRUCER'          ; RECURPTR
	DB 0,4

	DW 0FH			; length
	DW L74DA 		; definition of an integer
	DW _CONSTPTR+1		; LIB
	DB 0
	DB 0D2H,'TPTSNOC'          ; CONSTPTR
	DB 0,4

	DW 0FH			; length
	DW L74DA 		; definition of an integer
	DW _CONINPTR+1		; LIB
	DB 0
	DB 0D2H,'TPNINOC'          ; CONINPTR
	DB 0,4

	DW 10H			; length
	DW L74DA 		; definition of an integer
	DW _CONOUTPTR+1		; LIB
	DB 0
	DB 0D2H,'TPTUONOC'         ; CONOUTPTR
	DB 0,4

	DW 10H			; length
	DW L74DA 		; definition of an integer
	DW _LSTOUTPTR+1		; LIB
	DB 0
	DB 0D2H,'TPTUOTSL'         ; LSTOUTPTR
	DB 0,4

	DW 0FH			; length
	DW L74DA 		; definition of an integer
	DW _AUXINPTR+1		; LIB
	DB 0
	DB 0D2H,'TPNIXUA'          ; AUXINPTR
	DB 0,4

	DW 10H			; length
	DW L74DA 		; definition of an integer
	DW _AUXOUTPTR+1		; LIB
	DB 0
	DB 0D2H,'TPTUOXUA'         ; AUXOUTPTR
	DB 0,4

	DW 0FH			; length
	DW L74DA 		; definition of an integer
	DW _USRINPTR+1		; LIB
	DB 0
	DB 0D2H,'TPNIRSU'          ; USRINPTR
	DB 0,4

	DW 10H			; length
	DW L74DA 		; definition of an integer
	DW _USROUTPTR+1		; LIB
	DB 0
	DB 0D2H,'TPTUORSU'         ; USROUTPTR
	DB 0,4

	DW 11H
	DW L74DA 		; definition of an integer
         DW _OverlayLoadPTR+1       ; LIB
	DB 0
	DB 0D2H,'TPYALREVO'        ; OVERLAYPTR
	DB 0,4

	DW 0FH			; length
	DW L74DA 		; definition of an integer
	DW _ERRORPTR+1		; LIB
	DB 0
	DB 0D2H,'TPRORRE'          ; ERRORPTR
	DB 0,4

	DW 0EH			; length
	DW L7502 		; definition of a byte
	DW 0FAF6H		; byte absolute $FAF6
	DB 0
	DB 'E'+80H,'GAPTCA'        ; ACTPAGE
	DB 0,4

	DW 0DH			; length
	DW L7502 		; definition of a byte
	DW 0FB02H		; byte absolute $FB02
	DB 0
	DB 'R'+80H,'POGOL'         ; LOGOPR
	DB 0,4

	DW 0DH			; length
	DW L7502 		; definition of a byte
	DW 0F3F2H		; byte absolute $F3F2
	DB 0
	DB 'T'+80H,'YBRTA'         ; ATRBYT
	DB 0,4

	DW 0DH			; length
	DW L7502 		; definition of a byte
	DW 0F3EBH		; byte absolute $F3EB
	DB 0
	DB 'R'+80H,'EDROB'         ; BORDER
	DB 0,4

	DW 14H			; length
	DW L74DA 		; definition of an integer
	DW _MEMMNVER		; LIB
	DB 0
	DB 'N'+80H,'OISREVNAMMEM'  ; MemManVersion
	DB 0,4

	DW 0EH			; length
	DW L74DA 		; definition of an integer
	DW _RUNGIOS+1
	DB 0
	DB 'S'+80H,'OIGNUR'        ; RunGIOS
	DB 0,4

	DW 12H			; length
	DW L74DA 		; definition of an integer
	DW _GIOSVER		; LIB
	DB 0
	DB 'N'+80H,'OISREVSOIG'    ; GIOSVersion
	DB 0,4

	DW 12H			; length
	DW L74F2 		; definition of a boolean
	DW _GIOSOK
	DB 0
	DB 'T'+80H,'NESERPSOIG'    ; GIOSPresent
	DB 0,4

	DW 14H			; length
	DW L74F2 		; definition of a boolean
	DW _MEMMAN
	DB 0
	DB 'T'+80H,'NESERPNAMMEM'  ; MemManPresent
	DB 0,4

	DW 0DH			; length
	DW L74F2 		; definition of a boolean
	DW _CBREAK		; LIB
	DB 0
	DB 0CBH,'AERBC'            ; CBREAK
	DB 0
L74D2:	DB 4			; start of variable table, going downwards

	; basic types
	;  5  = typed file
	;  6  = text
	;  7  = untyped file
	;  8  = string
	;  9  = real
	; 0AH = integer, byte --> differences in range and length only
	; 0BH = boolean
	; 0CH = char
	; 0EH = longint

	; definition of a longint
	DB 0
	DB 4			; length of a longint
	DB 0,0			; max value, ignored
	DB 0,0			; min value, ignored
	DB 0
LONGDEF: DB 0EH			; type = LONGINT

	; definition of an integer
	DB 0
	DB 2			; length of an integer
	DB 7FH,0FFH		; max value
	DB 80H,000H		; min value
	DB 0
L74DA:	DB 0AH			; type = integer

	; definition of a char
	DB 0
	DB 1			; length of a character
	DB 0,0FFH		; max value
	DB 0,0			; min value
	DB 0
L74E2:	DB 0CH			; type = char

	; definition of a real
	DB 0
	DB 6			; length of a real
	DB 0,0			; max value, ignored
	DB 0,0			; min value, ignored
	DB 0
L74EA:	DB 9			; type = real

	; definition of a boolean
	DB 0
	DB 1			; length of a boolean
	DB 0,1			; max value
	DB 0,0			; min value
	DB 0
L74F2:	DB 0BH			; type = boolean

	; definition of an untyped file
	DB 0
         DB DOS_LEN-128
	DB 0,0
	DB 0,0
	DB 0
FILEDEF: DB 7			; type = untyped file

	; definition of a text
	DB 0
         DB DOS_LEN                 ; length of a file info block, FIB
	DB 0,0			; max value, ignored
	DB 0,0			; min value, ignored
	DB 0
L74FA:	DB 6			; type = text

	; definition of a byte
	DB 0
	DB 1			; length of a byte
	DB 0,0FFH		; max value
	DB 0,0			; min value
	DB 0
L7502:	DB 0AH			; type = byte

	DB 0
	DB 9			; length
	DB 0,0
	DB 0,0
	DB 0
L750A:	DB 8			; type = string

	DB 0
	DB 0			; length
	DB 0,0
	DB 0,0
	DB 0
L7512:	DB 0			; type

L7513:	DB 0			; 0 indicates 0 bytes following the name
	DW L7529 		; start of reserved word list:
				; PROGRAM, END, FORWARD,
				; EXTERNAL, PACKED, ARRAY, FILE,
				; SET, RECORD, STRING, OF, ABSOLUTE,
				; THEN, ELSE, DO, UNTIL, NOT, NIL

	DB 1			; 1 byte following
	DW L7584 		; start of reserved word list:
				; LABEL, CONST, TYPE, VAR, BEGIN, OVERLAY
				; PROCEDURE, FUNCTION

	DB 2			; 2 bytes following
	DW L75BB 		; start of reserved word list:
				; BEGIN, IF, WHILE, REPEAT, FOR
				; CASE, GOTO, WITH, INLINE

	DB 1			; 1 byte following
	DW L75F5

	DB 1			; 1 byte following
	DW L7604

	DB 1			; 1 byte following
	DW L761D

	DB 1			; 1 byte following
	DW L7634

	DB 0FFH			; end of this table

L7529:	DC 'PROGRAM'
L7530:	DC 'END'
L7533:	DC 'FORWARD'
L753A:	DC 'EXTERNAL'
L7542:	DC 'PACKED'
L7548:	DC 'ARRAY'
L754D:	DC 'FILE'
L7551:	DC 'SET'
L7554:	DC 'RECORD'
L755A:	DC 'STRING'
L7560:	DC 'OF'
L7562:	DC 'ABSOLUTE'
L756A:	DC 'THEN'
L756E:	DC 'ELSE'
L7572:	DC 'DO'
L7574:	DC 'UNTIL'

L7579:	DC 'NOT'
L757C:	DC 'NIL'
	DB 0			; end of this table

L7580:	DC '..'

L7582:	DC ':='                    ; assign

L7584:	DC 'LABEL'                 ; 4x list
	DB 1
	DC 'CONST'
	DB 2
	DC 'TYPE'
	DB 3
L7595:	DC 'VAR'
	DB 4
	DC 'BEGIN'
	DB 8
L759F:	DC 'OVERLAY'
	DB 7
L75A7:	DC 'PROCEDURE'             ; 1x list
	DB 5
	DC 'FUNCTION'
	DB 6
	DB 0

L75BB:	DC 'BEGIN'                 ; 1x list
	DW L5377 		; statements ended by 'END'

	DC 'IF'
         DW L53EF

	DC 'WHILE'
	DW L5424

	DC 'REPEAT'
	DW L544C

	DC 'FOR'
	DW L546B

L75DA:	DC 'CASE'
	DW L5521

	DC 'GOTO'
	DW L5626
	DC 'WITH'
	DW L564E
L75EC:	DC 'INLINE'
	DW L5698
	DB 0			; end of this table

L75F5:	DC 'TO'                    ; 1x list
	DB 23H			; opcode: INC HL
	DC 'DOWNTO'
	DB 2BH			; opcode: DEC HL
	DB 0			; end of this table

L7600:	DC '*'                     ; 0, *
	DB 0
L7602:	DC '/'                     ; 1, /
	DB 1

L7604:	DC 'AND'                   ; 2, AND
	DB 2
	DC 'DIV'                   ; 3, DIV
	DB 3
	DC 'MOD'                   ; 4, MOD
	DB 4
	DC 'SHL'                   ; 5, SHL
	DB 5
	DC 'SHR'                   ; 6, SHR
	DB 6
	DB 0			; end of this table

L7619:	DC '+'                     ; 0, +
	DB 0
	DC '-'                     ; 1, -
	DB 1

L761D:	DC 'OR'                    ; 2, OR
	DB 2
	DC 'XOR'                   ; 3, XOR
	DB 3
	DB 0			; end of this table

L7625:	DB '=' + 80H               ;  0, =
	DB 0
L7627:	DB '<','>' + 80H           ;  1, <>
	DB 1
L762A:	DB '>','=' + 80H           ;  2, >=
	DB 2
L762D:	DB '<','=' + 80H           ;  3, <=
	DB 3
L7630:	DB '>' + 80H               ;  4, >
	DB 4
L7632:	DB '<' + 80H               ;  5, <
	DB 5
L7634:	DC 'IN'                    ; ffh, IN
	DB 0FFH
	DB 0			; end of list

L78FA:	DC 'MEM'
	DB 0,0,0

L7900:	DB 0			; 0 = compilation to memory
				; 1 = compilation to disk
				; 2 = searching for address while compiling

L7901:	DB 0			; contains error from abort compilation

L7902:	DW 0
L7904:	DW 0			; code start address
L7906:	DW 0			; code end address
L7908:	DW 0			; data start address
L790A:	DW 0			; data end address
L790C:	DB 0
	DB 0

;L790E:	 DB 0			 ; 0 = read text from memory
;				 ;NZ = read text from include file

;	 ; FCB
;L790F:	 DB 0,'DUMMY   FCB'
;	 DS 36			 ; used as FCB

CodeFile:
         DS 1 + 64

CodeFilePos:
         DW 0
         DW 0

CodeFileStart:
         DW 0
         DW 0

	; FCB
L7933:   DB 0                       ; used as FCB
L7934:	DS 8			; file name
L793C:	DB 0
L793D:	DB 0
	DB 0
	DS 21
L7954:   DW 0                       ; block count
	DB 0

L7961    EQU $+10


CodeFileBufferSize         EQU 1024

CodeFileBufferPos:         DW 0
CodeFileBuffer:            DS CodeFileBufferSize

CodeFileCreated:           DB 0     ; 0 = no code file created
                                    ;NZ = code file created


;L7957:   DS 128                     ; used as FCB or 128 byte text buffer
;
L79D7:	DS 128			; buffer, line buffer

L7A57:	DS 128

L7AD7:	DS 128

	; buffer of 13 bytes that is placed on the stack
L7B57:	DB 0
L7B58:	DB 0
L7B59:	DB 0
L7B5A:	DB 0
	DB 0
	; buffer of 8 bytes where id info is placed
L7B5C:	DB 0			; type
L7B5D:	DB 0
L7B5E:	DB 0
	DB 0
L7B60:	DB 0
	DB 0
L7B62:	DB 0			; length
	DB 0

L7B64:	DB 0
L7B65:	DB 0
	DB 0
	DB 0
	DB 0
L7B69:	DB 0
	DB 0
L7B6B:	DB 0
	DB 0
L7B6D:	DB 0
	DB 0
L7B6F:	DB 0
	DB 0
L7B71:	DB 0			; stack pointer saved at entering the compiler
L7B72:	DB 0
L7B73:	DB 0
L7B74:	DB 0
L7B75:	DB 0
	DB 0
L7B77:	DW 0
L7B79:	DW 0
L7B7B:	DB 0
	DB 0

L7B7D:	DB 0
	DB 0
L7B7F:	DB 0
	DB 0
L7B81:	DB 0
	DB 0
L7B83:	DB 0
	DB 0
L7B85:	DB 0
	DB 0
L7B87:	DB 0
L7B88:	DB 0
L7B89:	DB 0
	DB 0

L7B8B:	DW 0

L7B8D:	DB 0
	DB 0
L7B8F:	DB 0			; 0 = no VAR, 255 = VAR
L7B90:	DB 0			; 0 = not absolute, 255 = absolute
L7B91:	DB 0
L7B92:	DB 0
L7B93:	DB 0			; current type used by SCALARS
				; starts at 16
L7B94:	DB 0
L7B95:	DB 0

L7B96:	DB 0			; number of the overlay file
				; FILE.001
				; FILE.002
				; etc.

L7B97:   DB 0                       ; 0 = procedure, 1 = function
L7B98:	DB 0
L7B99:	DB 0
L7B9A:	DB 0
L7B9B:	DB 0
L7B9C:	DB 0

L7B9D:	DB 0			; compiler directive flags
				; bit 0: 1 = I/O Error Handling
				; bit 1: 1 = Index Range Check
				; bit 2: 1 = Absolute Code
				; bit 3: 1 = User Interrupt
				; bit 4: 1 = Array Optimization
				; bit 5: 1 = Var-parameter Type Checking
				; bit 6: 1 = I/O Mode Selection
				; bit 7: 1 = Control C and S interpretation
L7B9E:	DB 0			; saved compiler directives
L7B9F:	DB 0			; saved compiler directives

L7BA0:	DB 0
L7BA1:	DB 0			; 255 = minus sign
				;   0 = no sign
				;   1 = plus sign
L7BA2:	DB 0			; end of file found flag
L7BA3:	DB 0
L7BA4:	DB 0
	DB 0
L7BA6:	DB 0
L7BA7:	DB 0
	DB 0
L7BA9:	DW 0			; used to save current text pointer
				; because library call that uses IX
L7BAB:	DB 0
	DB 0
	DB 0
	DB 0
	DB 0

L7BB0:   DB 0                       ; length of largest part
	DB 0

L7BB2:	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
L7BBD:	DB 0
L7BBE:	DB 0
	DB 0
L7BC0:	DB 0

L7BC1:	DB 0
L7BC2:	DB 0
	DB 0
L7BC4:	DB 0
	DB 0
L7BC6:	DB 0
WITHDEPTH:DB 0			; initial value at 4
L7BC8:	DB 0
L7BC9:	DB 0
L7BCA:	DB 0
	DB 0

L7BCC:	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
	DB 0
L7BD5:	DB 0
	DB 0

;L7BD7:	 DW 0			 ; text pointer of text in memory
;L7BD9:	 DB 0
;	 DB 0

L7BDB:	DB 0			; bit 0 = '0': block already read
				; bit 1 = '0': block is not dirty

;L7BDC:   DB 0                       ; index to current block

L7BDD:	DW 0			; first block of current part

L7BDF:	DW 0			; start of free area
L7BE1:	DW 0			; start of free area + 1024
L7BE3:	DB 0

L7BF1:	DB 0
L7BF2:	DB 0
L7BF3:	DW 0

TableIndex2:
	; HL = tablename[index]
	; maximum of 128 indexes, 0 .. 127
	; in:	HL = table base address
	;	 A = table index, zero based
	; out:	HL = contents of index, word
	; changes: AF
	ADD A,A

	ADD A,L
	JR NC,TableIndex2_1
	INC H
TableIndex2_1:
	LD L,A

	LD A,(HL)
	INC HL
	LD H,(HL)
	LD L,A
	RET

CompareHL_DE:
	; compares HL with DE, by subtraction HL - DE
	; in:	HL, DE
	; out:	Carry, if HL < DE
	;	Zero, if HL == DE
	;	Zero and NonCarry, if HL >= DE
	; changes: AF
	LD A,H
	SUB D
	RET NZ
	LD A,L
	SUB E
	RET

MinimumHL_DE:
	; in:	HL, DE
	; out:	HL = minimum value, DE = maximum value
	CALL CompareHL_DE
	RET C			; quit if HL = minimum (HL < DE)

	EX DE,HL 		; swap values
	RET

FileInfoEntryAddress:
	; in:	A = include level, 0 .. FileLevels - 1
	; out:	HL = address of info within FileInfo table
	LD DE,FileInfoEntrySize

	LD HL,FileInfo

FileInfoEntryAddress1:
	OR A
	RET Z
	DEC A
	ADD HL,DE
	JR FileInfoEntryAddress1

GoNextFileLevel:
	; in:	HL = address of filename of text file

	; push default extension 'INC'
	LD A,'I'
	LD BC,'N'*256+'C'
	PUSH AF
	PUSH BC

	PUSH HL

	LD HL,(FileBufferCount)
	LD DE,FileLevelMinimum
	OR A
	SBC HL,DE		; HL = number of lost bytes
	JR Z,GoNextFileLevelNoLoss ; jump if Count = 0
	JR C,GoNextFileLevelNoLoss ; jump if Count < 1024

	LD B,H			; BC = number of lost bytes
	LD C,L

	PUSH BC
	LD BC,FileCurrentInfo
	CALL FilePos
	POP BC

	OR A
	SBC HL,BC		; subtract loss from low-word
	JR NC,GoNextFileLevel0

	DEC DE			; decrease high-word

GoNextFileLevel0:
	LD BC,FileCurrentInfo
	CALL FileSeek		; set file position back with the number
				; of lost bytes

	CALL L72DA		; NonZero --> error
	DB 84H			; error 132: error seeking file

GoNextFileLevelNoLoss:

	LD HL,(FileBufferCount)
	LD DE,FileLevelMinimum	; 1024 = minimum size used by a file
	CALL MinimumHL_DE
	; LD (FileBufferSize),HL	  ; set new size
	LD (FileBufferCount),HL	; set new count

	LD B,H			; BC = HL = count
	LD C,L
	LD HL,(FileBufferPos)
	LD DE,(FileBufferStart)
	PUSH DE

	LDIR			; move to start of buffer

	POP HL
	LD (FileBufferPos),HL	; buffer pos = buffer start

	PUSH DE			; save buffer start for next level

	LD A,(FileLevel)
	CALL FileInfoEntryAddress
	EX DE,HL 		; DE = address where to save current info
	LD HL,FileInfoEntryStart
	LD BC,FileInfoEntrySize
	LDIR			; save current entry in table

	LD HL,FileLevel
	INC (HL) 		; go to next include level

GoNextFileLevel1:
	POP HL
	LD (FileBufferStart),HL	; set new buffer start
	LD (FileBufferPos),HL	; set new buffer pos

	EX DE,HL
	LD HL,FileBufferEnd
	OR A
	SBC HL,DE		; HL = size for new buffer
	LD (FileBufferSize),HL

	LD DE,FileCurrentInfo

	POP HL			; DE = address of filename to parse

	POP BC
	POP AF
	CALL OpenFile

	CALL L72DA		; NonZero --> error
	DB 5AH			; error 90: File not found

	LD HL,0
	LD (FileBufferLine),HL	; start at line 0

	CALL FileReadBuffer

	LD A,H
	OR L
	RET NZ			; quit if some bytes read

GoPreviousFileLevel:
; 33e    LD BC,FileCurrentInfo
; 33e    CALL CloseFile             ; close the current file

; 33e    CALL L72DA                 ; NonZero --> error
; 33e    DB 85H                     ; error 133: error closing file

	LD HL,FileLevel
	DEC (HL) 		; decrease level
	LD A,(HL)
	CALL FileInfoEntryAddress
	LD DE,FileInfoEntryStart
	LD BC,FileInfoEntrySize
	LDIR			; restore to previous level
	RET

FileReadBuffer:
	; in:	-
	; out:	HL = bytes read from file

	LD HL,(FileBufferSize)
	LD DE,(FileBufferStart)
	LD (FileBufferPos),DE
	LD BC,FileCurrentInfo	; handle/FCB address
         CALL ReadFile
	LD (FileBufferCount),HL

	CALL L72DA		; NonZero --> error
	DB 83H			; error 131: error reading file

	LD A,H
	OR L
	RET NZ			; quit if something was read

	LD HL,(FileBufferStart)
	LD (HL),1AH		; place end of file marker (^Z)
	LD HL,1
	LD (FileBufferCount),HL	; count = 1

	RET

FileInit:
	; in:	HL = address of filename of text file

	; push default extension 'PAS'
	LD A,'P'
	LD BC,'A'*256+'S'
	PUSH AF
	PUSH BC

	PUSH HL
	XOR A
	LD (FileLevel),A
	LD HL,FileBuffer
	PUSH HL
	JP GoNextFileLevel1

TotalFileBufferSize EQU 8192        ; 8 KByte
FileLevelMinimum  EQU 1024
MaxFileLevels	EQU 4		; levels 0 - 3

TEMPFileData:     DS 1 + 64

TotalLines:	DW 0
FileLevel:	DB 0		; current include level, 0 default

FileInfoEntryStart:

FileCurrentInfo:  DS 1 + 64         ; DOS 1: 37 byte FCB
				; DOS 2: handle, 63 bytes name, '\0'
FileBufferLine:	DW 0		; current line number in text file
FileBufferLastPos:DW 0		; starting position of last read item
FileBufferStart:	DW FileBuffer	; start of current file buffer, address
FileBufferPos:	DW FileBuffer	; address of next byte to read
FileBufferCount:	DW 0		; bytes left in current buffer
FileBufferSize:	DW TotalFileBufferSize ; size in bytes of current buffer

FileInfoEntrySize EQU $-FileInfoEntryStart ; size never greater than 128 !!

FileInfo:
	DS FileInfoEntrySize * MaxFileLevels

FileBuffer:
	DS TotalFileBufferSize
FileBufferEnd:

;         DB 'EXTRA'
; L90FC:   DW 0                       ; 33e TODO, L90FC

         END
