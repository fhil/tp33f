; ^QW: find current word
; ^QS: find current word without first letter (for names that start with an
;      underscore)

; - define the symbol 'MSX' to compile the msx compiler
;   otherwise the PC version will be generated

; - define the symbol 'USELIB' to compile all library routines
; - define the symbol 'NEWEXT' to use the new external routine

;NEWEXT:
FASTREAL:

IFNDEF MAKEPC
MSX:
ENDIF

IFDEF MSX
MSXDOS	EQU 5
USELIB:
ENDIF

	INCLUDE stdio.inc

         INCLUDE libdefs.inc

         INCLUDE libconst.inc

         ORG 100H

L0100:

IFDEF MAKEPC
         LD (L0006),SP
;!       jmp word ptr L0101

ELSE

         DB 0C3H

ENDIF

L0101:   DW L20E2

MagicNumber:                        ; must be at 103H
         DB 12H,34H,56H,78H
TurboPascalVersion:
         DB 03H,03H,'a',04H         ; must be at 107H

         DW L016B                   ; must be at 10BH
         DW 0                       ; reserved 10DH
         DW 0                       ; reserved 10FH
         DW 0                       ; reserved 111H
         DW 0
         DW 0
         DW 0
         DW 0
         DW 0
         DW 0
         DW 0
         DW 0
         DW 0

;PREFIX:  DB 'TURBO '                ; for 'TURBO.MSG' or 'TURBO.OVR'

;L0000:   DB 0
;L0001:   DW 0

;L0004:   DB 0                        ; current drive ?

;L0005:   DB 0

IFDEF MAKEPC
L0006:   DW 0
ENDIF    ; MAKEPC

;L0038:   DB 0
;L0039:   DW 0

L005C:	DB 0			; start of FCB

L005D:	DS 8			; name

L0065:	DB 0			; FCB extension, first letter
L0066:	DS 2			; second and third letter

L0068:	DB 0			; 0CH
	DB 0			; 0DH
	DB 0			; 0EH
	DB 0			; 0FH
L006C:	DS 4			; 10H-13H
L0070:	DS 4			; 14H-17H
L0074:	DS 8			; 18H-1FH
L007C:	DB 0			; 20H
L007D:	DW 0			; 21H-22H
	DW 0			; 23H-24H

IFDEF MSX
L0080    EQU 0080H
ELSE
; L0080    EQU $-1
ENDIF

CONSTPTR:; FUNCTION KeyPressed: BOOLEAN;
IFDEF MSX
	DB 0C3H
ELSE
;!	jmp word ptr CONSTPTR_1
ENDIF
CONSTPTR_1:DW L0316

CONINPTR:			; console input routine
IFDEF MSX
	DB 0C3H
ELSE
;!	jmp word ptr CONINPTR_1
ENDIF
CONINPTR_1:DW L0320

CONOUTPTR:                          ; console output routine
IFDEF MSX
	DB 0C3H
ELSE
;!	jmp word ptr CON1OUTPTR
ENDIF
CON1OUTPTR:DW L0339

LSTOUTPTR:
	JP L032F
	;DS 3			; jump opcode at 00A9H
				; LSTOUTPTR at absolute 00AAH
AUXOUTPTR:
	JP L0334
	;DS 3			; jump opcode at 00ACH
				; AUXOUTPTR at absolute 00ADH
AUXINPTR:
	JP L032A
	;DS 3			; jump opcode at 00AFH
				; AUXINPTR  at absolute 00B0H
USROUTPTR:
	JP L0339
	;DS 3			; jump opcode at 00B2H
				; USROUTPTR at absolute 00B3H
USRINPTR:
	JP L0320
	;DS 3			; jump opcode at 00B5H
				; USRINPTR  at absolute 00B6H

L00B8:	DW 0			; CON, TRM, 00B8
L00BA:	DW 0			; KBD,	   00BA
LST:	DW 0			; LST,	   00BC, absolute 00BCH
L00BE:	DW 0			; AUX,	   00BE
L00C0:	DW 0			; USR,	   00C0
OUTPUT:	DW 0			; OUTPUT,   00C2, absolute 00C2H

BUFLEN:	DB 0;			; BUFLEN    at absolute 00D1H

ERRORPTR:
IFDEF MSX
	DB 0C3H
ELSE
;!	jmp word ptr ERRORPTR_1
ENDIF
ERRORPTR_1:DW 0

CBREAK:DW 0			; CBREAK    at absolute 00DDH
HEAPPTR:DW 0			; HEAPPTR   at absolute 00C4H
RECURPTR:DW 0			; RECURPTR  at absolute 00C6H

L00C8:	DW 0			; 32 bit Seed number
         DB 0

L00CB:	DB 0			; waarde van R register

L00CC:	DW 0
L00CE:	DW 0

L00D0:	DB 0			 ; IORESULT value
L00D2:	DW 0
L00D4:	DW 0
L00D6:	DW 0
L00D8:	DB 0
L00DC:	DB 0
L00DE:	DW 0
L00E0:	DB 0

L00E2:	DW 0			; current device pointer

L00E4:	DW 0
L00E6:	DW 0
L00E8:	DW 0
L00E9	EQU L00E8+1
L00EA:	DW 0
L00EC:	DB 0
L00ED:	DW 0			; old device pointer

	; tabel van 16 bytes, soort buffer
L00F0:	DW 0
L00F2:	DW 0
L00F4:	DW 0			; MemAvail
L00F6:	DW 0			; MaxAvail
L00F8:	DW 0
	DS 8

;	 DW 0ABCDH		 ; Magic
;	 DB 0CDH,0ABH
;	 DB 'Copyright (C) 1994 MSX Computer Club Enschede',0

L0124:	DW 4			; Operating frequency of CPU (1-12 MHz)

L0126:	DB 0A1H,'B',0

	DS 42			; patch area of 42 bytes

L0153:	; TermTypStr
	DB 3,'msx'                 ; STRING
	DS L0153+21-$

L0168:	DB 80			; ScreenWidth
L0169:	DB 24			; ScreenHeight

	DB 0			; Why ?

L016B:	; InitialStr, 16 bytes
	DB 3,1BH,'x5',1DH
	DS L016B+16-$		; fill rest

L017B:	; ResetStr, 16 bytes
	DS L017B+16-$		; fill rest

L018B:	; CursorStr, 16 bytes
	DB 4,1BH,'Y',0,0
	DS L018B+16-$		; fill rest

L019B:	DB 1			; 0 = ASCII, 1 = Binary Address
L019C:	DB 32			; ColumnOffset
L019D:	DB 32			; LineOffset
L019E:	DB 4			; XPosition in CursorStr
L019F:	DB 3			; YPosition in CursorStr
L01A0:	DW 0			; Delay after cursor address (0 - 255 ms)

L01A2:	; ClearScrStr, 6 bytes
	DB 1,0CH 		; length = 1
	DS L01A2+6-$		; fill rest

L01A8:	; HomeStr, 6 bytes
	DB 0			; length = 0
	DS L01A8+6-$

L01AE:	; InsLineStr, 6 bytes
	DB 2,1BH,'L'
	DS L01AE+6-$

L01B4:	; DelLineStr, 6 bytes
	DB 2,1BH,'M'
	DS L01B4+6-$

L01BA:	DW 0			; DelayLine

L01BC:	; EraToEolStr
	DB 2,1BH,'K'
	DS L01BC+6-$

L01C2:	; HLStartStr		; Start of highlighting
	DB 0
	DS L01C2+6-$

L01C8:	; HLEndStr		; End of highlighting
	DB 0
	DS L01C8+6-$

L01CE:	DW 0			; DelayHL, delay after
				; EraToEol and HighLight

L01D0:   LD A,(HL)
	OR A
	SCF
	RET Z
L01D4:	INC HL
	PUSH AF
	PUSH HL
	LD A,(HL)
	CALL L01E8
	POP HL
	POP AF
	DEC A
	RET Z
	JR L01D4

L01E1:	CALL L0200		; print CR,LF
	DB 0DH,0AH,0
	RET

L01E8:   LD L,A
	PUSH HL
	CALL CONOUTPTR
	RET

L01EE:	; print character A with/without highlighting
	CP 080H
	CALL C,L026B		; LowVideo
	CALL NC,L0284		; HighVideo
	AND 07FH
	JR L01E8

L01FA:	; print ASCIIZ-string with highlighting
	PUSH HL
	LD HL,L01EE
	JR L0204

L0200:   ; print ASCIIZ-string without highlighting
	PUSH HL
	LD HL,L01E8
L0204:   LD (L0213),HL
	POP HL
	EX (SP),HL
L0209:	PUSH AF
	PUSH BC
L020B:	PUSH DE

L020C:   LD A,(HL)
	INC HL
	OR A
	JR Z,L0218
	PUSH HL
L0212:	CALL J0213		; call address, address is change able
	POP HL
	JR L020C

L0218:	POP DE
	POP BC
	POP AF
	EX (SP),HL		; continue after string data
	RET

J0213:
IFDEF MSX
	DB 0C3H
ELSE
;!	jmp word ptr L0213
ENDIF
L0213:	DW L04D2

L021D:	; in:	HL = time to wait
	LD A,L			; delay
	OR H
	RET Z
	LD A,(L0124)		; A = frequency
	ADD A,A
	ADD A,A
	ADD A,A
L0226:	EX (SP),HL
	EX (SP),HL
	EX (SP),HL
	EX (SP),HL
	PUSH BC
	LD BC,1234
	POP BC
	DEC A
	JR NZ,L0226
	DEC HL
	JR L021D 		; Delay

L0235:	CALL L01D0
	RET C
	LD HL,(L01CE)		; HL = DelayHL, delay highlighting
	JR L021D 		; Delay

L023E:	; PROCEDURE ClrSCr;
	PUSH AF
	PUSH BC
	PUSH DE
	PUSH HL

	LD HL,L01A8		; HL = HomeStr
	CALL L0235
	LD HL,L01A2		; HL = ClearScrStr

L024B:	CALL L01D0
	LD HL,(L01BA)		; HL = DelayLine
	CALL NC,L021D		; Delay

	POP HL
	POP DE
	POP BC
	POP AF
	RET

L0259:	; PROCEDURE DelLine
	PUSH AF
	PUSH BC
	PUSH DE
	PUSH HL
	LD HL,L01B4		; DelLineStr
	JR L024B

L0262:	; PROCEDURE InsLine;
	PUSH AF
	PUSH BC
	PUSH DE
	PUSH HL
	LD HL,L01AE		; InsLineStr
	JR L024B

L026B:	; PROCEDURE LowVideo;
	PUSH AF
	LD A,(L00E0)
	OR A
	JR Z,L0282

	PUSH BC
	PUSH DE
	PUSH HL
	XOR A
	LD (L00E0),A
	LD HL,L01C8		; HLEndStr

L027C:	CALL L0235

	POP HL
	POP DE
	POP BC
L0282:	POP AF
	RET

L0284:	; PROCEDURE NormVideo;
	PUSH AF
	LD A,(L00E0)
	CP 0FFH
	JR Z,L0282

	PUSH BC
	PUSH DE
	PUSH HL
	LD A,0FFH
	LD (L00E0),A
	LD HL,L01C2		; HLStartStr
	JR L027C

L0299:	; PROCEDURE ClrEol;
	PUSH AF
	PUSH BC
	PUSH DE
	PUSH HL
	LD HL,L01BC		; EraToEolStr
	JR L027C

L02A2:	; in:	L = X, 0..79
	;	H = Y, 0..23
	PUSH AF
	PUSH BC
	PUSH DE
	PUSH HL
	PUSH HL
	LD HL,L018B
	LD DE,L00F0
	LD BC,0010H
	LDIR
	POP DE
	LD A,(L019E)
	LD C,A
	LD A,(L019C)
	ADD A,D
	PUSH DE
	CALL L02DC
	POP DE
	LD A,(L019F)
	LD C,A
	LD A,(L019D)
	ADD A,E
	CALL L02DC
	LD HL,L00F0
	CALL L01D0

	LD HL,(L01A0)		; DelayCursor
	CALL L021D		; Delay
	POP HL
	POP DE
	POP BC
	POP AF
	RET

L02DC:	LD HL,L00F0
	LD B,0
	ADD HL,BC
	EX DE,HL
	LD HL,L019B
	INC (HL)
	DEC (HL)
	JR Z,L02EC
	LD (DE),A
	RET

L02EC:	DEC DE
	DEC DE
	LD HL,TAB110100+3
	LD B,3

L02F3:	DEC HL

	LD C,'0'-1
L02F6:	INC C
	SUB (HL)
	JR NC,L02F6

	ADD A,(HL)
	PUSH AF
	LD A,C
	CP '0'
L02FF:	JR Z,L0302
	LD (DE),A
L0302:	INC DE
	POP AF
	DJNZ L02F3
	RET

TAB110100:
	DB 1,10,100

IFDEF MSX
L030A:	; PROCEDURE CrtInit;
	LD HL,L016B		; InitialStr
	JP L0235
ENDIF

L0310:	; PROCEDURE CrtExit;
	LD HL,L017B		; ResetStr
	JP L0235

L0316:   ; tests if there is a character in the input buffer
	; and places it in a temporary buffer to read it the next time
	; in:	-
	; out:	HL = false = 0, if no character present
	;	HL = true = 1, if a character was present
IFDEF MSX
         ; MSX version, FAST
         LD HL,(0F3FAH)
         LD A,(0F3F8H)
         SUB L
         LD A,1                     ; assume there are characters present
         JR NZ,L0316_OK             ; jump if characters present

         DEC A                      ; FALSE if not
L0316_OK:

ELSE
         ; PC version, slow CPM call
         LD DE,3
         CALL L035F
	AND 1
ENDIF
	JR L0326

L0320:   ; in:    -
	; out:	HL = character read from keyboard
	;	H = always zero
IFNDEF MSX
         LD DE,2*3                  ; Console Input
ELSE
         ; FAST character input
         PUSH IX
         PUSH IY
         LD A,C
         DW 80F7H
         DW 009FH
         POP IY
         POP IX
         LD L,A
         LD H,0
         RET
ENDIF

L0323:   CALL L035F

L0326:   LD L,A
	LD H,0
	RET

L032A:	LD DE,6*3		; Reader Input
	JR L0323

L032F:	LD DE,4*3		; List Output
	JR L033C

L0334:	LD DE,5*3		; Puncher Output
	JR L033C

L0339:
IFNDEF MSX
         LD DE,3*3                  ; Console Output
ENDIF

L033C:	POP HL			; pop return address
	POP BC			; C = character to print
	PUSH HL			; push return address

         LD A,(CBREAK)
	OR A
         JR Z,L035D_1               ; jump if no break allowed

         PUSH DE
	PUSH BC
	CALL CONSTPTR
	LD A,H
	OR L
	JR Z,L035D		; jump if no character present

         CALL L03E1                 ; A = character from console
	CP 013H
	JR NZ,L035D

         CALL L03E1                 ; A = character from console
	CP 3
         JP Z,L20D4                 ; jump to Program Abort if ^C pressed

L035D:	POP BC
	POP DE

L035D_1:
IFDEF MSX
         ; FAST character output
         PUSH IX
         PUSH IY
         LD A,C
         DW 80F7H
         DW 00A2H
         POP IY
         POP IX
         RET
ENDIF

L035F:
IFDEF MSX
	LD HL,(0001H)
	ADD HL,DE
	JP (HL)
ELSE
	JP DOSIO 		; ----
ENDIF

L0364:   ; InitCharIO
	LD (L00D2),HL		; LIB
	LD A,B
	LD (CBREAK),A
;	 LD A,C
;	 OR A
;	 JR Z,L037A

L037A:
IFDEF MSX
	LD HL,L03A5
	LD DE,CONSTPTR
	LD BC,L03A5_L
	LDIR
ENDIF

	LD HL,L03BD
	LD DE,L00B8
	LD BC,000CH
	LDIR			; flag bits of I/O routines

	XOR A
	LD L,A
	LD H,A
	LD (L00D0),A		; reset IORESULT value
	LD (L00D4),HL
	LD (L00D6),HL
	LD A,07EH
	LD (BUFLEN),A
	LD (L00E0),A

         JP InitFileIO              ; Set DOS2Present variable

L03A5:   JP L0316                   ; keypressed
         JP L0320                   ; read character from console
         JP L0339                   ; write character to console
	JP L032F
	JP L0334
	JP L032A
         JP L0339                   ; write character to console
         JP L0320                   ; read character from console
L03A5_L EQU $ - L03A5

L03BD:   DW 0C1H                    ; Con / Trm       , read and write
         DW 82H                     ; Kbd             , read
         DW 43H                     ; Lst             , write
         DW 0C4H                    ; Aux             , read and write
         DW 0C5H                    ; Usr             , read and write
         DW 0C1H                    ; Input / Output  , read and write

L03C9:	; in:	A = character to print
	; out:	-
	; changes: -
	PUSH BC
	PUSH DE
	PUSH HL
	PUSH IX
	PUSH IY
	PUSH AF
	LD L,A
	LD H,0
	PUSH HL
	CALL CONOUTPTR
	POP AF

L03D9:   POP IY
	POP IX
	POP HL
	POP DE
	POP BC
	RET

L03E1:	; in:	-
	; out:	A = character read from console
	; changes: F
	PUSH BC
	PUSH DE
	PUSH HL
	PUSH IX
	PUSH IY
L03E8:	CALL CONINPTR
	LD A,L
	JR L03D9 		; same end as 'print character'

	; -----------------------------------------------------------

L03EE:	; parses a filename at DE with wildcards to FCB at L005C
	LD C,0FFH		; with wildcards
	JR L03FE

L03F2:	; parses a string whose address is in L00D2 to FCB at L005C
	; with no wildcards, skips leading spaces in string
	LD C,0			; don't allow wildcards
	LD DE,(L00D2)
L03F8:	INC DE
	LD A,(DE)
	CP ' '
	JR Z,L03F8		; skip leading spaces

L03FE:	LD HL,L0065		; HL = start address for extension
	LD B,3			; 3 characters
	CALL L047B

L0406:	; parses a complete filename at address in DE to FCB at L005C
	; in:	DE = source address for filename
	;	 C = 0, no wildcards
	LD A,(DE)
	CALL L04A6		; upcase
	CP 'A'
	JR C,L0420		; jump if < 'A'
	CP 'Q'
	JR NC,L0420		; jump if >= 'Q'
	LD B,A			; save first character in B
	INC DE
	LD A,(DE)
	CP ':'                     ; next character is ':' ?
	JR NZ,L041F		; no, don't start with a drive specification
	LD A,B			; A = drive letter
	SUB 040H 		; 1 = 'A:', 2 = 'B:' etc..
	INC DE			; to character after ':'
	JR L0421

L041F:	DEC DE			; back to first character

L0420:	XOR A			; default drive
L0421:	LD HL,L005C
	LD (HL),A		; set drive specification
	INC HL

	INC C			; C = 0 if no wildcards are allowed
	DEC C
	JR Z,L0443		; jump to skip wildcards

	LD A,(DE)
	CALL L0482
	JR NZ,L0443
	CP '?'
	JR Z,L0443
	CP '*'
	JR Z,L0443
	CP '.'
	JR Z,L0443
	LD B,11
	CALL L0477
	JR L0453

L0443:	LD B,8
	CALL L045E
	LD A,(DE)
	CP '.'                     ; followed by an extension ?
	JR NZ,L0453		; no, skip parsing of an extension

	INC DE			; to first character of extension
	LD B,3
	CALL L045E		; parse extension

L0453:	LD HL,L005C+12		; clear rest of the FCB
         LD B,FCB_LEN -11           ; 33e -12
L0458:	LD (HL),0
	INC HL
	DJNZ L0458
	RET

L045E:	LD A,(DE)
	INC C			; skip wildcard check if not allowed
	DEC C
	JR Z,L046B

	CP '?'
	JR Z,L0470		; fill as if normal letter
	CP '*'
	JR Z,L0476		; fill rest with '?'-wildcards

L046B:	CALL L0482
	JR Z,L047B		; jump if abnormal character found, end of
				; string found, fill rest with spaces

L0470:	LD (HL),A
	INC HL
	INC DE
	DJNZ L045E
	RET

L0476:	INC DE

L0477:	; fill rest with '?'-wildcards
	LD A,'?'
	JR L047D

L047B:	; fill rest with spaces
	LD A,' '

L047D:	LD (HL),A
	INC HL
	DJNZ L047D
	RET

L0482:	CALL L04A6		; upcase A
	CP ' '                     ; < ' ' ?
	JR C,L0496

	PUSH HL
	PUSH BC
	LD HL,L0498		; HL = address of data to scan
	LD BC,L04911		; BC = length of data to scan
	CPIR
	POP BC
	POP HL
	RET			; return Z-flag = '1' if A found in data

L0496:	CP A			; return with Z-flag corresponding to A
	RET

L0498:	; SepTable
	DB ' .,;:=?*[]<>{}'
L04911	EQU $-L0498

	; -----------------------------------------------------------

L04A6:	; in:	A = character
	; out:	A = upcased, if A >= 'a' and A <= 'z'
	CP 'a'
	RET C
	CP 'z'+1
	RET NC
	SUB 'a'-'A'
	RET

L04AF:	LD A,H
	CALL L04B4
	LD A,L

L04B4:	PUSH AF
	RRA
	RRA
	RRA
	RRA
	CALL L04BD
	POP AF
L04BD:	AND 00FH
	CP 10
	JR C,L04BE
	ADD A,7
L04BE:	ADD A,'0'
	JP L03C9 		; print digit

L04C8:   ; converts integer HL to an unsigned byte A
	; in:	HL
	; out:	A = 0 and carry set, if HL < 0
	;	A = L and carry reset, if HL < 256
	;	otherwise A = 255
	XOR A
	SCF			; assume HL is negative
	BIT 7,H
	RET NZ			; return with carry set if negative

         LD A,H
	OR A
	LD A,L
         RET Z                      ; return if HL < 256

L04D2:   LD A,(L04D2_D)             ; code area
	RET

L04D2_D: DB 0                       ; data area


L0581:   ; LIB
	; push new empty SET on stack
	; in:	-
	; out:	a new SET pushed on to the stack
	POP IX			; LIB
	LD HL,-32
	ADD HL,SP
	LD SP,HL 		; reserve 32 bytes

	; clear the SET with zeroes
	LD B,020H
	XOR A
L058B:	LD (HL),A
	INC HL
	DJNZ L058B

	JP (IX)

L0591:	; add element HL to SET at stack
	;
	POP IX
	LD B,L			; B = element to add
	CALL L05BA

L0597:	OR (HL)
	LD (HL),A

L0599:	JP (IX)

L059B:   POP IX                     ; LIB
	POP DE
	LD A,L
	SUB E
	JR C,L0599
	INC A
	LD C,A
	LD B,E
	CALL L05BA
	LD E,A
	LD B,C
	XOR A
L05AB:	OR E
	SLA E
	JR NC,L05B6
	OR (HL)
	LD (HL),A
	INC HL
	XOR A
	LD E,1
L05B6:	DJNZ L05AB
	JR L0597

L05BA:	LD A,B
	AND 0F8H 		; calculate byte offset
	RRCA
	RRCA
	RRCA
	ADD A,2			; add 2 for return address
	LD L,A
	LD H,0
	ADD HL,SP
	LD A,B
	AND 7
	INC A
	LD B,A
	XOR A
	SCF
L05CD:	RLA
	DJNZ L05CD
	RET


L0612:	; pop pushed set to the address in HL
	; in:	HL = destination address of SET
	;	C = bytes to copy from SET
	;	B = offset within SET
	POP IX			; LIB
	EX DE,HL
	LD L,B			; HL = offset within SET
	LD H,0
	LD B,H			; BC = length
	ADD HL,SP
	LDIR			; copy set to given address

	LD HL,0020H

L061F:   ADD HL,SP
	LD SP,HL
	JP (IX)

L06F5:	; X * Y : INTEGER
	; in:	DE = X
	;	HL = Y
	; out:	HL = X * Y
	LD C,E			; BC = X
	LD B,D
	EX DE,HL
	LD HL,0
	LD A,D			; D non zero?
	OR A
	LD A,16			; assume 16 bits
	JR NZ,L0704		; yes, continue
	LD D,E			; no, shift E to D
	LD A,8			; shift rest over 8 bits
L0704:	ADD HL,HL
	EX DE,HL
	ADD HL,HL
	EX DE,HL
	JR NC,L070B
	ADD HL,BC
L070B:	DEC A
	JR NZ,L0704
	RET

L0780:   ; Abs X : INTEGER
	; in:	HL = X
	; out:	HL = -X, if X < 0
	;	HL = X, if X >= 0
	BIT 7,H			; LIB, HL = negative ?
	RET Z			; return if positive

L0783:	; X = -X : INTEGER
	; in:	HL = X
	; out:	HL = -X
	LD A,H			; negate HL
	CPL
	LD H,A
	LD A,L
	CPL
	LD L,A
	INC HL
	RET

L07C6:   ; unsigned Integer to ASCII
	; in:	HL = unsigned INTEGER
	;	IX = destination address of ASCII result
	; out:	IX = address after ASCII result
	LD B,0			; Flag = 0, no leading zero
	LD DE,10000
	CALL L07E2
	LD DE,1000
	CALL L07E2
	LD DE,100
	CALL L07E2
	LD E,10
	CALL L07E2
	LD A,L
	JR L07EF

L07E2:	XOR A
L07E3:	INC A
	SBC HL,DE
	JR NC,L07E3
	ADD HL,DE
	INC B			; increase, assume NonZero
	DEC A
	JR NZ,L07EF		; jump if digit > 0

	DEC B			; Flag = 0 ?, suppress leading zero's
	RET Z

L07EF:	ADD A,'0'
	LD (IX+0),A
	INC IX
	RET

L07F7:   ; ASCII hexadecimal or decimal to Integer
	; converts ascii hexadecimal or decimal number at IX to
	; a value in HL
	; in:	IX = address of ascii digit sequence
	; out:	carry set if value out of range
	;	carry reset, HL = value
	LD A,(IX+0)
	SUB '$'
	LD C,A
	LD HL,0
	JR NZ,L0804		; NonZero, do not skip '$' character
L0802:	INC IX

L0804:	LD A,(IX+0)
	CALL L04A6		; upcase
	SUB '0'                    ; < '0' ?
	JR C,L0837		; yes, quit
	CP 10			; < 10 ?
	JR C,L0820		; yes, continue

	; A..F ?
	INC C			; started with '$' ?
	DEC C
	JR NZ,L0837		; no, quit
	SUB 7			; 'A' --> 10, 'B' --> 11
	CP 10			; < 10 ?
	JR C,L0837		; yes, quit
	CP 16			; >= 16 ?
	JR NC,L0837		; yes, quit
L0820:	LD D,H			; save old HL
	LD E,L
	ADD HL,HL		; * 2
	RET C			; quit if carry, overflow
	ADD HL,HL		; * 4
	RET C			; quit if error
	INC C			; hexadecimal ?
	DEC C
	JR NZ,L082C
	LD D,H			; yes, hexadecimal (perform * 16)
	LD E,L
L082C:	ADD HL,DE		; * 5 if decimal
				; * 8 if hexadecimal
	RET C			; quit if error
	ADD HL,HL		; * 10 if decimal
				; * 16 if hexadecimal
	RET C			; quit if error
	LD E,A
	LD D,0
	ADD HL,DE		; * 10 + digit if decimal
				; * 16 + digit if hexadecimal
	RET C			; quit if error
	JR L0802 		; go for the next digit

L0837:   OR A
	;RET Z			; quit if carry reset if hexadecimal
				; allow hexadecimals that are negative
				; decimals
	;LD A,H
	;ADD A,A
	RET			; quit with carry set if HL > 32767?

A2L_FLAG:DB 0                       ; hexadecimal flag
				; 0 = convert as hexadecimal
				; NonZero = convert as decimal
A2L:     ; ASCII hexadecimal or decimal to LONGINT
	; converts ascii hexadecimal or decimal number at IX to
	; an unsigned value in DE:HL
	; in:	IX = address of ascii digit sequence
	; out:	carry set if value out of range
	;	carry reset, DE:HL = unsigned value
         ;        A = 0, if hexadecimal constant parsed
	LD A,(IX+0)
	SUB '$'
	LD (A2L_FLAG),A
	LD HL,0			; DE:HL = 0
	LD DE,0
	JR NZ,A2L04		; NonZero, do not skip '$' character

A2L02:	INC IX

A2L04:   LD A,(A2L_FLAG)
         LD C,A
         LD A,(IX+0)
	CALL L04A6		; upcase
	SUB '0'                    ; < '0' ?
	JR C,A2L37		; yes, quit --> error
	CP 10			; < 10 ?
	JR C,A2L20		; yes, continue

	; A..F ?
         INC C                      ; started with '$' ?
         DEC C
         JR NZ,A2L37                ; no, quit --> error

	; hexadecimal
	SUB 7			; 'A' --> 10, 'B' --> 11
	CP 10			; < 10 ?
         JR C,A2L37                 ; yes, quit --> error
	CP 16			; >= 16 ?
         JR NC,A2L37                ; yes, quit --> error

A2L20:   PUSH AF
         LD A,(A2L_FLAG)
	OR A			; hexadecimal or decimal ?
	JR Z,A2L_HEX		; jump if hexadecimal

	; multiply DE:HL by 10 with overflow detection
	PUSH DE			; save old DE:HL * 1
	PUSH HL
	CALL L_M2		; DE:HL * 2
	JR C,A2L38		; quit if carry, overflow

	CALL L_M2		; DE:HL * 4
	JR C,A2L38		; quit if carry, overflow

	POP BC			; DE:HL * 4 + DE:HL * 1
	ADD HL,BC
	EX DE,HL
	POP BC
	ADC HL,BC
	EX DE,HL
         POP BC
         LD A,B                     ; A = digit to add
         RET C                      ; quit if carry, overflow

         CALL L_M2                  ; DE:HL * 2
         RET C
         JR A2L36                   ; add the current digit

A2L_HEX: POP AF
         CALL L_M2                  ; DE:HL * 2
	RET C			; quit if carry, overflow
	CALL L_M2		; DE:HL * 4
	RET C			; quit if carry, overflow
	CALL L_M2		; DE:HL * 8
	RET C			; quit if carry, overflow
	CALL L_M2		; DE:HL * 16
	RET C			; quit if carry, overflow

A2L36:   ; add the new digit and repeat
         LD C,A
         LD B,0
         ADD HL,BC
         EX DE,HL
         LD BC,0
         ADC HL,BC
         EX DE,HL
         JR A2L02                   ; go for the next digit

A2L37:   LD A,C
	OR A
	RET

A2L38:   POP HL
         POP HL
	POP DE
	RET

L_M2:    ; in:    DE:HL
	; out:	DE:HL * 2
	;	Carry if overflow
	ADD HL,HL
	EX DE,HL
	ADC HL,HL
	EX DE,HL
	RET

; ------------------------------------------------------
; ------------------------------------------------------
; ------------------------------------------------------
; ------------------------------------------------------
; ------------------------------------------------------


L09E9:   ; REAL + REAL
         CALL L0A0D                 ; LIB

L09EC:	RET NC
	LD A,1			; r.error 1: Floating point overflow
	JP L2027 		; Run-time error


L0A03:   LD A,2                     ; r.error 2: Division by zero attempted
	JP Z,L2027		; Run-time error
         CALL L0AF5
	JR L09EC

L0A0D:	EXX
	BIT 7,B
	EXX
	JP NZ,L0A88
L0A14:	EXX
	LD A,L
	OR A
	EXX
	RET Z
	EXX
	PUSH BC
	PUSH DE
	PUSH HL
	EXX
	LD A,L
	OR A
	JR NZ,L0A27
	EXX
	RES 7,B
	JR L0A7B
L0A27:	PUSH BC
	SET 7,B
	XOR A
	EX AF,AF'
	EXX
	SET 7,B
	LD A,L
	EXX
	SUB L
	JR Z,L0A47
	JR NC,L0A3C
	NEG
	EX AF,AF'
	DEC A
	EX AF,AF'
	EXX
L0A3C:	CALL L0B7A
	INC L
	DEC A
	JR NZ,L0A3C
	EX AF,AF'
	JR Z,L0A47
	EXX
L0A47:	POP AF
	AND 80H
	JR NZ,L0A5B
	CALL L0B92
	JR NC,L0A76
	CALL L0B7B
	OR A
	INC L
	JR NZ,L0A76
	SCF
	JR L0A7B
L0A5B:	CALL L0BC6
	CCF
	PUSH AF
	JR Z,L0A72
	JR C,L0A65
	EXX
L0A65:	CALL L0BAC
L0A68:	BIT 7,B
	JR NZ,L0A75
	CALL L0B86
	DEC L
	JR NZ,L0A68

L0A72:	CALL L0B72		; HLDEBC = 0.0

L0A75:	POP AF
L0A76:	JR C,L0A7A
	RES 7,B
L0A7A:	OR A
L0A7B:	EXX
	POP HL
	POP DE
	POP BC
	EXX
	RET
L0A81:	EXX
	BIT 7,B
	EXX
	JP NZ,L0A14
L0A88:	CALL L0A8F
	CALL L0A14
	RET C
L0A8F:	INC L
	DEC L
	RET Z
	LD A,B
	XOR 80H
	LD B,A
	RET
L0A97:	EXX
	LD A,L
	OR A
	EXX
	JP Z,L0B72		; Zero --> HLDEBC = 0.0

	LD A,L
	OR A
	RET Z
	EXX
	ADD A,L
	EXX
	CALL L0B4D
	PUSH BC
	PUSH DE
	PUSH HL
	ADD IX,SP

IFNDEF FASTREAL
	CALL L0B72		; HLDEBC = 0.0
	EXX
	LD L,5
	EXX
L0AB3:	LD A,8
	INC IX
IFDEF MSX
	LD L,(IX+0)
ELSE
;!	mov bl,ss:[si + 0]	; read from stack !!! ----
ENDIF
L0ABA:	EX AF,AF'
	RR L
	JR NC,L0AC2
	CALL L0B92
L0AC2:	CALL L0B7B
	EX AF,AF'
	DEC A
	JR NZ,L0ABA
	EXX
	DEC L
	EXX
	JR NZ,L0AB3

ELSE	; FASTREAL

	EXX
	PUSH BC
	LD C,H
	EXX
	POP DE			; BCDEHL' --> DED'E'C'

	XOR A			; HLH'L'A = 0
	LD L,A
	LD H,A
	EXX
	LD L,A
	LD H,A
	LD B,5			; B' = byte count
	EXX

MultReal1:
	LD B,8			; B = bit count
	INC IX
;         LD C,(IX+0)
IFDEF MSX
         LD C,(IX+0)
ELSE
;!       mov cl,ss:[si + 0]         ; read from stack !!! ----
ENDIF

MultReal2:
	RR C
	JR NC,MultReal3
	EXX
	ADD A,C
	ADC HL,DE
	EXX
	ADC HL,DE

MultReal3:
	RR H
	RR L
	EXX
	RR H
	RR L
	EXX
	RRA

	DJNZ MultReal2

	EXX
	DEC B
	EXX
	JR NZ,MultReal1

	; BCDEH = HLH'L'A
	LD B,H
	LD C,L
	LD H,A
	EXX
	PUSH HL
	EXX
	POP DE

	EX AF,AF'                  ; save Carry from RRA

ENDIF	; FASTREAL

IFDEF MSX
	LD L,(IX-5)
ELSE
;!	mov bl,ss:[si - 5]
ENDIF
	BIT 7,B
	JR NZ,L0ADE
	EX AF,AF'
	CALL L0B87
	INC L
	DEC L
	JR Z,L0ADE
	DEC L
L0ADE:	POP AF
	POP AF
	POP AF

L0AE1:	OR A

L0AE2:	EX AF,AF'
	POP AF
	EXX
	POP BC
	POP DE			; FastReal
	POP HL
	EXX
	POP IX
	RES 7,B
	OR B
	LD B,A
	INC L
	DEC L
	CALL Z,L0B72		; Zero --> HLDEBC = 0.0

	EX AF,AF'
	RET

L0AF5:	LD A,L
	OR A
	RET Z
	EXX
	SUB L
	EXX
	CCF
	CALL L0B4D
	PUSH HL
L0B00:	PUSH HL
	PUSH HL
	ADD IX,SP

IFNDEF FASTREAL
	EXX
	LD L,5
	EXX
	LD A,8
L0B0A:	EX AF,AF'
	CALL L0BC6
	JR C,L0B13
	CALL L0BAC
L0B13:	CCF
	RL L
	EX AF,AF'
	DEC A
	JR NZ,L0B26
IFDEF MSX
	LD (IX+5),L
ELSE
;!	mov byte ptr ss:[si+5],bl
ENDIF
	DEC IX
	EXX
	DEC L
	EXX
	JR Z,L0B32
	LD A,8
L0B26:	CALL L0B86
	JR NC,L0B0A
	EX AF,AF'
	CALL L0BAC
	OR A
	JR L0B13
L0B32:	CALL L0B86
	JR C,L0B3B
	CALL L0BC6
	CCF
ELSE	; FASTREAL

	LD A,H
	EX AF,AF'
	LD H,B
	LD L,C
	PUSH DE
	EXX
	LD A,H
	POP HL
	PUSH BC
	LD C,A
	LD B,5			; B' = byte count
	EXX
	POP DE
	EX AF,AF'

	LD B,8			; B = bit count

DivReal1:CALL CompMantisse
	JR C,DivReal2

	; SubMantisse
	EXX
	SUB C
	SBC HL,DE
	EXX
	SBC HL,DE

DivReal2:CCF
	RL C

	DJNZ DivReal3

;         LD (IX+5),C
IFDEF MSX
         LD (IX+5),C
ELSE
;!       mov byte ptr ss:[si+5],cl
ENDIF
	DEC IX

	EXX
	DEC B
	EXX
	JR Z,DivReal4

	LD B,8			; B = bit count

DivReal3:; SLAMantisse
	OR A
	RLA
	EXX
	ADC HL,HL
	EXX
	ADC HL,HL
	JR NC,DivReal1

	; SubMantisse
	EXX
	SUB C
	SBC HL,DE
	EXX
	SBC HL,DE
	OR A
	JP DivReal2

DivReal4:; SLAMantisse
	OR A
	RLA
	EXX
	ADC HL,HL
	EXX
	ADC HL,HL
	JR C,DivReal5

	CALL CompMantisse
	CCF

DivReal5:

ENDIF	; FASTREAL

L0B3B:	POP HL
	POP DE
	POP BC
;!       lahf                       ; store carry in ah

         BIT 7,B
         JR NZ,L0B47

;!       sahf                       ; restore carry
         CALL L0B87
	JP L0AE1

IFDEF FASTREAL
CompMantisse:
	OR A
	SBC HL,DE
	PUSH AF
	ADD HL,DE
	POP AF
	RET NZ

	EXX
	OR A
	SBC HL,DE
	PUSH AF
	ADD HL,DE
	POP AF
	EXX
	RET NZ

	EXX
	CP C
	EXX
	RET

ENDIF	; FASTREAL

L0B47:	INC L
	JP NZ,L0AE1
	SCF
	JP L0AE2

L0B4D:	JR C,L0B55
	ADD A,80H
	JR C,L0B59
	JR L0B70
L0B55:	ADD A,80H
	JR C,L0B70
L0B59:	LD L,A
	EX (SP),IX
	EXX
	PUSH HL
	PUSH DE
	PUSH BC
	LD A,B
	SET 7,B
	EXX
	XOR B
	AND 80H
	PUSH AF
	SET 7,B
	PUSH IX
	LD IX,0
	RET
L0B70:	POP HL
	RET C

L0B72:	; create a REAL HLDEBC with 0.0 as value
	; in:	-
	; out:	REAL HLDEBC filled with zeroes
	XOR A
	LD L,A
	LD B,A
	LD C,A
	LD D,A
	LD E,A
	LD H,A
	RET

L0B7A:	OR A
L0B7B:	RR B
	RR C
	RR D
	RR E
	RR H
	RET

L0B86:   OR A

L0B87:   RL H
	RL E
	RL D
	RL C
	RL B
	RET

L0B92:   LD A,H
	EXX
	ADD A,H
	EXX
	LD H,A
	LD A,E
	EXX
	ADC A,E
	EXX
	LD E,A
	LD A,D
	EXX
	ADC A,D
	EXX
	LD D,A
	LD A,C
	EXX
	ADC A,C
	EXX
	LD C,A
	LD A,B
	EXX
	ADC A,B
	EXX
	LD B,A
	RET
L0BAC:	LD A,H
	EXX
	SUB H
	EXX
	LD H,A
	LD A,E
	EXX
	SBC A,E
	EXX
	LD E,A
	LD A,D
	EXX
	SBC A,D
	EXX
	LD D,A
	LD A,C
	EXX
	SBC A,C
	EXX
	LD C,A
	LD A,B
	EXX
	SBC A,B
	EXX
	LD B,A
	RET

L0BC6:	LD A,B
	EXX
	CP B
	EXX
	RET NZ
	LD A,C
	EXX
	CP C
	EXX
	RET NZ
	LD A,D
	EXX
	CP D
	EXX
	RET NZ
	LD A,E
	EXX
	CP E
	EXX
	RET NZ
	LD A,H
	EXX
	CP H
	EXX
	RET

L0BDF:	; Compare REALS
	EXX
	LD A,B
	EXX
	XOR B
	JP P,L0BE9
	LD A,B
	RLA
	RET
L0BE9:	BIT 7,B
	JR Z,L0BF3
	CALL L0BF3
	RET Z
	CCF
	RET
L0BF3:	LD A,L
	EXX
	CP L
	EXX
	RET NZ
	OR A
	RET Z
	JP L0BC6


L0F73:   ; in:    IX = address of REAL
	; out:	HLDEBC = REAL located at address IX
	;	IX unchanged
	LD L,(IX+0)
	LD H,(IX+1)
	LD E,(IX+2)
	LD D,(IX+3)
	LD C,(IX+4)
	LD B,(IX+5)
	RET

L0F86:   LD HL,81H                  ; 1.0
	LD B,H
	LD C,H
	LD D,H
	LD E,H
	RET

L10031:  LD A,93H                   ; r.error 93H: Out of LONGINT range
	JP L2027

L1008:   LD A,H                     ; LIB, convert integer HL to REAL HLDEBC
	OR L
	JP Z,L0B72		; return 0.0 REAL if HL = 0

	BIT 7,H
	EX AF,AF'                  ; save NZ for negative

         CALL L0780                 ; absolute HL

	LD A,90H

	; shift, normalization
L1015:   ADD HL,HL
	DEC A
	BIT 7,H
	JR Z,L1015

	LD B,H			; BC = integer, bit 7 of B always '1'
	LD C,L
	LD DE,0			; D = E = 0
	LD H,D			; H = 0
	LD L,A

	EX AF,AF'
	RET NZ			; keep bit 7 of B '1' if negative

	RES 7,B			; no, make if positive
	RET

L_NEG:   ; X = -X : LONG
	; in:	X in DEHL
	; out:	DEHL
         ; changes: BC, A = 0
	LD C,L			; BC = low-word
	LD B,H
	XOR A			; Carry = 0
	LD L,A
	LD H,A
	SBC HL,BC		; 0 - low-word
	EX DE,HL
	LD C,L			; BC = high-word
	LD B,H
	LD L,A
	LD H,A
	SBC HL,BC		; 0 - high-word - carry
	EX DE,HL
	RET

L_R:     ; convert LONGINT DEHL to REAL HLDEBC
	; in:	DEHL = signed LONGINT
	; out:	HLDEBC = REAL
	LD A,H
	OR L
	OR D
	OR E
	JP Z,L0B72		; jump if long is zero

	BIT 7,D			; is this long negative ?
	PUSH AF			; rember this
	CALL NZ,L_NEG		; make positive if long is negative
	LD A,0A0H

	; perform normlization
L_R_SH:	ADD HL,HL
	EX DE,HL
	ADC HL,HL
	EX DE,HL
	DEC A
	BIT 7,D
	JR Z,L_R_SH		; shift until bit 31 = '1'

	EX DE,HL 		; HL:DE = normalized mantissa
	LD B,H
	LD C,L
	LD H,0
	LD L,A			; exponent + 81H in A
	POP AF			; ZeroFlag = 0 if long was negative
	RET NZ			; if negative then leave bit 7 of B '1'

	RES 7,B
	RET

R_L:     ; convert REAL HLDEBC to LONGINT DEHL
	; in:	HLDEBC = REAL
	; out:	DEHL = signed LONGINT
	BIT 7,L			; exponent < 80H then float = 0.0
				; in other words float < 1.0
	JP Z,L0B72		; return DEHL = 0 if REAL < 1.0

	BIT 7,B			; ZeroFlag = 0 if REAL is negative
	PUSH AF			; save sign of REAL

	SET 7,B			; restore hidden bit

R_L_SH:	LD A,9FH
	CP L			; more than 31 bits before the comma
	JR C,L10031		; r.error 93H: Out of LONGINT range

	JR Z,R_L_READY		; jump if no more shifts
	SRL B
	RR C
	RR D
	RR E
	RR H
	INC L
	JR R_L_SH		; go for next possible shift

R_L_READY:
	SRL B
	RR C
	RR D
	RR E
	RR H
	POP AF			; restore sign of REAL
	LD H,B
	LD L,C			; long HLDE complete, if positive
	EX DE,HL 		; deliver in format DE:HL

	RET Z			; return if float was positive

	JP L_NEG 		; make long negative if REAL was negative

L1027:   ; in:    BCDEHL' = REAL to convert to ASCII
         ;        HL = number of digits after decimal point
         CALL L04C8                 ; int to byte
	EX DE,HL
	LD E,0
	JR C,L1033
	CP 19H
	JR C,L104B

L1033:	DEC E
	CALL L04C8		; int to byte
	EXX
	BIT 7,B			; NonZero if REAL HLDEBC is negative
	EXX
	LD D,7			; 7 digits if positive
	JR Z,L1040

	INC D			; no, 8 digits, sign included

L1040:	SUB D			; subtract from total bytes of space
	JR NC,L1044		; jump if enough room
	XOR A
L1044:	CP 9			; less than 9 digits of space left ?
	JR C,L104A		; yes, jump

	LD A,9			; no, make it 9 digits at the most

L104A:	INC A

L104B:	LD D,A
	PUSH DE
	EXX
	LD IY,L005D		; destination for ascii-float
	PUSH IX
	CALL L10EB		; convert HLDEBC to ascii at IY
	POP IX
	POP DE
	LD C,A
	LD A,D
	INC A
	BIT 7,E
	JR NZ,L1071
	ADD A,C
	JP P,L106B

	LD (IY+0),0
	JR L1076

L106B:	CP 0CH
	JR C,L1071

	LD A,0BH

L1071:	PUSH DE
	CALL L1180
	POP DE
L1076:	BIT 7,B
	JR Z,L107F

	LD A,'-'
	CALL L10E5		; add '-' at (IX+0)

L107F:	BIT 7,E
	JR Z,L1086
	LD H,C
	LD C,0
L1086:	BIT 7,C
	JR Z,L108F

	CALL L10E3		; add '0' at (IX+0)
	JR L1096

L108F:	CALL L10D9
	DEC C
	JP P,L108F

L1096:	LD A,D
	OR A
	JR Z,L10B1

	LD A,'.'
	CALL L10E5		; add '.' at (IX+0)

L109F:	INC C
	JR Z,L10A8

	CALL L10E3		; add '0' at (IX+0)
	DEC D
	JR NZ,L109F
L10A8:	DEC D
	JP M,L10B1
	CALL L10D9
	JR L10A8

L10B1:	BIT 7,E
	RET Z

	LD A,'E'
	CALL L10E5		; add 'E' at (IX+0)

	LD A,'+'                   ; add '+'
	BIT 7,H
	JR Z,L10C5
	LD A,H
	NEG
	LD H,A

	LD A,'-'
L10C5:	CALL L10E5		; add '+' or '-' at (IX+0)
	LD A,H
	LD B,'0'-1

L10CB:	INC B
	SUB 10
	JR NC,L10CB

	ADD A,'0'+10
	LD (IX+0),B
	INC IX
	JR L10E5

L10D9:	LD A,(IY+0)
	INC IY
	OR A
	JR NZ,L10E5

	DEC IY

L10E3:	LD A,'0'
L10E5:	LD (IX+0),A
	INC IX
	RET

L10EB:	; in:	IY = destination address for REAL in ASCII format
	;	HLDEBC = REAL
	PUSH IY
	INC L			; REAL represents zero?
	DEC L
	JR NZ,L10FF		; no, continue

	; fill destination address at IY with 12 '0' characters
	LD B,12
L10F3:	LD (IY+0),'0'
	INC IY
	DJNZ L10F3
	XOR A
	JP L117D 		; jump POP IY and RET

L10FF:	PUSH BC
	RES 7,B
	LD A,L
	EXX
	SUB 80H
	LD L,A
	SBC A,A			; A = 255, if L was < 80H, otherwise A = 0
	LD H,A			; HL = signed L - 80H = exponend
	LD DE,4DH
	CALL L06F5		; LIB
	LD DE,5
	ADD HL,DE
	LD A,H
	CP 0D9H
	JR NZ,L1119
	INC A
L1119:	LD (IY+0),A
	NEG
	CALL L1240
	LD A,L
	CP 81H
	JR NC,L112C
	CALL L12B3
	DEC (IY+0)
L112C:	SET 7,B
	LD A,84H
	SUB L
	LD L,0
	JR Z,L113D
L1135:	CALL L0B7A
	RR L
	DEC A
	JR NZ,L1135
L113D:	LD A,(IY+0)
	PUSH AF
	LD A,0CH
L1143:	EX AF,AF'
	LD A,B
	RRA
	RRA
	RRA
	RRA
	AND 0FH
	ADD A,30H
	LD (IY+0),A
	INC IY
	LD A,B
	AND 0FH
	LD B,A
	PUSH BC
	PUSH DE
	PUSH HL
	SLA L
	CALL L0B87
	SLA L
	CALL L0B87
	EX DE,HL
	EX (SP),HL
	ADD HL,DE
	POP DE
	EX (SP),HL
	ADC HL,DE
	EX DE,HL
	POP HL
	EX (SP),HL
	ADC HL,BC
	LD B,H
	LD C,L
	POP HL
	SLA L
	CALL L0B87
	EX AF,AF'
	DEC A
	JR NZ,L1143		; repeat until ready with conversion
	POP AF
	POP BC
L117D:	POP IY
	RET


	; ----------
	; subroutine
	; ----------
L1180:	PUSH IY
	POP HL
	LD E,A
	LD D,0
	ADD HL,DE
	LD A,(HL)
	LD (HL),0
	CP 35H
	RET C

L118D:	DEC E
	JP M,L119C
	DEC HL
	LD A,(HL)
	INC A
	LD (HL),A
	CP 3AH
	RET C
	LD (HL),0
	JR L118D

L119C:	LD (HL),31H
	INC HL
	LD (HL),0
	INC C
	RET
	; ----------

L11A3:	; converts ascii REAL at IX to binary REAL in HLDEBC
	; in:	IX = address of ascii REAL
	; out:	carry set if conversion did not succeed
	EXX
	LD BC,0
	EXX
	CALL L0B72		; HLDEBC = 0.0

L11AB:	LD A,(IX+0)
	CALL L04A6		; upcase
	CP '.'
	JR NZ,L11C1

	EXX
	BIT 6,B
	SCF
	RET NZ

	SET 6,B
	EXX
L11BD:	INC IX
	JR L11AB

L11C1:	CP 'E'
	JR Z,L11E6
	CALL L1239
	JR NC,L121E
	EX AF,AF'
	CALL L12B3
	RET C
	EX AF,AF'
	EXX
	PUSH BC
	LD L,A
	LD H,0
	CALL L1008		; convert integer HL to REAL HLDEBC
	CALL L09E9
	EXX
	POP BC
	RET C
	BIT 6,B
	JR Z,L11E3
	DEC C
L11E3:	EXX
	JR L11BD

L11E6:	CALL L121E
	RET C

	EXX
	SET 4,B
	INC IX

	LD A,(IX+0)

	CP '+'
	JR Z,L11FC		; jump if '+', ignore it

	CP '-'
	JR NZ,L11FE

	SET 5,B			; set bit 5 for negative

L11FC:	INC IX
L11FE:	CALL L1236		; check digit at (IX+0)
	CCF
	RET C
	LD C,A
	INC IX
	CALL L1236		; check digit at (IX+0)
	JR NC,L1215
	INC IX
	LD D,A
	LD A,C
	ADD A,A
	ADD A,A
	ADD A,C
	ADD A,A
	ADD A,D
	LD C,A
L1215:	BIT 5,B
	JR Z,L121D
	LD A,C
	NEG
	LD C,A
L121D:	EXX

L121E:	EXX
	LD A,C
	ADD A,80H
	CP 5AH
	RET C
	CP 0A6H
	CCF
	RET C
	PUSH BC
	PUSH IX
	LD A,C
	CALL L1240
	POP IX
	EXX
	POP BC
	EXX
	RET

L1236:	; checks if byte at (IX+0)

	LD A,(IX+0)

L1239:	; in:	A = byte to check
	; out:	A = 0 .. 9
	;	C-flag set if A is a correct digit
	SUB '0'
	CCF
	RET NC
	CP 10
	RET

L1240:	PUSH AF
	OR A
	JP P,L1247
	NEG

L1247:	PUSH AF
	SRL A
	SRL A
	INC A
	LD HL,-6
	LD DE,6

L1253:	ADD HL,DE
	DEC A
	JR NZ,L1253
	EX DE,HL
	LD IX,L1277
	ADD IX,DE
	CALL L0F73		; get REAL at address IX
	POP AF
	AND 3
	JR Z,L126E

L1266:	PUSH AF
	CALL L12B3
	POP AF
	DEC A
	JR NZ,L1266
L126E:	POP AF
	OR A
	JP P,L0A97
	EXX
	JP L0AF5

L1277:	DB  81H,  0 ,  0 ,  0 ,  0 ,  0	; 1.0E+00
	DB  8EH,  0 ,  0 ,  0 , 40H, 1CH	; 1.0E+04
	DB  9BH,  0 ,  0 , 20H,0BCH, 3EH	; 1.0E+08
	DB 0A8H,  0 , 10H,0A5H,0D4H, 68H	; 1.0E+12
	DB 0B6H,  4 ,0BFH,0C9H, 1BH, 0EH	; 1.0E+16
	DB 0C3H,0ACH,0C5H,0EBH, 78H, 2DH	; 1.0E+20
	DB 0D0H,0CDH,0CEH, 1BH,0C2H, 53H	; 1.0E+24
	DB 0DEH,0F9H, 78H, 39H, 3FH,  1	; 1.0E+28
	DB 0EBH, 2BH,0A8H,0ADH,0C5H, 1DH	; 1.0E+32
	DB 0F8H,0C9H, 7BH,0CEH, 97H, 40H	; 1.0E+36

L12B3:	LD A,L
	OR A
	RET Z
	SET 7,B
	PUSH BC
	PUSH DE
	LD A,H
	CALL L0B7A
	CALL L0B7A
	ADD A,H
	LD H,A
	EX (SP),HL
	ADC HL,DE
	EX DE,HL
	POP HL
	EX (SP),HL
	ADC HL,BC
	LD B,H
	LD C,L
	POP HL
	JR NC,L12D6
	CALL L0B7B
	INC L
	SCF
	RET Z

L12D6:	LD A,L
	ADD A,3
	LD L,A
	RES 7,B
	RET


L149B:   ; LIB
	; sets current FIB address to standard output (OUTPUT)
	; in:	HL = FIB address
	; out:	-
	EX (SP),HL		; LIB, for search ???
	LD (L00E4),HL		; save return address
	EX (SP),HL
	PUSH HL
	LD HL,OUTPUT
	LD (L00E2),HL
	POP HL
	RET


L14E8:   LD B,0                     ; ^Z is ignored when typed in

L14EA:   LD HL,BUFLEN
	LD A,(HL)
	CP 7FH			; < 127
	JR C,L14F4		; jump if < 127

	LD A,7EH 		; trunc to a length of 126 characters
L14F4:	LD C,A
	LD (HL),7EH
	LD HL,(L00D2)
	LD (L00D4),HL
L14FD:	LD D,0

L14FF:	CALL L03E1		; A = character from console
	LD (HL),A

	LD E,1
	CP 8			; backspace ?
	JR Z,L153F
	CP 7FH
	JR Z,L153F

	DEC E			; E = 0
	CP 18H			; insert ?
	JR Z,L153F
	CP 1BH			; escape ?
	JR Z,L153F

	CP 1AH			; ctrl-z ?
	JR Z,L1550		; jump to quit with ^Z

	CP 0DH			; return ?
	JR Z,L1556

	CP ' '                     ; space ?
	JR NC,L1533
	CP 3			; ctrl-break ?
	JR NZ,L14FF
	LD A,(CBREAK)
	OR A
	JR Z,L14FF		; ignore character if no CBREAK handler
	LD IX,(L00E4)		; IX = return address
	JP L2016 		; force userbreak

L1533:	LD A,C
	CP D
	JR Z,L14FF
	LD A,(HL)
	INC D
	INC HL
	CALL L03C9		; print character
	JR L14FF

L153F:	DEC D
	JP M,L14FD
	DEC HL
	CALL L0200
	DB 8,' ',8,0               ; backspace, space, backspace
	DEC E
	JR Z,L14FF
	JR L153F

L1550:	INC B
	DEC B
	JR Z,L14FF
	JR L155A 		; quit with ^Z

L1556:	INC B
	DEC B
	JR NZ,L155E		; jump if quit with 0DH,0Ah

L155A:	; quit with ^Z
	LD (HL),1AH
	JR L1566 		; quit

L155E:	CALL L01E1		; print CR, LF
	LD (HL),0DH
	INC HL
	LD (HL),0AH
L1566:	INC HL
	LD (L00D6),HL		; save end address
	RET

L156B:   ; read character from current file or device
	; out:	A = character read
	LD HL,(L00E2)
	LD A,(L00D0)		; read IORESULT
	OR A
	JR NZ,L15ED		; jump if error occurred, return EOF

	LD A,(HL)
	BIT 5,A
	JR NZ,L15E9		; jump if pre-read character present

	AND 0FH
	JR NZ,L15AB		; jump if device

	; read character from text file
	OFF_HL 0 FIB_PTR
;	 INC HL
;	 INC HL
	LD A,(HL)		; A = FIB_PTR
	OR A
	JP P,L1597		; < 128 ?

	; read next FIB_BUF
	LD C,14H 		; sequential read
	PUSH HL
	CALL L19BA		; sequential read from current position
				; to FIB_BUF
	POP HL
	JR Z,L1595		; jump if no error

	; error occurred, fill first byte of FIB_BUF with ^Z (end of file)
	PUSH HL
	OFF_HL FIB_PTR FIB_BUF
;	 LD DE,2EH
;	 ADD HL,DE
	LD (HL),1AH
	POP HL			; restore to FIB_PTR

L1595:	XOR A
	LD (HL),A		; FIB_PTR = 0

L1597:	INC (HL)
	ADD A,FIB_BUF - FIB_PTR	; 2EH
	LD E,A
	LD D,0
	ADD HL,DE
	LD A,(HL)
	CP 1AH			; first character = ^Z (eof)
	JR NZ,L15E0

	LD HL,(L00E2)
	OFF_HL 0 FIB_PTR
;	 INC HL
;	 INC HL
	DEC (HL) 		; FIB_PTR does not move beyond ^Z
	JR L15E0

L15AB:	DEC A			; device = 1, 'CON:' ?
	JR NZ,L15C9		; jump if not 'CON:'
	LD HL,(L00D4)
	LD DE,(L00D6)
	OR A
	SBC HL,DE
	JR C,L15BF		; read from buffer until current = end address

	LD B,0FFH
	CALL L14EA

L15BF:	LD HL,(L00D4)		; HL = data pointer
	LD A,(HL)		; A = data byte
	INC HL
	LD (L00D4),HL		; save new data pointer
	JR L15E0 		; put character in FIB_CHR

L15C9:	DEC A			; device = 2, 'KBD:' ?
	JR NZ,L15D2		; jump if not 'KBD:'

	CALL CONINPTR
	LD A,L
	JR L15E0 		; put character in FIB_CHR

L15D2:	DEC A			; skip 'LST:' (output device)
	DEC A			; device = 4, 'AUX:' ?
	JR NZ,L15DC		; jump if not 'AUX:', then device = 'USR:'

	CALL AUXINPTR
	LD A,L
	JR L15E0 		; put character in FIB_CHR

L15DC:	CALL USRINPTR
	LD A,L

L15E0:	LD HL,(L00E2)		; HL = address of FIB
	SET 5,(HL)		; set write semaphore
				; pre-read character ready
	OFF_HL 0 FIB_CHR
;	 INC HL
	LD (HL),A		; put character in character buffer
	OFF_HL FIB_CHR 0
;	 DEC HL
	RET

L15E9:	OFF_HL 0 FIB_CHR
;	 INC HL
	LD A,(HL)		; read pre-read from character buffer
	OFF_HL FIB_CHR 0
;	 DEC HL
	RET

L15ED:	LD A,1AH
	RET

L15F0:	PUSH HL
	LD HL,(L00E2)		; HL = address of FIB
	LD A,(HL)		; A = flags byte
	AND 0FH

	CP 6			; device 6 = used for 'val'
	JR Z,L1622		; quit immediately is device = 6

L15FB:	CALL L156B		; read character from file or device
	CP 21H
	JR NC,L160A
	CP 1AH
	JR Z,L160A
	RES 5,(HL)
	JR L15FB

L160A:	LD DE,L005D
	LD B,1EH
L160F:	PUSH BC
	PUSH DE
	CALL L156B		; read character from file or device
	POP DE
	POP BC
	CP 21H
	JR C,L1620
	RES 5,(HL)
	LD (DE),A
	INC DE
	DJNZ L160F
L1620:	XOR A
	LD (DE),A
L1622:	POP HL
	RET

L1624:	; in:	-
	; out:	B = 0 and IX = L005D --> no '-' found
	;	B = 1 and IX = L005E --> a '-' found
	;	Zero --> end of string reached
	LD IX,L005D
	LD A,(IX+0)
	OR A
	RET Z			; quit if zero

	LD B,0			; assume positive
	CP '-'                     ; minus sign ?
	RET NZ			; quit with NonZero of something else

	INC B			; no, negative number
	INC IX			; next character
         ; quit with NonZero (INC B)
	RET

L1636:	; checks a correct termination of the parsed string
	; in:	IX = position of character after parsed string
	;	Carry flag --> IORESULT = 10H
	; out:	NonCarry if '\0' found at (IX), A not changed
	;	Carry if no '\0' found at (IX), A changed
	; changes: AF, IORESULT

	JR C,L163D

	INC (IX+0)		; string correct ended ?
	DEC (IX+0)
	RET Z			; yes, quit

L163D:	LD A,10H
	LD (L00D0),A		; IORESULT = 10H, Error in numeric format
	SCF
	RET


L164E:   ; store as INTEGER
	XOR A			; store as INTEGER

L164F:	; in:	HL = destination address for INTEGER value
	;	IX = address of first ASCII character
	;	C = 0, store as INTEGER
	;	C = > 0, store as BYTE
	; out:	HL = INTEGER value
	;	DE = destination address + 1
	LD C,A
	PUSH BC
	CALL L15F0
	POP BC
         CALL L1624                 ; read an optional sign
         RET Z                      ; quit if end of ASCII-text

	; B = 0, no sign
	; B = 1, a sign
	PUSH BC
	PUSH HL			; save destination address

	CALL L07F7		; convert hexadecimal or decimal to HL

	POP DE			; DE = destination address
	POP BC			; B = sign flag
	; Carry if error at conversion

	CALL L1636		; conversion ended correct ?
	RET C			; quit if error

	DEC B			; B = 1 ?, a sign read ?
	CALL Z,L0783		; Zero --> negate HL

	EX DE,HL 		; HL = destination address
				; DE = INTEGER value
	LD (HL),E		; store low-byte

	INC C			; byte ?
	DEC C
	JR NZ,L1670		; yes, only low-byte stored

	INC HL
	LD (HL),D		; store high-byte

L1670:	EX DE,HL
	RET

L1671:	; in:	HL = destination address for LONGINT value
	;	IX = address of first ASCII character
	; out:	DE:HL = LONGINT value
	CALL L15F0

	CALL L1624		; read an optional sign
	RET Z

	; B = 0, no sign
	; B = 1, a sign
	PUSH HL			; save destination address
	PUSH BC			; save sign flag

	CALL A2L 		; convert hexadecimal or decimal to DE:HL

	POP BC			; B = sign flag

	PUSH AF
	DEC B
	CALL Z,L_NEG		; Zero --> negate LONGINT DE:HL
	POP AF

	POP BC			; BC = destination address
	; Carry if error at conversion

	CALL L1636		; conversion ended correct ?
	RET C			; quit if error

	PUSH BC			; save destination address
	LD B,H			; BC = low-word
	LD C,L
	POP HL			; HL = destination address

	LD (HL),C		; store low-word
	INC HL
	LD (HL),B
	INC HL

	LD (HL),E		; store high-word
	INC HL
	LD (HL),D
	LD H,B			; restore low-word
	LD L,C
	; return DE:HL
	RET


L16C6:	; in:	A = character
	; out:	character printed to a device or a file
	LD HL,(L00E2)		; HL = FIB address
	LD C,A			; C = character data

	LD A,(L00D0)		; read IORESULT
	OR A
	RET NZ			; quit if an error occurred
	LD A,(HL)
	AND 0FH
	JR NZ,L16E4		; jump if device

	OFF_HL 0 FIB_PTR
;	 INC HL
;	 INC HL			 ; offset to FIB_PTR
	PUSH HL
	LD A,(HL)		; A = low byte of FIB_PTR
	ADD A,FIB_BUF-FIB_PTR	; 2EH, distance between FIB_PTR and FIB_BUF
	LD E,A
	LD D,0
	ADD HL,DE
	LD (HL),C		; write character
	POP HL
	INC (HL) 		; increase FIB_PTR
	RET P			; quit if < 128
	JR L170C 		; write buffer if FIB_PTR = 128
				; why not directly to 'LD (HL),0' ???

L16E4:	CP 6
	JR Z,L16FD		; what kind of a device is this ????

	POP HL			; pop return address
	LD B,0
	PUSH BC			; push BC = character data
	PUSH HL			; push return address

	DEC A			; 1: device = 'CON:' ?
	JP Z,CONOUTPTR
	DEC A
	DEC A			; 3: device = 'LST:' ?
	JP Z,LSTOUTPTR
	DEC A			; 4: device = 'AUX:' ?
	JP Z,AUXOUTPTR
	JP USROUTPTR		; 5: device = 'USR:' ?

L16FD:	LD HL,(L00E8)
	LD A,(L00EA)
	CP (HL)
	RET Z
	INC (HL)
	LD E,(HL)		; DE = index
	LD D,0
	ADD HL,DE
	LD (HL),C		; write character in buffer
	RET

L170C:	; flushes the buffer to disk if it is not empty
	LD HL,(L00E2)
	OFF_HL 0 FIB_PTR
;	 INC HL
;	 INC HL
	LD A,(HL)		; A = low byte of FIB_PTR
	OR A
	RET Z			; quit if nothing written
	LD (HL),0		; reset to start of FIB_BUF

	LD C,15H 		; sequential write 128 bytes
	CALL L19BA		; write FIB_BUF to current position
	RET Z			; quit if no error
	LD A,0F0H
	LD (L00D0),A		; IORESULT = 0F0H, Disk write error
	RET


L1726:   ; LIB, print INTEGER
         ; in:    value to print is pushed on stack
         ;        HL = size in characters
         ;        (L00D2) destination address for ASCII result
         ; out:   -
         POP BC                     ; LIB
	POP DE
	PUSH BC
	LD IX,(L00D2)
	BIT 7,H
         JR Z,L1737                 ; jump if size = positive

         CALL L0783                 ; negate HL (size)
         EX DE,HL                   ; HL = value, DE = size
         JR L1745

L1737:   EX DE,HL                   ; HL = value, DE = size
	BIT 7,H
         JR Z,L1745                 ; jump if value = positive

         CALL L0783                 ; negate HL
         LD (IX+0),'-'              ; print minus sign
	INC IX

L1745:   PUSH DE                    ; push size

         CALL L07C6                 ; unsigned INTEGER to ASCII

L1749:   ; print string from character buffer (L00D2) with leading spaces if
         ; pushed size > characters written in buffer
         ; in:    total size wanted is pushed
         POP HL                     ; size, ( WRITELN(int : size) )

         CALL L04C8                 ; int to byte
         ; A = size

         LD DE,(L00D2)              ; DE = start of ASCII buffer
	PUSH IX
	POP HL
	OR A
         SBC HL,DE
         LD C,L                     ; C = characters written in buffer

         EX DE,HL                   ; HL = start of ASCII buffer

L1759:   ; in:   HL = start of ASCII buffer
         ;        C = characters written in buffer
         SUB C                      ; size - characters written
         JR C,L176A                 ; jump if size is less, no spaces first
         JR Z,L176A                 ; jump if size is equal, no spaces first

         LD B,A                     ; B = number of spaces to add
         PUSH HL                    ; save start of ASCII buffer

L1760:   LD A,' '
	PUSH BC
         CALL L16C6                 ; write space character
	POP BC
         DJNZ L1760                 ; repeat

         POP HL                     ; HL = start of ASCII buffer

L176A:   LD B,C                     ; B = characters in ASCII buffer
	INC B

L176C:	DEC B
         RET Z                      ; quit if all printed (or empty)

         LD A,(HL)                  ; A = chacacter to print
	PUSH BC
	PUSH HL
         CALL L16C6                 ; print character
	POP HL
	POP BC
         INC HL                     ; next one
	JR L176C

L1779:   ; LIB, print REAL
         ; in:    push REAL
         ;        push size
         ;        HL = number of digits after decimal point
         POP BC                     ; return address

         POP DE                     ; DE = size of real

         EXX
	POP HL			; HLDEBC = REAL to be printed
	POP DE
	POP BC
	EXX

         PUSH BC                    ; return address

         LD IX,(L00D2)              ; IX = destination address for ASCII
         PUSH DE                    ; push size

         CALL L1027                 ; convert REAL to ASCII

         JR L1749


L18A4:	EX (SP),HL
	LD (L00E4),HL
	EX (SP),HL
	LD (L00E2),HL
	LD A,(HL)
	AND 0C0H 		; read or write flags set?
	RET NZ			; yes, quit

L18B0:	LD A,4
	LD (L00D0),A		; IORESULT = 4, File not open
	RET

L19BA:	; write FIB_BUF to current position according to FCB
	LD HL,(L00E2)		; HL = address of FIB
	PUSH HL
	PUSH BC			; save record to write

	OFF_HL 0 FIB_BUF
;	 LD DE,FIB_BUF		 ; offset to BUFFER
;	 ADD HL,DE
	EX DE,HL
	LD C,1AH 		; C = set dma at FIB buffer
	CALL MSXDOS

	POP BC
	POP HL
	OFF_HL 0 FIB_FCB
;	 LD DE,FIB_FCB		 ; offset to FCB
;	 ADD HL,DE
	EX DE,HL
	CALL MSXDOS
	OR A
	RET


L1A26:	LD A,91H
	LD (L00D0),A		;  IORESULT = 91H, Seek beyond end-of-file
	RET


L2016:   LD DE,0001                 ; user break, D = 0 with error code = 1
	JR L202C

L2027:   ; Run-time error
	POP IX

         LD E,A                     ; E = error code
	LD D,2			; Run-time rror

L202C:   ; in:    D = 0, user break
	;	D = 1, I/O error, E = error number
	;	D = 2, Run-time error	E = error number
	PUSH DE
	CALL L037A
	POP DE

	XOR A
	LD (CBREAK),A
	LD HL,(L00CE)
	LD A,H
	OR L
	PUSH IX
	POP HL
         LD BC,(L00CC)
	SBC HL,BC
	LD BC,0015H
	ADD HL,BC
	LD (L00CE),HL
	OR A
	JR NZ,L2054
	PUSH DE			; save error type and code

	PUSH DE
	PUSH HL			; address where error occurred
         CALL ERRORPTR
	POP DE			; restore error type and code

L2054:	LD A,D
	OR A
	JR NZ,L206C
	CALL L0200		; D = 0 >> User Break
	DB '^C',0DH,0AH
	DB 'User break',0
	JR L2097

L206C:   DEC A
	JR NZ,L207A
	CALL L0200		; D = 1 >> I/O error
L2075	EQU $+3
	DB 0DH,0AH,'I/O',0
	JR L2088

L207A:	CALL L0200		; D = 2 >> Run-time error
	DB 0DH,0AH,'Run-time',0

L2088:	CALL L0200
	DB ' error ',0

L2093:	LD A,E
	CALL L04B4

L2097:	CALL L0200
	DB ', PC=',0
	LD HL,(L00CE)
	CALL L04AF
	JR L20BD

L20A8:   CALL L0200
	DB 'Not enough memory',0
L20BD:	CALL L0200
	DB 0DH,0AH,'Program aborted',0DH,0AH,0

L20D4:   LD A,(L00D8)
	OR A
;         JP Z,L278E
	LD C,0
	CALL MSXDOS

L20DE:	POP HL
	POP DE
	POP DE
	JP (HL)

;L20E2:

